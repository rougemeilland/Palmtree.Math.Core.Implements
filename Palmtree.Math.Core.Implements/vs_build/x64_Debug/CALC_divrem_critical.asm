; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__4522B509_pmc_internal@h DB 01H
__1C66ECB2_pmc_debug@h DB 01H
__7646DD32_calc_divrem_critical@c DB 01H
msvcjmc	ENDS
PUBLIC	CalculateCriticalDataOfDivision
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0FE@HJGKBDLB@found?3?5u0?$DN0x?$CF08x?0?5u1?$DN0x?$CF08x?0?5u2@ ; `string'
PUBLIC	??_C@_0GJ@FDENHGMK@found?3?5u0?$DN0x?$CF016llx?0?5u1?$DN0x?$CF016l@ ; `string'
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FROMWORDTODWORD DD imagerel _FROMWORDTODWORD
	DD	imagerel _FROMWORDTODWORD+85
	DD	imagerel $unwind$_FROMWORDTODWORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FROMDWORDTOWORD DD imagerel _FROMDWORDTOWORD
	DD	imagerel _FROMDWORDTOWORD+95
	DD	imagerel $unwind$_FROMDWORDTOWORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_UNIT_DIV DD imagerel _ADD_UNIT_DIV
	DD	imagerel _ADD_UNIT_DIV+114
	DD	imagerel $unwind$_ADD_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_SUBTRUCT_UNIT_DIV DD imagerel _SUBTRUCT_UNIT_DIV
	DD	imagerel _SUBTRUCT_UNIT_DIV+114
	DD	imagerel $unwind$_SUBTRUCT_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MULTIPLY_UNIT_DIV DD imagerel _MULTIPLY_UNIT_DIV
	DD	imagerel _MULTIPLY_UNIT_DIV+102
	DD	imagerel $unwind$_MULTIPLY_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_DIVREM_UNIT DD imagerel _DIVREM_UNIT
	DD	imagerel _DIVREM_UNIT+218
	DD	imagerel $unwind$_DIVREM_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CalculateCriticalDataOfDivision DD imagerel $LN17
	DD	imagerel $LN17+1197
	DD	imagerel $unwind$CalculateCriticalDataOfDivision
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ADD_3W_UNIT DD imagerel ADD_3W_UNIT
	DD	imagerel ADD_3W_UNIT+163
	DD	imagerel $unwind$ADD_3W_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ADD_4W_UNIT DD imagerel ADD_4W_UNIT
	DD	imagerel ADD_4W_UNIT+190
	DD	imagerel $unwind$ADD_4W_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SUBTRUCT_3W_UNIT DD imagerel SUBTRUCT_3W_UNIT
	DD	imagerel SUBTRUCT_3W_UNIT+163
	DD	imagerel $unwind$SUBTRUCT_3W_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SUBTRUCT_4W_UNIT DD imagerel SUBTRUCT_4W_UNIT
	DD	imagerel SUBTRUCT_4W_UNIT+190
	DD	imagerel $unwind$SUBTRUCT_4W_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AsumeQ_ DD imagerel AsumeQ_
	DD	imagerel AsumeQ_+148
	DD	imagerel $unwind$AsumeQ_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckQ_ DD imagerel CheckQ_
	DD	imagerel CheckQ_+324
	DD	imagerel $unwind$CheckQ_
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0GJ@FDENHGMK@found?3?5u0?$DN0x?$CF016llx?0?5u1?$DN0x?$CF016l@
CONST	SEGMENT
??_C@_0GJ@FDENHGMK@found?3?5u0?$DN0x?$CF016llx?0?5u1?$DN0x?$CF016l@ DB 'f'
	DB	'ound: u0=0x%016llx, u1=0x%016llx, u2=0x%016llx, u3=0x%016llx,'
	DB	' v1=0x%016llx, v2=0x%016llx, v3=0x%016llx', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@HJGKBDLB@found?3?5u0?$DN0x?$CF08x?0?5u1?$DN0x?$CF08x?0?5u2@
CONST	SEGMENT
??_C@_0FE@HJGKBDLB@found?3?5u0?$DN0x?$CF08x?0?5u1?$DN0x?$CF08x?0?5u2@ DB 'f'
	DB	'ound: u0=0x%08x, u1=0x%08x, u2=0x%08x, u3=0x%08x, v1=0x%08x, '
	DB	'v2=0x%08x, v3=0x%08x', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckQ_ DD 025053601H
	DD	011b2320H
	DD	070140035H
	DD	05013H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
CheckQ_$rtcName$0 DB 06cH
	DB	068H
	DB	05fH
	DB	06dH
	DB	069H
	DB	00H
	ORG $+2
CheckQ_$rtcName$1 DB 072H
	DB	068H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+2
CheckQ_$rtcName$2 DB 072H
	DB	068H
	DB	05fH
	DB	06dH
	DB	069H
	DB	00H
	ORG $+2
CheckQ_$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:CheckQ_$rtcVarDesc
	ORG $+8
CheckQ_$rtcVarDesc DD 0a4H
	DD	04H
	DQ	FLAT:CheckQ_$rtcName$2
	DD	084H
	DD	04H
	DQ	FLAT:CheckQ_$rtcName$1
	DD	044H
	DD	04H
	DQ	FLAT:CheckQ_$rtcName$0
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AsumeQ_ DD 025053101H
	DD	0116231bH
	DD	0700f0025H
	DD	0500eH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
AsumeQ_$rtcName$0 DB 072H
	DB	00H
	ORG $+14
AsumeQ_$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:AsumeQ_$rtcName$0
	ORG $+48
AsumeQ_$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:AsumeQ_$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SUBTRUCT_4W_UNIT DD 025053901H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SUBTRUCT_3W_UNIT DD 025053901H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ADD_4W_UNIT DD 025053901H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ADD_3W_UNIT DD 025053901H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CalculateCriticalDataOfDivision DD 045052a01H
	DD	010e4313H
	DD	0700700b9H
	DD	05006H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
CalculateCriticalDataOfDivision$rtcName$0 DB 075H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	05fH
	DB	030H
	DB	00H
	ORG $+6
CalculateCriticalDataOfDivision$rtcName$1 DB 075H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	05fH
	DB	031H
	DB	00H
	ORG $+2
CalculateCriticalDataOfDivision$rtcName$4 DB 075H
	DB	030H
	DB	00H
	ORG $+1
CalculateCriticalDataOfDivision$rtcName$2 DB 075H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	05fH
	DB	032H
	DB	00H
	ORG $+2
CalculateCriticalDataOfDivision$rtcName$5 DB 075H
	DB	031H
	DB	00H
	ORG $+1
CalculateCriticalDataOfDivision$rtcName$3 DB 075H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	05fH
	DB	033H
	DB	00H
	ORG $+2
CalculateCriticalDataOfDivision$rtcName$6 DB 075H
	DB	032H
	DB	00H
	ORG $+1
CalculateCriticalDataOfDivision$rtcName$7 DB 075H
	DB	033H
	DB	00H
	ORG $+1
CalculateCriticalDataOfDivision$rtcName$11 DB 076H
	DB	031H
	DB	00H
	ORG $+1
CalculateCriticalDataOfDivision$rtcName$8 DB 076H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	05fH
	DB	031H
	DB	00H
	ORG $+2
CalculateCriticalDataOfDivision$rtcName$12 DB 076H
	DB	032H
	DB	00H
	ORG $+1
CalculateCriticalDataOfDivision$rtcName$9 DB 076H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	05fH
	DB	032H
	DB	00H
	ORG $+2
CalculateCriticalDataOfDivision$rtcName$13 DB 076H
	DB	033H
	DB	00H
	ORG $+1
CalculateCriticalDataOfDivision$rtcName$10 DB 076H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	05fH
	DB	033H
	DB	00H
	ORG $+2
CalculateCriticalDataOfDivision$rtcName$14 DB 062H
	DB	075H
	DB	030H
	DB	00H
CalculateCriticalDataOfDivision$rtcName$15 DB 062H
	DB	075H
	DB	031H
	DB	00H
CalculateCriticalDataOfDivision$rtcName$16 DB 062H
	DB	075H
	DB	032H
	DB	00H
CalculateCriticalDataOfDivision$rtcName$17 DB 062H
	DB	075H
	DB	033H
	DB	00H
CalculateCriticalDataOfDivision$rtcName$18 DB 06dH
	DB	076H
	DB	031H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+1
CalculateCriticalDataOfDivision$rtcName$19 DB 06dH
	DB	076H
	DB	032H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+1
CalculateCriticalDataOfDivision$rtcName$20 DB 06dH
	DB	076H
	DB	033H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+5
CalculateCriticalDataOfDivision$rtcVarDesc DD 0404H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$20
	DD	03c4H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$19
	DD	0384H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$18
	DD	0364H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$17
	DD	0344H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$16
	DD	0324H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$15
	DD	0304H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$14
	DD	02c4H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$13
	DD	02a4H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$12
	DD	0284H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$11
	DD	0264H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$10
	DD	0244H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$9
	DD	0224H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$8
	DD	0204H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$7
	DD	01e4H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$6
	DD	01c4H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$5
	DD	01a4H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$4
	DD	0184H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$3
	DD	0164H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$2
	DD	0144H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$1
	DD	0124H
	DD	04H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcName$0
	ORG $+1008
CalculateCriticalDataOfDivision$rtcFrameData DD 015H
	DD	00H
	DQ	FLAT:CalculateCriticalDataOfDivision$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_DIVREM_UNIT DD 025053601H
	DD	011b2320H
	DD	070140021H
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MULTIPLY_UNIT_DIV DD 025053101H
	DD	0116231bH
	DD	0700f001dH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_SUBTRUCT_UNIT_DIV DD 025053701H
	DD	011b2320H
	DD	07014001dH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_UNIT_DIV DD 025053701H
	DD	011b2320H
	DD	07014001dH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FROMDWORDTOWORD DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FROMWORDTODWORD DD 025052c01H
	DD	01112316H
	DD	0700a001dH
	DD	05009H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
;	COMDAT CheckQ_
_TEXT	SEGMENT
lh_hi$ = 4
lh_mi$ = 36
lh_lo$ = 68
rh_hi$ = 100
rh_mi$ = 132
rh_lo$ = 164
tv86 = 372
q_$ = 416
u0$ = 424
u1$ = 432
u2$ = 440
v1$ = 448
v2$ = 456
CheckQ_	PROC						; COMDAT

; 69   : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 424				; 000001a8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+456]
	lea	rcx, OFFSET FLAT:__7646DD32_calc_divrem_critical@c
	call	__CheckForDebuggerJustMyCode

; 70   :     const __UNIT_TYPE_DIV lh_hi = 0;

	mov	DWORD PTR lh_hi$[rbp], 0

; 71   :     __UNIT_TYPE_DIV lh_mi;
; 72   :     __UNIT_TYPE_DIV lh_lo = _MULTIPLY_UNIT_DIV(v2, q_, &lh_mi);

	lea	r8, QWORD PTR lh_mi$[rbp]
	mov	edx, DWORD PTR q_$[rbp]
	mov	ecx, DWORD PTR v2$[rbp]
	call	_MULTIPLY_UNIT_DIV
	mov	DWORD PTR lh_lo$[rbp], eax

; 73   :     __UNIT_TYPE_DIV rh_hi;
; 74   :     __UNIT_TYPE_DIV rh_mi = _MULTIPLY_UNIT_DIV(q_, v1, &rh_hi);

	lea	r8, QWORD PTR rh_hi$[rbp]
	mov	edx, DWORD PTR v1$[rbp]
	mov	ecx, DWORD PTR q_$[rbp]
	call	_MULTIPLY_UNIT_DIV
	mov	DWORD PTR rh_mi$[rbp], eax

; 75   :     __UNIT_TYPE_DIV rh_lo = u2;

	mov	eax, DWORD PTR u2$[rbp]
	mov	DWORD PTR rh_lo$[rbp], eax

; 76   :     _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, u1, rh_mi, &rh_mi), u0, rh_hi, &rh_hi);

	lea	r9, QWORD PTR rh_mi$[rbp]
	mov	r8d, DWORD PTR rh_mi$[rbp]
	mov	edx, DWORD PTR u1$[rbp]
	xor	ecx, ecx
	call	_SUBTRUCT_UNIT_DIV
	lea	r9, QWORD PTR rh_hi$[rbp]
	mov	r8d, DWORD PTR rh_hi$[rbp]
	mov	edx, DWORD PTR u0$[rbp]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV

; 77   :     if (lh_hi > rh_hi)

	mov	eax, DWORD PTR rh_hi$[rbp]
	cmp	DWORD PTR lh_hi$[rbp], eax
	jbe	SHORT $LN2@CheckQ_

; 78   :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN3@CheckQ_
$LN2@CheckQ_:

; 79   :     else if (lh_hi < rh_hi)

	mov	eax, DWORD PTR rh_hi$[rbp]
	cmp	DWORD PTR lh_hi$[rbp], eax
	jae	SHORT $LN4@CheckQ_

; 80   :         return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN5@CheckQ_
$LN4@CheckQ_:

; 81   :     else if (lh_mi > rh_mi)

	mov	eax, DWORD PTR rh_mi$[rbp]
	cmp	DWORD PTR lh_mi$[rbp], eax
	jbe	SHORT $LN6@CheckQ_

; 82   :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN7@CheckQ_
$LN6@CheckQ_:

; 83   :     else if (lh_mi < rh_mi)

	mov	eax, DWORD PTR rh_mi$[rbp]
	cmp	DWORD PTR lh_mi$[rbp], eax
	jae	SHORT $LN8@CheckQ_

; 84   :         return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN9@CheckQ_
$LN8@CheckQ_:

; 85   :     else
; 86   :         return (lh_lo > rh_lo);

	mov	eax, DWORD PTR rh_lo$[rbp]
	cmp	DWORD PTR lh_lo$[rbp], eax
	jbe	SHORT $LN11@CheckQ_
	mov	DWORD PTR tv86[rbp], 1
	jmp	SHORT $LN12@CheckQ_
$LN11@CheckQ_:
	mov	DWORD PTR tv86[rbp], 0
$LN12@CheckQ_:
	mov	eax, DWORD PTR tv86[rbp]
$LN9@CheckQ_:
$LN7@CheckQ_:
$LN5@CheckQ_:
$LN3@CheckQ_:
$LN1@CheckQ_:

; 87   : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:CheckQ_$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+392]
	pop	rdi
	pop	rbp
	ret	0
CheckQ_	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
;	COMDAT AsumeQ_
_TEXT	SEGMENT
r$ = 4
q$ = 36
u0$ = 288
u1$ = 296
v1$ = 304
AsumeQ_	PROC						; COMDAT

; 60   : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__7646DD32_calc_divrem_critical@c
	call	__CheckForDebuggerJustMyCode

; 61   :     if (u0 == v1)

	mov	eax, DWORD PTR v1$[rbp]
	cmp	DWORD PTR u0$[rbp], eax
	jne	SHORT $LN2@AsumeQ_

; 62   :         return ((__UNIT_TYPE_DIV)-1);

	mov	eax, -1					; ffffffffH
	jmp	SHORT $LN1@AsumeQ_
$LN2@AsumeQ_:

; 63   :     __UNIT_TYPE_DIV r;
; 64   :     __UNIT_TYPE_DIV q = _DIVREM_UNIT(u0, u1, v1, &r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, DWORD PTR v1$[rbp]
	mov	edx, DWORD PTR u1$[rbp]
	mov	ecx, DWORD PTR u0$[rbp]
	call	_DIVREM_UNIT
	mov	DWORD PTR q$[rbp], eax

; 65   :     return (q);

	mov	eax, DWORD PTR q$[rbp]
$LN1@AsumeQ_:

; 66   : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:AsumeQ_$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
AsumeQ_	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
;	COMDAT SUBTRUCT_4W_UNIT
_TEXT	SEGMENT
x1$ = 224
x2$ = 232
x3$ = 240
x4$ = 248
y$ = 256
SUBTRUCT_4W_UNIT PROC					; COMDAT

; 55   : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__7646DD32_calc_divrem_critical@c
	call	__CheckForDebuggerJustMyCode

; 56   :     return (_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, *x4, y, x4), *x3, 0, x3), *x2, 0, x2), *x1, 0, x1));

	mov	r9, QWORD PTR x4$[rbp]
	mov	r8d, DWORD PTR y$[rbp]
	mov	rax, QWORD PTR x4$[rbp]
	mov	edx, DWORD PTR [rax]
	xor	ecx, ecx
	call	_SUBTRUCT_UNIT_DIV
	mov	r9, QWORD PTR x3$[rbp]
	xor	r8d, r8d
	mov	rcx, QWORD PTR x3$[rbp]
	mov	edx, DWORD PTR [rcx]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV
	mov	r9, QWORD PTR x2$[rbp]
	xor	r8d, r8d
	mov	rcx, QWORD PTR x2$[rbp]
	mov	edx, DWORD PTR [rcx]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV
	mov	r9, QWORD PTR x1$[rbp]
	xor	r8d, r8d
	mov	rcx, QWORD PTR x1$[rbp]
	mov	edx, DWORD PTR [rcx]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV

; 57   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
SUBTRUCT_4W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
;	COMDAT SUBTRUCT_3W_UNIT
_TEXT	SEGMENT
x1$ = 224
x2$ = 232
x3$ = 240
y$ = 248
SUBTRUCT_3W_UNIT PROC					; COMDAT

; 50   : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__7646DD32_calc_divrem_critical@c
	call	__CheckForDebuggerJustMyCode

; 51   :     return (_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, *x3, y, x3), *x2, 0, x2), *x1, 0, x1));

	mov	r9, QWORD PTR x3$[rbp]
	mov	r8d, DWORD PTR y$[rbp]
	mov	rax, QWORD PTR x3$[rbp]
	mov	edx, DWORD PTR [rax]
	xor	ecx, ecx
	call	_SUBTRUCT_UNIT_DIV
	mov	r9, QWORD PTR x2$[rbp]
	xor	r8d, r8d
	mov	rcx, QWORD PTR x2$[rbp]
	mov	edx, DWORD PTR [rcx]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV
	mov	r9, QWORD PTR x1$[rbp]
	xor	r8d, r8d
	mov	rcx, QWORD PTR x1$[rbp]
	mov	edx, DWORD PTR [rcx]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV

; 52   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
SUBTRUCT_3W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
;	COMDAT ADD_4W_UNIT
_TEXT	SEGMENT
x1$ = 224
x2$ = 232
x3$ = 240
x4$ = 248
y$ = 256
ADD_4W_UNIT PROC					; COMDAT

; 45   : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__7646DD32_calc_divrem_critical@c
	call	__CheckForDebuggerJustMyCode

; 46   :     return (_ADD_UNIT_DIV(_ADD_UNIT_DIV(_ADD_UNIT_DIV(_ADD_UNIT_DIV(0, *x4, y, x4), *x3, 0, x3), *x2, 0, x2), *x1, 0, x1));

	mov	r9, QWORD PTR x4$[rbp]
	mov	r8d, DWORD PTR y$[rbp]
	mov	rax, QWORD PTR x4$[rbp]
	mov	edx, DWORD PTR [rax]
	xor	ecx, ecx
	call	_ADD_UNIT_DIV
	mov	r9, QWORD PTR x3$[rbp]
	xor	r8d, r8d
	mov	rcx, QWORD PTR x3$[rbp]
	mov	edx, DWORD PTR [rcx]
	movzx	ecx, al
	call	_ADD_UNIT_DIV
	mov	r9, QWORD PTR x2$[rbp]
	xor	r8d, r8d
	mov	rcx, QWORD PTR x2$[rbp]
	mov	edx, DWORD PTR [rcx]
	movzx	ecx, al
	call	_ADD_UNIT_DIV
	mov	r9, QWORD PTR x1$[rbp]
	xor	r8d, r8d
	mov	rcx, QWORD PTR x1$[rbp]
	mov	edx, DWORD PTR [rcx]
	movzx	ecx, al
	call	_ADD_UNIT_DIV

; 47   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
ADD_4W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
;	COMDAT ADD_3W_UNIT
_TEXT	SEGMENT
x1$ = 224
x2$ = 232
x3$ = 240
y$ = 248
ADD_3W_UNIT PROC					; COMDAT

; 40   : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__7646DD32_calc_divrem_critical@c
	call	__CheckForDebuggerJustMyCode

; 41   :     return (_ADD_UNIT_DIV(_ADD_UNIT_DIV(_ADD_UNIT_DIV(0, *x3, y, x3), *x2, 0, x2), *x1, 0, x1));

	mov	r9, QWORD PTR x3$[rbp]
	mov	r8d, DWORD PTR y$[rbp]
	mov	rax, QWORD PTR x3$[rbp]
	mov	edx, DWORD PTR [rax]
	xor	ecx, ecx
	call	_ADD_UNIT_DIV
	mov	r9, QWORD PTR x2$[rbp]
	xor	r8d, r8d
	mov	rcx, QWORD PTR x2$[rbp]
	mov	edx, DWORD PTR [rcx]
	movzx	ecx, al
	call	_ADD_UNIT_DIV
	mov	r9, QWORD PTR x1$[rbp]
	xor	r8d, r8d
	mov	rcx, QWORD PTR x1$[rbp]
	mov	edx, DWORD PTR [rcx]
	movzx	ecx, al
	call	_ADD_UNIT_DIV

; 42   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
ADD_3W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
;	COMDAT CalculateCriticalDataOfDivision
_TEXT	SEGMENT
v_min_1$ = 4
v_min_2$ = 36
v_min_3$ = 68
u_min_0$ = 100
u_min_1$ = 132
u_min_2$ = 164
u_min_3$ = 196
u_count_0$ = 228
u_count_1$ = 260
u_count_2$ = 292
u_count_3$ = 324
u0$ = 356
u1$ = 388
u2$ = 420
u3$ = 452
v_count_1$24 = 484
v_count_2$25 = 516
v_count_3$26 = 548
v1$27 = 580
v2$28 = 612
v3$29 = 644
q_$30 = 676
bu0$31 = 708
bu1$32 = 740
bu2$33 = 772
bu3$34 = 804
mv1_hi$35 = 836
mv1_lo$36 = 868
mv2_hi$37 = 900
mv2_lo$38 = 932
mv3_hi$39 = 964
mv3_lo$40 = 996
env$ = 1440
CalculateCriticalDataOfDivision PROC			; COMDAT

; 90   : {

$LN17:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 1480				; 000005c8H
	lea	rbp, QWORD PTR [rsp+64]
	mov	rdi, rsp
	mov	ecx, 370				; 00000172H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+1512]
	lea	rcx, OFFSET FLAT:__7646DD32_calc_divrem_critical@c
	call	__CheckForDebuggerJustMyCode

; 91   :     const __UNIT_TYPE_DIV v_min_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);    // 0x80000000

	mov	DWORD PTR v_min_1$[rbp], -2147483648	; 80000000H

; 92   :     const __UNIT_TYPE_DIV v_min_2 = 0;                              // 0x00000000

	mov	DWORD PTR v_min_2$[rbp], 0

; 93   :     const __UNIT_TYPE_DIV v_min_3 = 0;

	mov	DWORD PTR v_min_3$[rbp], 0

; 94   : 
; 95   :     const __UNIT_TYPE_DIV u_min_0 = 0;                              // 0x00000000

	mov	DWORD PTR u_min_0$[rbp], 0

; 96   :     const __UNIT_TYPE_DIV u_min_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);    // 0x80000000

	mov	DWORD PTR u_min_1$[rbp], -2147483648	; 80000000H

; 97   :     const __UNIT_TYPE_DIV u_min_2 = 0;                              // 0x00000000

	mov	DWORD PTR u_min_2$[rbp], 0

; 98   :     const __UNIT_TYPE_DIV u_min_3 = 0;                              // 0x00000000

	mov	DWORD PTR u_min_3$[rbp], 0

; 99   : 
; 100  :     __UNIT_TYPE_DIV u_count_0 = (__UNIT_TYPE_DIV)-1;                // 0xffffffff

	mov	DWORD PTR u_count_0$[rbp], -1		; ffffffffH

; 101  :     __UNIT_TYPE_DIV u_count_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);        // 0x80000000

	mov	DWORD PTR u_count_1$[rbp], -2147483648	; 80000000H

; 102  :     __UNIT_TYPE_DIV u_count_2 = 0;                                  // 0x00000000

	mov	DWORD PTR u_count_2$[rbp], 0

; 103  :     __UNIT_TYPE_DIV u_count_3 = 0;                                  // 0x00000000

	mov	DWORD PTR u_count_3$[rbp], 0

; 104  : 
; 105  :     __UNIT_TYPE_DIV u0 = u_min_0;

	mov	eax, DWORD PTR u_min_0$[rbp]
	mov	DWORD PTR u0$[rbp], eax

; 106  :     __UNIT_TYPE_DIV u1 = u_min_1;

	mov	eax, DWORD PTR u_min_1$[rbp]
	mov	DWORD PTR u1$[rbp], eax

; 107  :     __UNIT_TYPE_DIV u2 = u_min_2;

	mov	eax, DWORD PTR u_min_2$[rbp]
	mov	DWORD PTR u2$[rbp], eax

; 108  :     __UNIT_TYPE_DIV u3 = u_min_3;

	mov	eax, DWORD PTR u_min_3$[rbp]
	mov	DWORD PTR u3$[rbp], eax
$LN2@CalculateC:

; 109  : 
; 110  :     for (;;)
; 111  :     {
; 112  :         __UNIT_TYPE_DIV v_count_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);    // 0x80000000

	mov	DWORD PTR v_count_1$24[rbp], -2147483648 ; 80000000H

; 113  :         __UNIT_TYPE_DIV v_count_2 = 0;                              // 0x00000000

	mov	DWORD PTR v_count_2$25[rbp], 0

; 114  :         __UNIT_TYPE_DIV v_count_3 = 0;                              // 0x00000000

	mov	DWORD PTR v_count_3$26[rbp], 0

; 115  :         __UNIT_TYPE_DIV v1 = v_min_1;

	mov	eax, DWORD PTR v_min_1$[rbp]
	mov	DWORD PTR v1$27[rbp], eax

; 116  :         __UNIT_TYPE_DIV v2 = v_min_2;

	mov	eax, DWORD PTR v_min_2$[rbp]
	mov	DWORD PTR v2$28[rbp], eax

; 117  :         __UNIT_TYPE_DIV v3 = v_min_3;

	mov	eax, DWORD PTR v_min_3$[rbp]
	mov	DWORD PTR v3$29[rbp], eax
$LN5@CalculateC:

; 118  :         for (;;)
; 119  :         {
; 120  :             __UNIT_TYPE_DIV q_ = AsumeQ_(u0, u1, v1);

	mov	r8d, DWORD PTR v1$27[rbp]
	mov	edx, DWORD PTR u1$[rbp]
	mov	ecx, DWORD PTR u0$[rbp]
	call	AsumeQ_
	mov	DWORD PTR q_$30[rbp], eax

; 121  :             if (CheckQ_(q_, u0, u1, u2, v1, v2))

	mov	eax, DWORD PTR v2$28[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR v1$27[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR u2$[rbp]
	mov	r8d, DWORD PTR u1$[rbp]
	mov	edx, DWORD PTR u0$[rbp]
	mov	ecx, DWORD PTR q_$30[rbp]
	call	CheckQ_
	test	eax, eax
	je	SHORT $LN8@CalculateC

; 122  :             {
; 123  :                 --q_;

	mov	eax, DWORD PTR q_$30[rbp]
	dec	eax
	mov	DWORD PTR q_$30[rbp], eax

; 124  :                 if (CheckQ_(q_, u0, u1, u2, v1, v2))

	mov	eax, DWORD PTR v2$28[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR v1$27[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR u2$[rbp]
	mov	r8d, DWORD PTR u1$[rbp]
	mov	edx, DWORD PTR u0$[rbp]
	mov	ecx, DWORD PTR q_$30[rbp]
	call	CheckQ_
	test	eax, eax
	je	SHORT $LN9@CalculateC

; 125  :                 {
; 126  :                     --q_;

	mov	eax, DWORD PTR q_$30[rbp]
	dec	eax
	mov	DWORD PTR q_$30[rbp], eax
$LN9@CalculateC:
$LN8@CalculateC:

; 127  :                 }
; 128  :             }
; 129  :             __UNIT_TYPE_DIV bu0 = u0;

	mov	eax, DWORD PTR u0$[rbp]
	mov	DWORD PTR bu0$31[rbp], eax

; 130  :             __UNIT_TYPE_DIV bu1 = u1;

	mov	eax, DWORD PTR u1$[rbp]
	mov	DWORD PTR bu1$32[rbp], eax

; 131  :             __UNIT_TYPE_DIV bu2 = u2;

	mov	eax, DWORD PTR u2$[rbp]
	mov	DWORD PTR bu2$33[rbp], eax

; 132  :             __UNIT_TYPE_DIV bu3 = u3;

	mov	eax, DWORD PTR u3$[rbp]
	mov	DWORD PTR bu3$34[rbp], eax

; 133  :             __UNIT_TYPE_DIV mv1_hi;
; 134  :             __UNIT_TYPE_DIV mv1_lo = _MULTIPLY_UNIT_DIV(v1, q_, &mv1_hi);

	lea	r8, QWORD PTR mv1_hi$35[rbp]
	mov	edx, DWORD PTR q_$30[rbp]
	mov	ecx, DWORD PTR v1$27[rbp]
	call	_MULTIPLY_UNIT_DIV
	mov	DWORD PTR mv1_lo$36[rbp], eax

; 135  :             __UNIT_TYPE_DIV mv2_hi;
; 136  :             __UNIT_TYPE_DIV mv2_lo = _MULTIPLY_UNIT_DIV(v2, q_, &mv2_hi);

	lea	r8, QWORD PTR mv2_hi$37[rbp]
	mov	edx, DWORD PTR q_$30[rbp]
	mov	ecx, DWORD PTR v2$28[rbp]
	call	_MULTIPLY_UNIT_DIV
	mov	DWORD PTR mv2_lo$38[rbp], eax

; 137  :             __UNIT_TYPE_DIV mv3_hi;
; 138  :             __UNIT_TYPE_DIV mv3_lo = _MULTIPLY_UNIT_DIV(v3, q_, &mv3_hi);

	lea	r8, QWORD PTR mv3_hi$39[rbp]
	mov	edx, DWORD PTR q_$30[rbp]
	mov	ecx, DWORD PTR v3$29[rbp]
	call	_MULTIPLY_UNIT_DIV
	mov	DWORD PTR mv3_lo$40[rbp], eax

; 139  : 
; 140  :             // [bu0, bu1, bu2, bu3] -= mv3_lo;
; 141  :             // [bu0, bu1, bu2] -= mv3_hi;
; 142  :             // [bu0, bu1, bu2] -= mv2_lo;
; 143  :             // [bu0, bu1] -= mv2_hi;
; 144  :             // [bu0, bu1] -= mv1_lo;
; 145  :             // [bu0] -= mv1_hi;
; 146  : 
; 147  :                 
; 148  :             if (_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, bu3, mv3_lo, &bu3), bu2, mv3_hi, &bu2), bu1, 0, &bu1), bu0, 0, &bu0) ||
; 149  :                 _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, bu2, mv2_lo, &bu2), bu1, mv2_hi, &bu1), bu0, 0, &bu0) ||

	lea	r9, QWORD PTR bu3$34[rbp]
	mov	r8d, DWORD PTR mv3_lo$40[rbp]
	mov	edx, DWORD PTR bu3$34[rbp]
	xor	ecx, ecx
	call	_SUBTRUCT_UNIT_DIV
	lea	r9, QWORD PTR bu2$33[rbp]
	mov	r8d, DWORD PTR mv3_hi$39[rbp]
	mov	edx, DWORD PTR bu2$33[rbp]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV
	lea	r9, QWORD PTR bu1$32[rbp]
	xor	r8d, r8d
	mov	edx, DWORD PTR bu1$32[rbp]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV
	lea	r9, QWORD PTR bu0$31[rbp]
	xor	r8d, r8d
	mov	edx, DWORD PTR bu0$31[rbp]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV
	movsx	eax, al
	test	eax, eax
	jne	$LN11@CalculateC
	lea	r9, QWORD PTR bu2$33[rbp]
	mov	r8d, DWORD PTR mv2_lo$38[rbp]
	mov	edx, DWORD PTR bu2$33[rbp]
	xor	ecx, ecx
	call	_SUBTRUCT_UNIT_DIV
	lea	r9, QWORD PTR bu1$32[rbp]
	mov	r8d, DWORD PTR mv2_hi$37[rbp]
	mov	edx, DWORD PTR bu1$32[rbp]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV
	lea	r9, QWORD PTR bu0$31[rbp]
	xor	r8d, r8d
	mov	edx, DWORD PTR bu0$31[rbp]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV
	movsx	eax, al
	test	eax, eax
	jne	SHORT $LN11@CalculateC
	lea	r9, QWORD PTR bu1$32[rbp]
	mov	r8d, DWORD PTR mv1_lo$36[rbp]
	mov	edx, DWORD PTR bu1$32[rbp]
	xor	ecx, ecx
	call	_SUBTRUCT_UNIT_DIV
	lea	r9, QWORD PTR bu0$31[rbp]
	mov	r8d, DWORD PTR mv1_hi$35[rbp]
	mov	edx, DWORD PTR bu0$31[rbp]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV
	movsx	eax, al
	test	eax, eax
	je	$LN10@CalculateC
$LN11@CalculateC:

; 150  :                 _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, bu1, mv1_lo, &bu1), bu0, mv1_hi, &bu0))
; 151  :             {
; 152  :                 if (sizeof(__UNIT_TYPE_DIV) <= 4)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN12@CalculateC

; 153  :                     env->log("found: u0=0x%08x, u1=0x%08x, u2=0x%08x, u3=0x%08x, v1=0x%08x, v2=0x%08x, v3=0x%08x\n", u0, u1, u2, u3, v1, v2, v3);

	mov	eax, DWORD PTR v3$29[rbp]
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR v2$28[rbp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR v1$27[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR u3$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR u2$[rbp]
	mov	r8d, DWORD PTR u1$[rbp]
	mov	edx, DWORD PTR u0$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0FE@HJGKBDLB@found?3?5u0?$DN0x?$CF08x?0?5u1?$DN0x?$CF08x?0?5u2@
	mov	rax, QWORD PTR env$[rbp]
	call	QWORD PTR [rax]
	jmp	SHORT $LN13@CalculateC
$LN12@CalculateC:

; 154  :                 else
; 155  :                     env->log("found: u0=0x%016llx, u1=0x%016llx, u2=0x%016llx, u3=0x%016llx, v1=0x%016llx, v2=0x%016llx, v3=0x%016llx\n", u0, u1, u2, u3, v1, v2, v3);

	mov	eax, DWORD PTR v3$29[rbp]
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR v2$28[rbp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR v1$27[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR u3$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR u2$[rbp]
	mov	r8d, DWORD PTR u1$[rbp]
	mov	edx, DWORD PTR u0$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0GJ@FDENHGMK@found?3?5u0?$DN0x?$CF016llx?0?5u1?$DN0x?$CF016l@
	mov	rax, QWORD PTR env$[rbp]
	call	QWORD PTR [rax]
$LN13@CalculateC:

; 156  :                 env->pause();

	mov	rax, QWORD PTR env$[rbp]
	call	QWORD PTR [rax+8]
$LN10@CalculateC:

; 157  :             }
; 158  : 
; 159  :             if (SUBTRUCT_3W_UNIT(&v_count_1, &v_count_2, &v_count_3, 1))

	mov	r9d, 1
	lea	r8, QWORD PTR v_count_3$26[rbp]
	lea	rdx, QWORD PTR v_count_2$25[rbp]
	lea	rcx, QWORD PTR v_count_1$24[rbp]
	call	SUBTRUCT_3W_UNIT
	movsx	eax, al
	test	eax, eax
	je	SHORT $LN14@CalculateC

; 160  :                 break;

	jmp	SHORT $LN6@CalculateC
$LN14@CalculateC:

; 161  :             ADD_3W_UNIT(&v1, &v2, &v3, 1);

	mov	r9d, 1
	lea	r8, QWORD PTR v3$29[rbp]
	lea	rdx, QWORD PTR v2$28[rbp]
	lea	rcx, QWORD PTR v1$27[rbp]
	call	ADD_3W_UNIT

; 162  :         }

	jmp	$LN5@CalculateC
$LN6@CalculateC:

; 163  :         if (SUBTRUCT_4W_UNIT(&u_count_0, &u_count_1, &u_count_2, &u_count_3, 1))

	mov	DWORD PTR [rsp+32], 1
	lea	r9, QWORD PTR u_count_3$[rbp]
	lea	r8, QWORD PTR u_count_2$[rbp]
	lea	rdx, QWORD PTR u_count_1$[rbp]
	lea	rcx, QWORD PTR u_count_0$[rbp]
	call	SUBTRUCT_4W_UNIT
	movsx	eax, al
	test	eax, eax
	je	SHORT $LN15@CalculateC

; 164  :             break;

	jmp	SHORT $LN3@CalculateC
$LN15@CalculateC:

; 165  :         ADD_4W_UNIT(&u0, &u1, &u2, &u3, 1);

	mov	DWORD PTR [rsp+32], 1
	lea	r9, QWORD PTR u3$[rbp]
	lea	r8, QWORD PTR u2$[rbp]
	lea	rdx, QWORD PTR u1$[rbp]
	lea	rcx, QWORD PTR u0$[rbp]
	call	ADD_4W_UNIT

; 166  :     }

	jmp	$LN2@CalculateC
$LN3@CalculateC:

; 167  : 
; 168  : }

	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:CalculateCriticalDataOfDivision$rtcFrameData
	call	_RTC_CheckStackVars
	lea	rsp, QWORD PTR [rbp+1416]
	pop	rdi
	pop	rbp
	ret	0
CalculateCriticalDataOfDivision ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _DIVREM_UNIT
_TEXT	SEGMENT
t$1 = 8
tv71 = 216
tv68 = 216
u_high$ = 256
u_low$ = 264
v$ = 272
r$ = 280
_DIVREM_UNIT PROC					; COMDAT

; 595  : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 596  : #ifdef _MSC_VER
; 597  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@DIVREM_UNI

; 598  :     {
; 599  :         // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 600  :         _UINT64_T t = _FROMWORDTODWORD(u_high, u_low);

	mov	edx, DWORD PTR u_low$[rbp]
	mov	ecx, DWORD PTR u_high$[rbp]
	call	_FROMWORDTODWORD
	mov	QWORD PTR t$1[rbp], rax

; 601  :         *r = (_UINT32_T)(t % v);

	mov	eax, DWORD PTR v$[rbp]
	mov	QWORD PTR tv68[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR t$1[rbp]
	mov	rcx, QWORD PTR tv68[rbp]
	div	rcx
	mov	rax, rdx
	mov	rcx, QWORD PTR r$[rbp]
	mov	DWORD PTR [rcx], eax

; 602  :         return ((_UINT32_T)(t / v));

	mov	eax, DWORD PTR v$[rbp]
	mov	QWORD PTR tv71[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR t$1[rbp]
	mov	rcx, QWORD PTR tv71[rbp]
	div	rcx
	jmp	SHORT $LN1@DIVREM_UNI

; 603  :     }

	jmp	SHORT $LN3@DIVREM_UNI
$LN2@DIVREM_UNI:

; 604  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@DIVREM_UNI

; 605  :     {
; 606  :         // 以下の理由のため、MSVCでは 128bit/64bit の除算を実装できない。運用で回避すること。
; 607  :         // ・(x64 に限らず) 除算の組み込み関数が用意されていない。
; 608  :         // ・128bit 整数のデータ型が用意されていない。
; 609  :         // ・x64 ではインラインアセンブラがサポートされていない。
; 610  :         *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 611  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@DIVREM_UNI

; 612  :     }

	jmp	SHORT $LN5@DIVREM_UNI
$LN4@DIVREM_UNI:

; 613  :     else
; 614  :     {
; 615  :         // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 616  :         *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 617  :         return (0);

	xor	eax, eax
$LN5@DIVREM_UNI:
$LN3@DIVREM_UNI:
$LN1@DIVREM_UNI:

; 618  :     }
; 619  : #elif defined(__GNUC__)
; 620  :     __UNIT_TYPE q;
; 621  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 622  :         __asm__("divl %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 623  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 624  :         __asm__("divq %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 625  :     else
; 626  :     {
; 627  :         // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 628  :         *r = 0;
; 629  :         q = 0;
; 630  :     }
; 631  :     return (q);
; 632  : #else
; 633  : #error unknown compiler
; 634  : #endif
; 635  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_DIVREM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _MULTIPLY_UNIT_DIV
_TEXT	SEGMENT
u$ = 224
v$ = 232
w_hi$ = 240
_MULTIPLY_UNIT_DIV PROC					; COMDAT

; 527  : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 528  : #ifdef _MSC_VER
; 529  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, DWORD PTR u$[rbp]
	mov	ecx, DWORD PTR v$[rbp]
	imul	rax, rcx
	mov	rdx, QWORD PTR w_hi$[rbp]
	mov	rcx, rax
	call	_FROMDWORDTOWORD

; 530  : #elif defined(__GNUC__)
; 531  : #ifdef _M_IX86
; 532  :     _UINT32_T w_lo;
; 533  :     __asm__("mull %3": "=a"(w_lo), "=d"(*w_hi) : "0"(u), "rm"(v));
; 534  :     return (w_lo);
; 535  : #elif defined(_M_X64)
; 536  :     return (_umul128(u, v, w_hi));
; 537  : #else
; 538  : #error unknown platform
; 539  : #endif
; 540  : #else
; 541  : #error unknown compiler
; 542  : #endif
; 543  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_MULTIPLY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _SUBTRUCT_UNIT_DIV
_TEXT	SEGMENT
borrow$ = 224
u$ = 232
v$ = 240
w$ = 248
_SUBTRUCT_UNIT_DIV PROC					; COMDAT

; 491  : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 492  : #ifdef _MSC_VER
; 493  :     return (_subborrow_u32(borrow, u, v, w));

	mov	eax, DWORD PTR u$[rbp]
	movzx	ecx, BYTE PTR borrow$[rbp]
	add	cl, -1
	sbb	eax, DWORD PTR v$[rbp]
	setb	cl
	mov	rdx, QWORD PTR w$[rbp]
	mov	DWORD PTR [rdx], eax
	movzx	eax, cl

; 494  : #elif defined(__GNUC__)
; 495  : #ifdef _M_IX86
; 496  :     return (_subborrow_u32(borrow, u, v, w));
; 497  : #elif defined(_M_X64)
; 498  :     return (_subborrow_u64(borrow, u, v, w));
; 499  : #else
; 500  : #error unknown platform
; 501  : #endif
; 502  : #else
; 503  : #error unknown compiler
; 504  : #endif
; 505  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_SUBTRUCT_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _ADD_UNIT_DIV
_TEXT	SEGMENT
carry$ = 224
u$ = 232
v$ = 240
w$ = 248
_ADD_UNIT_DIV PROC					; COMDAT

; 435  : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 436  : #ifdef _MSC_VER
; 437  :     return (_addcarry_u32(carry, u, v, w));

	mov	eax, DWORD PTR u$[rbp]
	movzx	ecx, BYTE PTR carry$[rbp]
	add	cl, -1
	adc	eax, DWORD PTR v$[rbp]
	setb	cl
	mov	rdx, QWORD PTR w$[rbp]
	mov	DWORD PTR [rdx], eax
	movzx	eax, cl

; 438  : #elif defined(__GNUC__)
; 439  : #ifdef _M_IX86
; 440  :     return (_addcarry_u32(carry, u, v, w));
; 441  : #elif defined(_M_X64)
; 442  :     return (_addcarry_u64(carry, u, v, w));
; 443  : #else
; 444  : #error unknown platform
; 445  : #endif
; 446  : #else
; 447  : #error unknown compiler
; 448  : #endif
; 449  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _FROMDWORDTOWORD
_TEXT	SEGMENT
value$ = 224
result_high$ = 232
_FROMDWORDTOWORD PROC					; COMDAT

; 393  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 394  :     *result_high = (_UINT32_T)(value >> 32);

	mov	rax, QWORD PTR value$[rbp]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR result_high$[rbp]
	mov	DWORD PTR [rcx], eax

; 395  :     return ((_UINT32_T)value);

	mov	eax, DWORD PTR value$[rbp]

; 396  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FROMDWORDTOWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _FROMWORDTODWORD
_TEXT	SEGMENT
value_high$ = 224
value_low$ = 232
_FROMWORDTODWORD PROC					; COMDAT

; 388  : {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	eax, DWORD PTR value_high$[rbp]
	shl	rax, 32					; 00000020H
	mov	ecx, DWORD PTR value_low$[rbp]
	or	rax, rcx

; 390  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FROMWORDTODWORD ENDP
_TEXT	ENDS
END
