; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__4522B509_pmc_internal@h DB 01H
__89DB6AB9_autogenerated_inline_func@h DB 01H
__A78DCA81_pmc_add@c DB 01H
msvcjmc	ENDS
PUBLIC	Initialize_Add
PUBLIC	PMC_Add_X_I
PUBLIC	PMC_Add_X_L
PUBLIC	PMC_Add_X_X
PUBLIC	__JustMyCode_Default
EXTRN	CheckBlockLight:PROC
EXTRN	AllocateNumber:PROC
EXTRN	DeallocateNumber:PROC
EXTRN	CommitNumber:PROC
EXTRN	CheckNumber:PROC
EXTRN	DuplicateNumber:PROC
EXTRN	From_I_Imp:PROC
EXTRN	From_L_Imp:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	number_zero:BYTE
_BSS	SEGMENT
fp_Add_X_X_using_ADC DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Initialize_Add DD imagerel $LN5
	DD	imagerel $LN5+128
	DD	imagerel $unwind$Initialize_Add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Add_X_I DD imagerel $LN19
	DD	imagerel $LN19+568
	DD	imagerel $unwind$PMC_Add_X_I
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Add_X_L DD imagerel $LN29
	DD	imagerel $LN29+1026
	DD	imagerel $unwind$PMC_Add_X_L
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Add_X_X DD imagerel $LN20
	DD	imagerel $LN20+588
	DD	imagerel $unwind$PMC_Add_X_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FROMDWORDTOWORD DD imagerel _FROMDWORDTOWORD
	DD	imagerel _FROMDWORDTOWORD+95
	DD	imagerel $unwind$_FROMDWORDTOWORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MAXIMUM_UNIT DD imagerel _MAXIMUM_UNIT
	DD	imagerel _MAXIMUM_UNIT+122
	DD	imagerel $unwind$_MAXIMUM_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_UNIT DD imagerel _ADD_UNIT
	DD	imagerel _ADD_UNIT+118
	DD	imagerel $unwind$_ADD_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADDX_UNIT DD imagerel _ADDX_UNIT
	DD	imagerel _ADDX_UNIT+121
	DD	imagerel $unwind$_ADDX_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_LZCNT_ALT_32 DD imagerel _LZCNT_ALT_32
	DD	imagerel _LZCNT_ALT_32+126
	DD	imagerel $unwind$_LZCNT_ALT_32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_LZCNT_ALT_UNIT DD imagerel _LZCNT_ALT_UNIT
	DD	imagerel _LZCNT_ALT_UNIT+131
	DD	imagerel $unwind$_LZCNT_ALT_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_32WORDS_ADC DD imagerel _ADD_32WORDS_ADC
	DD	imagerel _ADD_32WORDS_ADC+2741
	DD	imagerel $unwind$_ADD_32WORDS_ADC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_32WORDS_ADCX DD imagerel _ADD_32WORDS_ADCX
	DD	imagerel _ADD_32WORDS_ADCX+2741
	DD	imagerel $unwind$_ADD_32WORDS_ADCX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_16WORDS_ADC DD imagerel _ADD_16WORDS_ADC
	DD	imagerel _ADD_16WORDS_ADC+1413
	DD	imagerel $unwind$_ADD_16WORDS_ADC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_16WORDS_ADCX DD imagerel _ADD_16WORDS_ADCX
	DD	imagerel _ADD_16WORDS_ADCX+1413
	DD	imagerel $unwind$_ADD_16WORDS_ADCX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_8WORDS_ADC DD imagerel _ADD_8WORDS_ADC
	DD	imagerel _ADD_8WORDS_ADC+749
	DD	imagerel $unwind$_ADD_8WORDS_ADC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_8WORDS_ADCX DD imagerel _ADD_8WORDS_ADCX
	DD	imagerel _ADD_8WORDS_ADCX+749
	DD	imagerel $unwind$_ADD_8WORDS_ADCX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_4WORDS_ADC DD imagerel _ADD_4WORDS_ADC
	DD	imagerel _ADD_4WORDS_ADC+417
	DD	imagerel $unwind$_ADD_4WORDS_ADC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_4WORDS_ADCX DD imagerel _ADD_4WORDS_ADCX
	DD	imagerel _ADD_4WORDS_ADCX+417
	DD	imagerel $unwind$_ADD_4WORDS_ADCX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_2WORDS_ADC DD imagerel _ADD_2WORDS_ADC
	DD	imagerel _ADD_2WORDS_ADC+251
	DD	imagerel $unwind$_ADD_2WORDS_ADC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_2WORDS_ADCX DD imagerel _ADD_2WORDS_ADCX
	DD	imagerel _ADD_2WORDS_ADCX+251
	DD	imagerel $unwind$_ADD_2WORDS_ADCX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DoCarry DD imagerel DoCarry
	DD	imagerel DoCarry+409
	DD	imagerel $unwind$DoCarry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Add_X_1W DD imagerel Add_X_1W
	DD	imagerel Add_X_1W+289
	DD	imagerel $unwind$Add_X_1W
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Add_X_2W DD imagerel Add_X_2W
	DD	imagerel Add_X_2W+547
	DD	imagerel $unwind$Add_X_2W
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Add_X_X_using_ADC DD imagerel Add_X_X_using_ADC
	DD	imagerel Add_X_X_using_ADC+1056
	DD	imagerel $unwind$Add_X_X_using_ADC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Add_X_X_using_ADCX DD imagerel Add_X_X_using_ADCX
	DD	imagerel Add_X_X_using_ADCX+1056
	DD	imagerel $unwind$Add_X_X_using_ADCX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Add_X_X DD imagerel Add_X_X
	DD	imagerel Add_X_X+101
	DD	imagerel $unwind$Add_X_X
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Add_X_X DD 025053401H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Add_X_X_using_ADCX DD 035053401H
	DD	0118331dH
	DD	070110045H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Add_X_X_using_ADC DD 035053401H
	DD	0118331dH
	DD	070110045H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Add_X_2W DD 035053901H
	DD	011d3322H
	DD	070160035H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Add_X_1W DD 035053401H
	DD	0118331dH
	DD	070110035H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DoCarry DD 025053801H
	DD	011c2321H
	DD	07015001fH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_2WORDS_ADCX DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_2WORDS_ADC DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_4WORDS_ADCX DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_4WORDS_ADC DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_8WORDS_ADCX DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_8WORDS_ADC DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_16WORDS_ADCX DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_16WORDS_ADC DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_32WORDS_ADCX DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_32WORDS_ADC DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_LZCNT_ALT_UNIT DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_LZCNT_ALT_UNIT$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+12
_LZCNT_ALT_UNIT$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:_LZCNT_ALT_UNIT$rtcName$0
	ORG $+48
_LZCNT_ALT_UNIT$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_LZCNT_ALT_UNIT$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_LZCNT_ALT_32 DD 025052801H
	DD	010d2312H
	DD	070060021H
	DD	05005H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_LZCNT_ALT_32$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+12
_LZCNT_ALT_32$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:_LZCNT_ALT_32$rtcName$0
	ORG $+48
_LZCNT_ALT_32$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_LZCNT_ALT_32$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADDX_UNIT DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_UNIT DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MAXIMUM_UNIT DD 025052f01H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FROMDWORDTOWORD DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Add_X_X DD 025053401H
	DD	0118231dH
	DD	07011003dH
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_Add_X_X$rtcName$0 DB 06eH
	DB	07aH
	DB	00H
	ORG $+5
PMC_Add_X_X$rtcName$1 DB 06eH
	DB	07aH
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_Add_X_X$rtcVarDesc DD 0108H
	DD	08H
	DQ	FLAT:PMC_Add_X_X$rtcName$1
	DD	088H
	DD	08H
	DQ	FLAT:PMC_Add_X_X$rtcName$0
	ORG $+96
PMC_Add_X_X$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:PMC_Add_X_X$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Add_X_L DD 025053401H
	DD	0118231dH
	DD	07011005dH
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_Add_X_L$rtcName$0 DB 06eH
	DB	07aH
	DB	00H
	ORG $+1
PMC_Add_X_L$rtcName$1 DB 079H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+7
PMC_Add_X_L$rtcName$2 DB 06eH
	DB	07aH
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_Add_X_L$rtcName$3 DB 06eH
	DB	07aH
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_Add_X_L$rtcName$4 DB 06eH
	DB	07aH
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+12
PMC_Add_X_L$rtcVarDesc DD 0208H
	DD	08H
	DQ	FLAT:PMC_Add_X_L$rtcName$4
	DD	0188H
	DD	08H
	DQ	FLAT:PMC_Add_X_L$rtcName$3
	DD	0128H
	DD	08H
	DQ	FLAT:PMC_Add_X_L$rtcName$2
	DD	0a4H
	DD	04H
	DQ	FLAT:PMC_Add_X_L$rtcName$1
	DD	068H
	DD	08H
	DQ	FLAT:PMC_Add_X_L$rtcName$0
	ORG $+240
PMC_Add_X_L$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:PMC_Add_X_L$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Add_X_I DD 025053301H
	DD	0117231cH
	DD	070100039H
	DD	0500fH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_Add_X_I$rtcName$0 DB 06eH
	DB	07aH
	DB	00H
	ORG $+5
PMC_Add_X_I$rtcName$1 DB 06eH
	DB	07aH
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+10
PMC_Add_X_I$rtcVarDesc DD 0e8H
	DD	08H
	DQ	FLAT:PMC_Add_X_I$rtcName$1
	DD	068H
	DD	08H
	DQ	FLAT:PMC_Add_X_I$rtcName$0
	ORG $+96
PMC_Add_X_I$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:PMC_Add_X_I$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Initialize_Add DD 025052a01H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_add.c
;	COMDAT Add_X_X
_TEXT	SEGMENT
x$ = 224
y$ = 232
z$ = 240
Add_X_X	PROC						; COMDAT

; 307  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__A78DCA81_pmc_add@c
	call	__CheckForDebuggerJustMyCode

; 308  :     return ((*fp_Add_X_X_using_ADC)(x, y, z));

	mov	r8, QWORD PTR z$[rbp]
	mov	rdx, QWORD PTR y$[rbp]
	mov	rcx, QWORD PTR x$[rbp]
	call	QWORD PTR fp_Add_X_X_using_ADC

; 309  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Add_X_X	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_add.c
;	COMDAT Add_X_X_using_ADCX
_TEXT	SEGMENT
t$1 = 8
x_count$ = 40
y_count$ = 72
z_count$ = 104
xp$ = 136
yp$ = 168
zp$ = 200
c$ = 228
count$ = 264
tv166 = 472
tv169 = 480
tv172 = 488
x$ = 528
y$ = 536
z$ = 544
Add_X_X_using_ADCX PROC					; COMDAT

; 230  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 552				; 00000228H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 138				; 0000008aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+584]
	lea	rcx, OFFSET FLAT:__A78DCA81_pmc_add@c
	call	__CheckForDebuggerJustMyCode

; 231  :     // x のワード長が y のワード長以上であるようにする
; 232  :     if (x->UNIT_WORD_COUNT < y->UNIT_WORD_COUNT)

	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR y$[rbp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN4@Add_X_X_us

; 233  :     {
; 234  :         NUMBER_HEADER* t = x;

	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR t$1[rbp], rax

; 235  :         x = y;

	mov	rax, QWORD PTR y$[rbp]
	mov	QWORD PTR x$[rbp], rax

; 236  :         y = t;

	mov	rax, QWORD PTR t$1[rbp]
	mov	QWORD PTR y$[rbp], rax
$LN4@Add_X_X_us:

; 237  :     }
; 238  :     __UNIT_TYPE x_count = x->UNIT_WORD_COUNT;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR x_count$[rbp], rax

; 239  :     __UNIT_TYPE y_count = y->UNIT_WORD_COUNT;

	mov	rax, QWORD PTR y$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR y_count$[rbp], rax

; 240  :     __UNIT_TYPE z_count = z->BLOCK_COUNT;

	mov	rax, QWORD PTR z$[rbp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR z_count$[rbp], rax

; 241  :     __UNIT_TYPE* xp = &x->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR x$[rbp]
	add	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR xp$[rbp], rax

; 242  :     __UNIT_TYPE* yp = &y->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR y$[rbp]
	add	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR yp$[rbp], rax

; 243  :     __UNIT_TYPE* zp = &z->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR z$[rbp]
	add	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR zp$[rbp], rax

; 244  :     char c = 0;

	mov	BYTE PTR c$[rbp], 0

; 245  : 
; 246  :     // まず 32 ワードずつ加算をする。
; 247  :     __UNIT_TYPE count = y_count >> 5;

	mov	rax, QWORD PTR y_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@Add_X_X_us:

; 248  :     while (count != 0)

	cmp	QWORD PTR count$[rbp], 0
	je	SHORT $LN3@Add_X_X_us

; 249  :     {
; 250  :         c = _ADD_32WORDS_ADCX(c, xp, yp, zp);

	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR yp$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_32WORDS_ADCX
	mov	BYTE PTR c$[rbp], al

; 251  :         xp += 32;

	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR xp$[rbp], rax

; 252  :         yp += 32;

	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR yp$[rbp], rax

; 253  :         zp += 32;

	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR zp$[rbp], rax

; 254  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 255  :     }

	jmp	SHORT $LN2@Add_X_X_us
$LN3@Add_X_X_us:

; 256  :     // この時点で未処理の桁は 32 ワード未満のはず
; 257  : 
; 258  :     // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
; 259  :     if (y_count & 0x10)

	mov	rax, QWORD PTR y_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	SHORT $LN5@Add_X_X_us

; 260  :     {
; 261  :         c = _ADD_16WORDS_ADCX(c, xp, yp, zp);

	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR yp$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_16WORDS_ADCX
	mov	BYTE PTR c$[rbp], al

; 262  :         xp += 16;

	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR xp$[rbp], rax

; 263  :         yp += 16;

	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR yp$[rbp], rax

; 264  :         zp += 16;

	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR zp$[rbp], rax
$LN5@Add_X_X_us:

; 265  :     }
; 266  :     // この時点で未処理の桁は 16 ワード未満のはず
; 267  : 
; 268  :     // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
; 269  :     if (y_count & 0x8)

	mov	rax, QWORD PTR y_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	SHORT $LN6@Add_X_X_us

; 270  :     {
; 271  :         c = _ADD_8WORDS_ADCX(c, xp, yp, zp);

	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR yp$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_8WORDS_ADCX
	mov	BYTE PTR c$[rbp], al

; 272  :         xp += 8;

	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR xp$[rbp], rax

; 273  :         yp += 8;

	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR yp$[rbp], rax

; 274  :         zp += 8;

	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR zp$[rbp], rax
$LN6@Add_X_X_us:

; 275  :     }
; 276  :     // この時点で未処理の桁は 8 ワード未満のはず
; 277  : 
; 278  :     // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
; 279  :     if (y_count & 0x4)

	mov	rax, QWORD PTR y_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	SHORT $LN7@Add_X_X_us

; 280  :     {
; 281  :         c = _ADD_4WORDS_ADCX(c, xp, yp, zp);

	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR yp$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_4WORDS_ADCX
	mov	BYTE PTR c$[rbp], al

; 282  :         xp += 4;

	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR xp$[rbp], rax

; 283  :         yp += 4;

	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR yp$[rbp], rax

; 284  :         zp += 4;

	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR zp$[rbp], rax
$LN7@Add_X_X_us:

; 285  :     }
; 286  :     // この時点で未処理の桁は 4 ワード未満のはず
; 287  : 
; 288  :     // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
; 289  :     if (y_count & 0x2)

	mov	rax, QWORD PTR y_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	SHORT $LN8@Add_X_X_us

; 290  :     {
; 291  :         c = _ADD_2WORDS_ADCX(c, xp, yp, zp);

	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR yp$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_2WORDS_ADCX
	mov	BYTE PTR c$[rbp], al

; 292  :         xp += 2;

	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 16
	mov	QWORD PTR xp$[rbp], rax

; 293  :         yp += 2;

	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 16
	mov	QWORD PTR yp$[rbp], rax

; 294  :         zp += 2;

	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 16
	mov	QWORD PTR zp$[rbp], rax
$LN8@Add_X_X_us:

; 295  :     }
; 296  :     // この時点で未処理の桁は 2 ワード未満のはず
; 297  : 
; 298  :     // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
; 299  :     if (y_count & 0x1)

	mov	rax, QWORD PTR y_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	$LN9@Add_X_X_us

; 300  :         c = _ADDX_UNIT(c, *xp++, *yp++, zp++);

	mov	rax, QWORD PTR zp$[rbp]
	mov	QWORD PTR tv166[rbp], rax
	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 8
	mov	QWORD PTR zp$[rbp], rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv169[rbp], rax
	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 8
	mov	QWORD PTR yp$[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv172[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 8
	mov	QWORD PTR xp$[rbp], rax
	mov	r9, QWORD PTR tv166[rbp]
	mov	r8, QWORD PTR tv169[rbp]
	mov	rdx, QWORD PTR tv172[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al
$LN9@Add_X_X_us:

; 301  : 
; 302  :     // 残りの桁の繰り上がりを計算し、復帰する。
; 303  :     return (DoCarry(c, xp, x_count - y_count, zp, z_count - y_count));

	mov	rax, QWORD PTR y_count$[rbp]
	mov	rcx, QWORD PTR z_count$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR y_count$[rbp]
	mov	rdx, QWORD PTR x_count$[rbp]
	sub	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, rcx
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	DoCarry

; 304  : }

	lea	rsp, QWORD PTR [rbp+504]
	pop	rdi
	pop	rbp
	ret	0
Add_X_X_using_ADCX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_add.c
;	COMDAT Add_X_X_using_ADC
_TEXT	SEGMENT
t$1 = 8
x_count$ = 40
y_count$ = 72
z_count$ = 104
xp$ = 136
yp$ = 168
zp$ = 200
c$ = 228
count$ = 264
tv166 = 472
tv169 = 480
tv172 = 488
x$ = 528
y$ = 536
z$ = 544
Add_X_X_using_ADC PROC					; COMDAT

; 153  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 552				; 00000228H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 138				; 0000008aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+584]
	lea	rcx, OFFSET FLAT:__A78DCA81_pmc_add@c
	call	__CheckForDebuggerJustMyCode

; 154  :     // x のワード長が y のワード長以上であるようにする
; 155  :     if (x->UNIT_WORD_COUNT < y->UNIT_WORD_COUNT)

	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR y$[rbp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN4@Add_X_X_us

; 156  :     {
; 157  :         NUMBER_HEADER* t = x;

	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR t$1[rbp], rax

; 158  :         x = y;

	mov	rax, QWORD PTR y$[rbp]
	mov	QWORD PTR x$[rbp], rax

; 159  :         y = t;

	mov	rax, QWORD PTR t$1[rbp]
	mov	QWORD PTR y$[rbp], rax
$LN4@Add_X_X_us:

; 160  :     }
; 161  :     __UNIT_TYPE x_count = x->UNIT_WORD_COUNT;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR x_count$[rbp], rax

; 162  :     __UNIT_TYPE y_count = y->UNIT_WORD_COUNT;

	mov	rax, QWORD PTR y$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR y_count$[rbp], rax

; 163  :     __UNIT_TYPE z_count = z->BLOCK_COUNT;

	mov	rax, QWORD PTR z$[rbp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR z_count$[rbp], rax

; 164  :     __UNIT_TYPE* xp = &x->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR x$[rbp]
	add	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR xp$[rbp], rax

; 165  :     __UNIT_TYPE* yp = &y->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR y$[rbp]
	add	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR yp$[rbp], rax

; 166  :     __UNIT_TYPE* zp = &z->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR z$[rbp]
	add	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR zp$[rbp], rax

; 167  :     char c = 0;

	mov	BYTE PTR c$[rbp], 0

; 168  : 
; 169  :     // まず 32 ワードずつ加算をする。
; 170  :     __UNIT_TYPE count = y_count >> 5;

	mov	rax, QWORD PTR y_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@Add_X_X_us:

; 171  :     while (count != 0)

	cmp	QWORD PTR count$[rbp], 0
	je	SHORT $LN3@Add_X_X_us

; 172  :     {
; 173  :         c = _ADD_32WORDS_ADC(c, xp, yp, zp);

	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR yp$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_32WORDS_ADC
	mov	BYTE PTR c$[rbp], al

; 174  :         xp += 32;

	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR xp$[rbp], rax

; 175  :         yp += 32;

	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR yp$[rbp], rax

; 176  :         zp += 32;

	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR zp$[rbp], rax

; 177  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 178  :     }

	jmp	SHORT $LN2@Add_X_X_us
$LN3@Add_X_X_us:

; 179  :     // この時点で未処理の桁は 32 ワード未満のはず
; 180  : 
; 181  :     // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
; 182  :     if (y_count & 0x10)

	mov	rax, QWORD PTR y_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	SHORT $LN5@Add_X_X_us

; 183  :     {
; 184  :         c = _ADD_16WORDS_ADC(c, xp, yp, zp);

	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR yp$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_16WORDS_ADC
	mov	BYTE PTR c$[rbp], al

; 185  :         xp += 16;

	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR xp$[rbp], rax

; 186  :         yp += 16;

	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR yp$[rbp], rax

; 187  :         zp += 16;

	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR zp$[rbp], rax
$LN5@Add_X_X_us:

; 188  :     }
; 189  :     // この時点で未処理の桁は 16 ワード未満のはず
; 190  : 
; 191  :     // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
; 192  :     if (y_count & 0x8)

	mov	rax, QWORD PTR y_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	SHORT $LN6@Add_X_X_us

; 193  :     {
; 194  :         c = _ADD_8WORDS_ADC(c, xp, yp, zp);

	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR yp$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_8WORDS_ADC
	mov	BYTE PTR c$[rbp], al

; 195  :         xp += 8;

	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR xp$[rbp], rax

; 196  :         yp += 8;

	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR yp$[rbp], rax

; 197  :         zp += 8;

	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR zp$[rbp], rax
$LN6@Add_X_X_us:

; 198  :     }
; 199  :     // この時点で未処理の桁は 8 ワード未満のはず
; 200  : 
; 201  :     // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
; 202  :     if (y_count & 0x4)

	mov	rax, QWORD PTR y_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	SHORT $LN7@Add_X_X_us

; 203  :     {
; 204  :         c = _ADD_4WORDS_ADC(c, xp, yp, zp);

	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR yp$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_4WORDS_ADC
	mov	BYTE PTR c$[rbp], al

; 205  :         xp += 4;

	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR xp$[rbp], rax

; 206  :         yp += 4;

	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR yp$[rbp], rax

; 207  :         zp += 4;

	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR zp$[rbp], rax
$LN7@Add_X_X_us:

; 208  :     }
; 209  :     // この時点で未処理の桁は 4 ワード未満のはず
; 210  : 
; 211  :     // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
; 212  :     if (y_count & 0x2)

	mov	rax, QWORD PTR y_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	SHORT $LN8@Add_X_X_us

; 213  :     {
; 214  :         c = _ADD_2WORDS_ADC(c, xp, yp, zp);

	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR yp$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_2WORDS_ADC
	mov	BYTE PTR c$[rbp], al

; 215  :         xp += 2;

	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 16
	mov	QWORD PTR xp$[rbp], rax

; 216  :         yp += 2;

	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 16
	mov	QWORD PTR yp$[rbp], rax

; 217  :         zp += 2;

	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 16
	mov	QWORD PTR zp$[rbp], rax
$LN8@Add_X_X_us:

; 218  :     }
; 219  :     // この時点で未処理の桁は 2 ワード未満のはず
; 220  : 
; 221  :     // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
; 222  :     if (y_count & 0x1)

	mov	rax, QWORD PTR y_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	$LN9@Add_X_X_us

; 223  :         c = _ADD_UNIT(c, *xp++, *yp++, zp++);

	mov	rax, QWORD PTR zp$[rbp]
	mov	QWORD PTR tv166[rbp], rax
	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 8
	mov	QWORD PTR zp$[rbp], rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv169[rbp], rax
	mov	rax, QWORD PTR yp$[rbp]
	add	rax, 8
	mov	QWORD PTR yp$[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv172[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 8
	mov	QWORD PTR xp$[rbp], rax
	mov	r9, QWORD PTR tv166[rbp]
	mov	r8, QWORD PTR tv169[rbp]
	mov	rdx, QWORD PTR tv172[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al
$LN9@Add_X_X_us:

; 224  : 
; 225  :     // 残りの桁の繰り上がりを計算し、復帰する。
; 226  :     return (DoCarry(c, xp, x_count - y_count, zp, z_count - y_count));

	mov	rax, QWORD PTR y_count$[rbp]
	mov	rcx, QWORD PTR z_count$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR y_count$[rbp]
	mov	rdx, QWORD PTR x_count$[rbp]
	sub	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, rcx
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	DoCarry

; 227  : }

	lea	rsp, QWORD PTR [rbp+504]
	pop	rdi
	pop	rbp
	ret	0
Add_X_X_using_ADC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_add.c
;	COMDAT Add_X_2W
_TEXT	SEGMENT
x_count$ = 8
z_count$ = 40
xp$ = 72
zp$ = 104
c$ = 132
tv136 = 344
tv95 = 344
tv140 = 352
tv131 = 352
x$ = 400
y_hi$ = 408
y_lo$ = 416
z$ = 424
Add_X_2W PROC						; COMDAT

; 110  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 424				; 000001a8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+456]
	lea	rcx, OFFSET FLAT:__A78DCA81_pmc_add@c
	call	__CheckForDebuggerJustMyCode

; 111  :     __UNIT_TYPE x_count = x->UNIT_WORD_COUNT;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR x_count$[rbp], rax

; 112  :     __UNIT_TYPE z_count = z->BLOCK_COUNT;

	mov	rax, QWORD PTR z$[rbp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR z_count$[rbp], rax

; 113  :     __UNIT_TYPE* xp = &x->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR x$[rbp]
	add	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR xp$[rbp], rax

; 114  :     __UNIT_TYPE* zp = &z->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR z$[rbp]
	add	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR zp$[rbp], rax

; 115  :     char c;
; 116  : 
; 117  :     if (x_count < 2)

	cmp	QWORD PTR x_count$[rbp], 2
	jae	$LN2@Add_X_2W

; 118  :     {
; 119  :         // x が 1 ワードしかなかった場合
; 120  : 
; 121  :         // 最下位ワードの加算を行う
; 122  :         c = _ADD_UNIT(0, xp[0], y_lo, &zp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r9, rax
	mov	r8, QWORD PTR y_lo$[rbp]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	xor	ecx, ecx
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 123  : 
; 124  :         // 最下位から 2 番目のワードの加算を行う
; 125  :         c = _ADD_UNIT(c, 0, y_hi, &zp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, rax
	mov	r8, QWORD PTR y_hi$[rbp]
	xor	edx, edx
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 126  : 
; 127  :         // 桁上りが発生したら 3 番目のワードに 1 を設定する。
; 128  :         if (c)

	movsx	eax, BYTE PTR c$[rbp]
	test	eax, eax
	je	SHORT $LN4@Add_X_2W

; 129  :             zp[2] = 1;

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	mov	QWORD PTR [rcx+rax], 1
$LN4@Add_X_2W:

; 130  : 
; 131  :         // 正常復帰する。
; 132  :         return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	$LN1@Add_X_2W

; 133  :     }

	jmp	$LN3@Add_X_2W
$LN2@Add_X_2W:

; 134  :     else
; 135  :     {
; 136  :         // x が 2 ワード以上あった場合
; 137  : 
; 138  :         // 最下位のワードの加算をする
; 139  :         c = _ADD_UNIT(0, *xp++, y_lo, zp++);

	mov	rax, QWORD PTR zp$[rbp]
	mov	QWORD PTR tv95[rbp], rax
	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 8
	mov	QWORD PTR zp$[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv131[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 8
	mov	QWORD PTR xp$[rbp], rax
	mov	r9, QWORD PTR tv95[rbp]
	mov	r8, QWORD PTR y_lo$[rbp]
	mov	rdx, QWORD PTR tv131[rbp]
	xor	ecx, ecx
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 140  : 
; 141  :         // 最下位から 2 番目のワードの加算をする。
; 142  :         c = _ADD_UNIT(c, *xp++, y_hi, zp++);

	mov	rax, QWORD PTR zp$[rbp]
	mov	QWORD PTR tv136[rbp], rax
	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 8
	mov	QWORD PTR zp$[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv140[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 8
	mov	QWORD PTR xp$[rbp], rax
	mov	r9, QWORD PTR tv136[rbp]
	mov	r8, QWORD PTR y_hi$[rbp]
	mov	rdx, QWORD PTR tv140[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 143  :         x_count -= 2;

	mov	rax, QWORD PTR x_count$[rbp]
	sub	rax, 2
	mov	QWORD PTR x_count$[rbp], rax

; 144  :         z_count -= 2;

	mov	rax, QWORD PTR z_count$[rbp]
	sub	rax, 2
	mov	QWORD PTR z_count$[rbp], rax

; 145  : 
; 146  :         // 残りの桁の繰り上がりを計算し、復帰する。
; 147  :         return (DoCarry(c, xp, x_count, zp, z_count));

	mov	rax, QWORD PTR z_count$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR x_count$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	DoCarry
$LN3@Add_X_2W:
$LN1@Add_X_2W:

; 148  :     }
; 149  : }

	lea	rsp, QWORD PTR [rbp+376]
	pop	rdi
	pop	rbp
	ret	0
Add_X_2W ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_add.c
;	COMDAT Add_X_1W
_TEXT	SEGMENT
x_count$ = 8
z_count$ = 40
xp$ = 72
zp$ = 104
c$ = 132
tv74 = 344
tv78 = 352
x$ = 400
y$ = 408
z$ = 416
Add_X_1W PROC						; COMDAT

; 93   : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 424				; 000001a8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+456]
	lea	rcx, OFFSET FLAT:__A78DCA81_pmc_add@c
	call	__CheckForDebuggerJustMyCode

; 94   :     __UNIT_TYPE x_count = x->UNIT_WORD_COUNT;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR x_count$[rbp], rax

; 95   :     __UNIT_TYPE z_count = z->BLOCK_COUNT;

	mov	rax, QWORD PTR z$[rbp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR z_count$[rbp], rax

; 96   :     __UNIT_TYPE* xp = &x->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR x$[rbp]
	add	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR xp$[rbp], rax

; 97   :     __UNIT_TYPE* zp = &z->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR z$[rbp]
	add	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR zp$[rbp], rax

; 98   :     char c;
; 99   : 
; 100  :     // 最下桁の加算を行う
; 101  :     c = _ADD_UNIT(0, *xp++, y, zp++);

	mov	rax, QWORD PTR zp$[rbp]
	mov	QWORD PTR tv74[rbp], rax
	mov	rax, QWORD PTR zp$[rbp]
	add	rax, 8
	mov	QWORD PTR zp$[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv78[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 8
	mov	QWORD PTR xp$[rbp], rax
	mov	r9, QWORD PTR tv74[rbp]
	mov	r8, QWORD PTR y$[rbp]
	mov	rdx, QWORD PTR tv78[rbp]
	xor	ecx, ecx
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 102  :     --x_count;

	mov	rax, QWORD PTR x_count$[rbp]
	dec	rax
	mov	QWORD PTR x_count$[rbp], rax

; 103  :     --z_count;

	mov	rax, QWORD PTR z_count$[rbp]
	dec	rax
	mov	QWORD PTR z_count$[rbp], rax

; 104  : 
; 105  :     // 残りの桁の繰上りを行い復帰する。
; 106  :     return (DoCarry(c, xp, x_count, zp, z_count));

	mov	rax, QWORD PTR z_count$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR zp$[rbp]
	mov	r8, QWORD PTR x_count$[rbp]
	mov	rdx, QWORD PTR xp$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	DoCarry

; 107  : }

	lea	rsp, QWORD PTR [rbp+376]
	pop	rdi
	pop	rbp
	ret	0
Add_X_1W ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_add.c
;	COMDAT DoCarry
_TEXT	SEGMENT
tv72 = 192
tv76 = 200
c$ = 240
xp$ = 248
x_count$ = 256
op$ = 264
o_count$ = 272
DoCarry	PROC						; COMDAT

; 41   : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__A78DCA81_pmc_add@c
	call	__CheckForDebuggerJustMyCode
$LN2@DoCarry:

; 42   :     // 繰り上がりを続く限り行う
; 43   :     for (;;)
; 44   :     {
; 45   :         if (x_count <= 0)

	cmp	QWORD PTR x_count$[rbp], 0
	ja	SHORT $LN7@DoCarry

; 46   :         {
; 47   :             // x の最上位まで達してしまった場合
; 48   : 
; 49   :             if (c)

	movsx	eax, BYTE PTR c$[rbp]
	test	eax, eax
	je	SHORT $LN9@DoCarry

; 50   :             {
; 51   :                 // かつそれでも繰り上がりを行う必要がある場合
; 52   :                 if (o_count <= 0)

	cmp	QWORD PTR o_count$[rbp], 0
	ja	SHORT $LN10@DoCarry

; 53   :                 {
; 54   :                     // しかし z がもう終端に達してしまった場合
; 55   : 
; 56   :                     // z のバッファはこの余裕を見込んでいるのでこのルートには到達しないはず。
; 57   :                     return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@DoCarry
$LN10@DoCarry:

; 58   :                 }
; 59   :                 *op = 1;

	mov	rax, QWORD PTR op$[rbp]
	mov	QWORD PTR [rax], 1
$LN9@DoCarry:

; 60   :             }
; 61   : 
; 62   :             // xの最上位に達してしまった場合はいずれにしろループを中断して正常復帰する。
; 63   : 
; 64   :             return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	$LN1@DoCarry

; 65   :         }

	jmp	$LN8@DoCarry
$LN7@DoCarry:

; 66   :         else if (c)

	movsx	eax, BYTE PTR c$[rbp]
	test	eax, eax
	je	$LN11@DoCarry

; 67   :         {
; 68   :             // xの最上位に達しておらず、かつキャリーが立っている場合
; 69   : 
; 70   :             // 繰り上がりを継続する
; 71   :             c = _ADD_UNIT(c, *xp++, 0, op++);

	mov	rax, QWORD PTR op$[rbp]
	mov	QWORD PTR tv72[rbp], rax
	mov	rax, QWORD PTR op$[rbp]
	add	rax, 8
	mov	QWORD PTR op$[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 8
	mov	QWORD PTR xp$[rbp], rax
	mov	r9, QWORD PTR tv72[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv76[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 72   :             --x_count;

	mov	rax, QWORD PTR x_count$[rbp]
	dec	rax
	mov	QWORD PTR x_count$[rbp], rax

; 73   :             --o_count;

	mov	rax, QWORD PTR o_count$[rbp]
	dec	rax
	mov	QWORD PTR o_count$[rbp], rax

; 74   :         }

	jmp	SHORT $LN12@DoCarry
$LN11@DoCarry:
$LN5@DoCarry:

; 75   :         else
; 76   :         {
; 77   :             // xの最上位に達しておらず、かつキャリーが立っていない場合
; 78   : 
; 79   :             // 繰り上がりを中断し、xの残りのデータをzにそのまま複写し、正常復帰する。
; 80   :             while (x_count > 0)

	cmp	QWORD PTR x_count$[rbp], 0
	jbe	SHORT $LN6@DoCarry

; 81   :             {
; 82   :                 *op++ = *xp++;

	mov	rax, QWORD PTR op$[rbp]
	mov	rcx, QWORD PTR xp$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR op$[rbp]
	add	rax, 8
	mov	QWORD PTR op$[rbp], rax
	mov	rax, QWORD PTR xp$[rbp]
	add	rax, 8
	mov	QWORD PTR xp$[rbp], rax

; 83   :                 --x_count;

	mov	rax, QWORD PTR x_count$[rbp]
	dec	rax
	mov	QWORD PTR x_count$[rbp], rax

; 84   :                 --o_count;

	mov	rax, QWORD PTR o_count$[rbp]
	dec	rax
	mov	QWORD PTR o_count$[rbp], rax

; 85   :             }

	jmp	SHORT $LN5@DoCarry
$LN6@DoCarry:

; 86   :             return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	SHORT $LN1@DoCarry
$LN12@DoCarry:
$LN8@DoCarry:

; 87   :         }
; 88   :     }

	jmp	$LN2@DoCarry
$LN1@DoCarry:

; 89   : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
DoCarry	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\autogenerated_inline_func.h
;	COMDAT _ADD_2WORDS_ADCX
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_2WORDS_ADCX PROC					; COMDAT

; 4376 :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__89DB6AB9_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 4377 : #ifdef _MSC_VER
; 4378 :         c = _ADDX_UNIT(c, xp[0], yp[0], &zp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 4379 :         c = _ADDX_UNIT(c, xp[1], yp[1], &zp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 4380 : #elif defined(__GNUC__)
; 4381 : #ifdef _M_IX86
; 4382 :         __asm__ volatile (
; 4383 :             "addb\t$-1, %0\n\t"
; 4384 :             "movl\t(%1), %%ecx\n\t"
; 4385 :             "adcxl\t(%2), %%ecx\n\t"
; 4386 :             "movl\t%%ecx, (%3)\n\t"
; 4387 :             "movl\t4(%1), %%ecx\n\t"
; 4388 :             "adcxl\t4(%2), %%ecx\n\t"
; 4389 :             "movl\t%%ecx, 4(%3)\n\t"
; 4390 :             "setc\t%0"
; 4391 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4392 :             :
; 4393 :             : "cc", "memory", "%ecx"
; 4394 :             );
; 4395 : #elif defined(_M_IX64)
; 4396 :         __asm__ volatile (
; 4397 :             "addb\t$-1, %0\n\t"
; 4398 :             "movq\t(%1), %%rcx\n\t"
; 4399 :             "adcxq\t(%2), %%rcx\n\t"
; 4400 :             "movq\t%%rcx, (%3)\n\t"
; 4401 :             "movq\t8(%1), %%rcx\n\t"
; 4402 :             "adcxq\t8(%2), %%rcx\n\t"
; 4403 :             "movq\t%%rcx, 8(%3)\n\t"
; 4404 :             "setc\t%0"
; 4405 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4406 :             :
; 4407 :             : "cc", "memory", "%rcx"
; 4408 :             );
; 4409 : #else
; 4410 : #error unknown platform
; 4411 : #endif
; 4412 : #else
; 4413 : #error unknown compiler
; 4414 : #endif
; 4415 :         return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 4416 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_2WORDS_ADCX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\autogenerated_inline_func.h
;	COMDAT _ADD_2WORDS_ADC
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_2WORDS_ADC PROC					; COMDAT

; 4333 :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__89DB6AB9_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 4334 : #ifdef _MSC_VER
; 4335 :         c = _ADD_UNIT(c, xp[0], yp[0], &zp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 4336 :         c = _ADD_UNIT(c, xp[1], yp[1], &zp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 4337 : #elif defined(__GNUC__)
; 4338 : #ifdef _M_IX86
; 4339 :         __asm__ volatile (
; 4340 :             "addb\t$-1, %0\n\t"
; 4341 :             "movl\t(%1), %%ecx\n\t"
; 4342 :             "adcl\t(%2), %%ecx\n\t"
; 4343 :             "movl\t%%ecx, (%3)\n\t"
; 4344 :             "movl\t4(%1), %%ecx\n\t"
; 4345 :             "adcl\t4(%2), %%ecx\n\t"
; 4346 :             "movl\t%%ecx, 4(%3)\n\t"
; 4347 :             "setc\t%0"
; 4348 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4349 :             :
; 4350 :             : "cc", "memory", "%ecx"
; 4351 :             );
; 4352 : #elif defined(_M_IX64)
; 4353 :         __asm__ volatile (
; 4354 :             "addb\t$-1, %0\n\t"
; 4355 :             "movq\t(%1), %%rcx\n\t"
; 4356 :             "adcq\t(%2), %%rcx\n\t"
; 4357 :             "movq\t%%rcx, (%3)\n\t"
; 4358 :             "movq\t8(%1), %%rcx\n\t"
; 4359 :             "adcq\t8(%2), %%rcx\n\t"
; 4360 :             "movq\t%%rcx, 8(%3)\n\t"
; 4361 :             "setc\t%0"
; 4362 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4363 :             :
; 4364 :             : "cc", "memory", "%rcx"
; 4365 :             );
; 4366 : #else
; 4367 : #error unknown platform
; 4368 : #endif
; 4369 : #else
; 4370 : #error unknown compiler
; 4371 : #endif
; 4372 :         return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 4373 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_2WORDS_ADC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\autogenerated_inline_func.h
;	COMDAT _ADD_4WORDS_ADCX
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_4WORDS_ADCX PROC					; COMDAT

; 3934 :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__89DB6AB9_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 3935 : #ifdef _MSC_VER
; 3936 :         c = _ADDX_UNIT(c, xp[0], yp[0], &zp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3937 :         c = _ADDX_UNIT(c, xp[1], yp[1], &zp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3938 :         c = _ADDX_UNIT(c, xp[2], yp[2], &zp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	edx, 8
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3939 :         c = _ADDX_UNIT(c, xp[3], yp[3], &zp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	edx, 8
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3940 : #elif defined(__GNUC__)
; 3941 : #ifdef _M_IX86
; 3942 :         __asm__ volatile (
; 3943 :             "addb\t$-1, %0\n\t"
; 3944 :             "movl\t(%1), %%ecx\n\t"
; 3945 :             "adcxl\t(%2), %%ecx\n\t"
; 3946 :             "movl\t%%ecx, (%3)\n\t"
; 3947 :             "movl\t4(%1), %%ecx\n\t"
; 3948 :             "adcxl\t4(%2), %%ecx\n\t"
; 3949 :             "movl\t%%ecx, 4(%3)\n\t"
; 3950 :             "movl\t8(%1), %%ecx\n\t"
; 3951 :             "adcxl\t8(%2), %%ecx\n\t"
; 3952 :             "movl\t%%ecx, 8(%3)\n\t"
; 3953 :             "movl\t12(%1), %%ecx\n\t"
; 3954 :             "adcxl\t12(%2), %%ecx\n\t"
; 3955 :             "movl\t%%ecx, 12(%3)\n\t"
; 3956 :             "setc\t%0"
; 3957 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3958 :             :
; 3959 :             : "cc", "memory", "%ecx"
; 3960 :             );
; 3961 : #elif defined(_M_IX64)
; 3962 :         __asm__ volatile (
; 3963 :             "addb\t$-1, %0\n\t"
; 3964 :             "movq\t(%1), %%rcx\n\t"
; 3965 :             "adcxq\t(%2), %%rcx\n\t"
; 3966 :             "movq\t%%rcx, (%3)\n\t"
; 3967 :             "movq\t8(%1), %%rcx\n\t"
; 3968 :             "adcxq\t8(%2), %%rcx\n\t"
; 3969 :             "movq\t%%rcx, 8(%3)\n\t"
; 3970 :             "movq\t16(%1), %%rcx\n\t"
; 3971 :             "adcxq\t16(%2), %%rcx\n\t"
; 3972 :             "movq\t%%rcx, 16(%3)\n\t"
; 3973 :             "movq\t24(%1), %%rcx\n\t"
; 3974 :             "adcxq\t24(%2), %%rcx\n\t"
; 3975 :             "movq\t%%rcx, 24(%3)\n\t"
; 3976 :             "setc\t%0"
; 3977 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3978 :             :
; 3979 :             : "cc", "memory", "%rcx"
; 3980 :             );
; 3981 : #else
; 3982 : #error unknown platform
; 3983 : #endif
; 3984 : #else
; 3985 : #error unknown compiler
; 3986 : #endif
; 3987 :         return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 3988 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_4WORDS_ADCX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\autogenerated_inline_func.h
;	COMDAT _ADD_4WORDS_ADC
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_4WORDS_ADC PROC					; COMDAT

; 3877 :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__89DB6AB9_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 3878 : #ifdef _MSC_VER
; 3879 :         c = _ADD_UNIT(c, xp[0], yp[0], &zp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3880 :         c = _ADD_UNIT(c, xp[1], yp[1], &zp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3881 :         c = _ADD_UNIT(c, xp[2], yp[2], &zp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	edx, 8
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3882 :         c = _ADD_UNIT(c, xp[3], yp[3], &zp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	edx, 8
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3883 : #elif defined(__GNUC__)
; 3884 : #ifdef _M_IX86
; 3885 :         __asm__ volatile (
; 3886 :             "addb\t$-1, %0\n\t"
; 3887 :             "movl\t(%1), %%ecx\n\t"
; 3888 :             "adcl\t(%2), %%ecx\n\t"
; 3889 :             "movl\t%%ecx, (%3)\n\t"
; 3890 :             "movl\t4(%1), %%ecx\n\t"
; 3891 :             "adcl\t4(%2), %%ecx\n\t"
; 3892 :             "movl\t%%ecx, 4(%3)\n\t"
; 3893 :             "movl\t8(%1), %%ecx\n\t"
; 3894 :             "adcl\t8(%2), %%ecx\n\t"
; 3895 :             "movl\t%%ecx, 8(%3)\n\t"
; 3896 :             "movl\t12(%1), %%ecx\n\t"
; 3897 :             "adcl\t12(%2), %%ecx\n\t"
; 3898 :             "movl\t%%ecx, 12(%3)\n\t"
; 3899 :             "setc\t%0"
; 3900 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3901 :             :
; 3902 :             : "cc", "memory", "%ecx"
; 3903 :             );
; 3904 : #elif defined(_M_IX64)
; 3905 :         __asm__ volatile (
; 3906 :             "addb\t$-1, %0\n\t"
; 3907 :             "movq\t(%1), %%rcx\n\t"
; 3908 :             "adcq\t(%2), %%rcx\n\t"
; 3909 :             "movq\t%%rcx, (%3)\n\t"
; 3910 :             "movq\t8(%1), %%rcx\n\t"
; 3911 :             "adcq\t8(%2), %%rcx\n\t"
; 3912 :             "movq\t%%rcx, 8(%3)\n\t"
; 3913 :             "movq\t16(%1), %%rcx\n\t"
; 3914 :             "adcq\t16(%2), %%rcx\n\t"
; 3915 :             "movq\t%%rcx, 16(%3)\n\t"
; 3916 :             "movq\t24(%1), %%rcx\n\t"
; 3917 :             "adcq\t24(%2), %%rcx\n\t"
; 3918 :             "movq\t%%rcx, 24(%3)\n\t"
; 3919 :             "setc\t%0"
; 3920 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3921 :             :
; 3922 :             : "cc", "memory", "%rcx"
; 3923 :             );
; 3924 : #else
; 3925 : #error unknown platform
; 3926 : #endif
; 3927 : #else
; 3928 : #error unknown compiler
; 3929 : #endif
; 3930 :         return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 3931 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_4WORDS_ADC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\autogenerated_inline_func.h
;	COMDAT _ADD_8WORDS_ADCX
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_8WORDS_ADCX PROC					; COMDAT

; 3282 :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__89DB6AB9_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 3283 : #ifdef _MSC_VER
; 3284 :         c = _ADDX_UNIT(c, xp[0], yp[0], &zp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3285 :         c = _ADDX_UNIT(c, xp[1], yp[1], &zp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3286 :         c = _ADDX_UNIT(c, xp[2], yp[2], &zp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	edx, 8
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3287 :         c = _ADDX_UNIT(c, xp[3], yp[3], &zp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	edx, 8
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3288 :         c = _ADDX_UNIT(c, xp[4], yp[4], &zp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	edx, 8
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3289 :         c = _ADDX_UNIT(c, xp[5], yp[5], &zp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	edx, 8
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3290 :         c = _ADDX_UNIT(c, xp[6], yp[6], &zp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	edx, 8
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3291 :         c = _ADDX_UNIT(c, xp[7], yp[7], &zp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	edx, 8
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 3292 : #elif defined(__GNUC__)
; 3293 : #ifdef _M_IX86
; 3294 :         __asm__ volatile (
; 3295 :             "addb\t$-1, %0\n\t"
; 3296 :             "movl\t(%1), %%ecx\n\t"
; 3297 :             "adcxl\t(%2), %%ecx\n\t"
; 3298 :             "movl\t%%ecx, (%3)\n\t"
; 3299 :             "movl\t4(%1), %%ecx\n\t"
; 3300 :             "adcxl\t4(%2), %%ecx\n\t"
; 3301 :             "movl\t%%ecx, 4(%3)\n\t"
; 3302 :             "movl\t8(%1), %%ecx\n\t"
; 3303 :             "adcxl\t8(%2), %%ecx\n\t"
; 3304 :             "movl\t%%ecx, 8(%3)\n\t"
; 3305 :             "movl\t12(%1), %%ecx\n\t"
; 3306 :             "adcxl\t12(%2), %%ecx\n\t"
; 3307 :             "movl\t%%ecx, 12(%3)\n\t"
; 3308 :             "movl\t16(%1), %%ecx\n\t"
; 3309 :             "adcxl\t16(%2), %%ecx\n\t"
; 3310 :             "movl\t%%ecx, 16(%3)\n\t"
; 3311 :             "movl\t20(%1), %%ecx\n\t"
; 3312 :             "adcxl\t20(%2), %%ecx\n\t"
; 3313 :             "movl\t%%ecx, 20(%3)\n\t"
; 3314 :             "movl\t24(%1), %%ecx\n\t"
; 3315 :             "adcxl\t24(%2), %%ecx\n\t"
; 3316 :             "movl\t%%ecx, 24(%3)\n\t"
; 3317 :             "movl\t28(%1), %%ecx\n\t"
; 3318 :             "adcxl\t28(%2), %%ecx\n\t"
; 3319 :             "movl\t%%ecx, 28(%3)\n\t"
; 3320 :             "setc\t%0"
; 3321 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3322 :             :
; 3323 :             : "cc", "memory", "%ecx"
; 3324 :             );
; 3325 : #elif defined(_M_IX64)
; 3326 :         __asm__ volatile (
; 3327 :             "addb\t$-1, %0\n\t"
; 3328 :             "movq\t(%1), %%rcx\n\t"
; 3329 :             "adcxq\t(%2), %%rcx\n\t"
; 3330 :             "movq\t%%rcx, (%3)\n\t"
; 3331 :             "movq\t8(%1), %%rcx\n\t"
; 3332 :             "adcxq\t8(%2), %%rcx\n\t"
; 3333 :             "movq\t%%rcx, 8(%3)\n\t"
; 3334 :             "movq\t16(%1), %%rcx\n\t"
; 3335 :             "adcxq\t16(%2), %%rcx\n\t"
; 3336 :             "movq\t%%rcx, 16(%3)\n\t"
; 3337 :             "movq\t24(%1), %%rcx\n\t"
; 3338 :             "adcxq\t24(%2), %%rcx\n\t"
; 3339 :             "movq\t%%rcx, 24(%3)\n\t"
; 3340 :             "movq\t32(%1), %%rcx\n\t"
; 3341 :             "adcxq\t32(%2), %%rcx\n\t"
; 3342 :             "movq\t%%rcx, 32(%3)\n\t"
; 3343 :             "movq\t40(%1), %%rcx\n\t"
; 3344 :             "adcxq\t40(%2), %%rcx\n\t"
; 3345 :             "movq\t%%rcx, 40(%3)\n\t"
; 3346 :             "movq\t48(%1), %%rcx\n\t"
; 3347 :             "adcxq\t48(%2), %%rcx\n\t"
; 3348 :             "movq\t%%rcx, 48(%3)\n\t"
; 3349 :             "movq\t56(%1), %%rcx\n\t"
; 3350 :             "adcxq\t56(%2), %%rcx\n\t"
; 3351 :             "movq\t%%rcx, 56(%3)\n\t"
; 3352 :             "setc\t%0"
; 3353 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3354 :             :
; 3355 :             : "cc", "memory", "%rcx"
; 3356 :             );
; 3357 : #else
; 3358 : #error unknown platform
; 3359 : #endif
; 3360 : #else
; 3361 : #error unknown compiler
; 3362 : #endif
; 3363 :         return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 3364 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_8WORDS_ADCX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\autogenerated_inline_func.h
;	COMDAT _ADD_8WORDS_ADC
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_8WORDS_ADC PROC					; COMDAT

; 3197 :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__89DB6AB9_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 3198 : #ifdef _MSC_VER
; 3199 :         c = _ADD_UNIT(c, xp[0], yp[0], &zp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3200 :         c = _ADD_UNIT(c, xp[1], yp[1], &zp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3201 :         c = _ADD_UNIT(c, xp[2], yp[2], &zp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	edx, 8
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3202 :         c = _ADD_UNIT(c, xp[3], yp[3], &zp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	edx, 8
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3203 :         c = _ADD_UNIT(c, xp[4], yp[4], &zp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	edx, 8
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3204 :         c = _ADD_UNIT(c, xp[5], yp[5], &zp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	edx, 8
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3205 :         c = _ADD_UNIT(c, xp[6], yp[6], &zp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	edx, 8
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3206 :         c = _ADD_UNIT(c, xp[7], yp[7], &zp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	edx, 8
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 3207 : #elif defined(__GNUC__)
; 3208 : #ifdef _M_IX86
; 3209 :         __asm__ volatile (
; 3210 :             "addb\t$-1, %0\n\t"
; 3211 :             "movl\t(%1), %%ecx\n\t"
; 3212 :             "adcl\t(%2), %%ecx\n\t"
; 3213 :             "movl\t%%ecx, (%3)\n\t"
; 3214 :             "movl\t4(%1), %%ecx\n\t"
; 3215 :             "adcl\t4(%2), %%ecx\n\t"
; 3216 :             "movl\t%%ecx, 4(%3)\n\t"
; 3217 :             "movl\t8(%1), %%ecx\n\t"
; 3218 :             "adcl\t8(%2), %%ecx\n\t"
; 3219 :             "movl\t%%ecx, 8(%3)\n\t"
; 3220 :             "movl\t12(%1), %%ecx\n\t"
; 3221 :             "adcl\t12(%2), %%ecx\n\t"
; 3222 :             "movl\t%%ecx, 12(%3)\n\t"
; 3223 :             "movl\t16(%1), %%ecx\n\t"
; 3224 :             "adcl\t16(%2), %%ecx\n\t"
; 3225 :             "movl\t%%ecx, 16(%3)\n\t"
; 3226 :             "movl\t20(%1), %%ecx\n\t"
; 3227 :             "adcl\t20(%2), %%ecx\n\t"
; 3228 :             "movl\t%%ecx, 20(%3)\n\t"
; 3229 :             "movl\t24(%1), %%ecx\n\t"
; 3230 :             "adcl\t24(%2), %%ecx\n\t"
; 3231 :             "movl\t%%ecx, 24(%3)\n\t"
; 3232 :             "movl\t28(%1), %%ecx\n\t"
; 3233 :             "adcl\t28(%2), %%ecx\n\t"
; 3234 :             "movl\t%%ecx, 28(%3)\n\t"
; 3235 :             "setc\t%0"
; 3236 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3237 :             :
; 3238 :             : "cc", "memory", "%ecx"
; 3239 :             );
; 3240 : #elif defined(_M_IX64)
; 3241 :         __asm__ volatile (
; 3242 :             "addb\t$-1, %0\n\t"
; 3243 :             "movq\t(%1), %%rcx\n\t"
; 3244 :             "adcq\t(%2), %%rcx\n\t"
; 3245 :             "movq\t%%rcx, (%3)\n\t"
; 3246 :             "movq\t8(%1), %%rcx\n\t"
; 3247 :             "adcq\t8(%2), %%rcx\n\t"
; 3248 :             "movq\t%%rcx, 8(%3)\n\t"
; 3249 :             "movq\t16(%1), %%rcx\n\t"
; 3250 :             "adcq\t16(%2), %%rcx\n\t"
; 3251 :             "movq\t%%rcx, 16(%3)\n\t"
; 3252 :             "movq\t24(%1), %%rcx\n\t"
; 3253 :             "adcq\t24(%2), %%rcx\n\t"
; 3254 :             "movq\t%%rcx, 24(%3)\n\t"
; 3255 :             "movq\t32(%1), %%rcx\n\t"
; 3256 :             "adcq\t32(%2), %%rcx\n\t"
; 3257 :             "movq\t%%rcx, 32(%3)\n\t"
; 3258 :             "movq\t40(%1), %%rcx\n\t"
; 3259 :             "adcq\t40(%2), %%rcx\n\t"
; 3260 :             "movq\t%%rcx, 40(%3)\n\t"
; 3261 :             "movq\t48(%1), %%rcx\n\t"
; 3262 :             "adcq\t48(%2), %%rcx\n\t"
; 3263 :             "movq\t%%rcx, 48(%3)\n\t"
; 3264 :             "movq\t56(%1), %%rcx\n\t"
; 3265 :             "adcq\t56(%2), %%rcx\n\t"
; 3266 :             "movq\t%%rcx, 56(%3)\n\t"
; 3267 :             "setc\t%0"
; 3268 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3269 :             :
; 3270 :             : "cc", "memory", "%rcx"
; 3271 :             );
; 3272 : #else
; 3273 : #error unknown platform
; 3274 : #endif
; 3275 : #else
; 3276 : #error unknown compiler
; 3277 : #endif
; 3278 :         return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 3279 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_8WORDS_ADC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\autogenerated_inline_func.h
;	COMDAT _ADD_16WORDS_ADCX
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_16WORDS_ADCX PROC					; COMDAT

; 2210 :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__89DB6AB9_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 2211 : #ifdef _MSC_VER
; 2212 :         c = _ADDX_UNIT(c, xp[0], yp[0], &zp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2213 :         c = _ADDX_UNIT(c, xp[1], yp[1], &zp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2214 :         c = _ADDX_UNIT(c, xp[2], yp[2], &zp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	edx, 8
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2215 :         c = _ADDX_UNIT(c, xp[3], yp[3], &zp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	edx, 8
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2216 :         c = _ADDX_UNIT(c, xp[4], yp[4], &zp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	edx, 8
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2217 :         c = _ADDX_UNIT(c, xp[5], yp[5], &zp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	edx, 8
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2218 :         c = _ADDX_UNIT(c, xp[6], yp[6], &zp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	edx, 8
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2219 :         c = _ADDX_UNIT(c, xp[7], yp[7], &zp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	edx, 8
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2220 :         c = _ADDX_UNIT(c, xp[8], yp[8], &zp[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	edx, 8
	imul	rdx, rdx, 8
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2221 :         c = _ADDX_UNIT(c, xp[9], yp[9], &zp[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	edx, 8
	imul	rdx, rdx, 9
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2222 :         c = _ADDX_UNIT(c, xp[10], yp[10], &zp[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	edx, 8
	imul	rdx, rdx, 10
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2223 :         c = _ADDX_UNIT(c, xp[11], yp[11], &zp[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	edx, 8
	imul	rdx, rdx, 11
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2224 :         c = _ADDX_UNIT(c, xp[12], yp[12], &zp[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	edx, 8
	imul	rdx, rdx, 12
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2225 :         c = _ADDX_UNIT(c, xp[13], yp[13], &zp[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	edx, 8
	imul	rdx, rdx, 13
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2226 :         c = _ADDX_UNIT(c, xp[14], yp[14], &zp[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	edx, 8
	imul	rdx, rdx, 14
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2227 :         c = _ADDX_UNIT(c, xp[15], yp[15], &zp[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	edx, 8
	imul	rdx, rdx, 15
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 2228 : #elif defined(__GNUC__)
; 2229 : #ifdef _M_IX86
; 2230 :         __asm__ volatile (
; 2231 :             "addb\t$-1, %0\n\t"
; 2232 :             "movl\t(%1), %%ecx\n\t"
; 2233 :             "adcxl\t(%2), %%ecx\n\t"
; 2234 :             "movl\t%%ecx, (%3)\n\t"
; 2235 :             "movl\t4(%1), %%ecx\n\t"
; 2236 :             "adcxl\t4(%2), %%ecx\n\t"
; 2237 :             "movl\t%%ecx, 4(%3)\n\t"
; 2238 :             "movl\t8(%1), %%ecx\n\t"
; 2239 :             "adcxl\t8(%2), %%ecx\n\t"
; 2240 :             "movl\t%%ecx, 8(%3)\n\t"
; 2241 :             "movl\t12(%1), %%ecx\n\t"
; 2242 :             "adcxl\t12(%2), %%ecx\n\t"
; 2243 :             "movl\t%%ecx, 12(%3)\n\t"
; 2244 :             "movl\t16(%1), %%ecx\n\t"
; 2245 :             "adcxl\t16(%2), %%ecx\n\t"
; 2246 :             "movl\t%%ecx, 16(%3)\n\t"
; 2247 :             "movl\t20(%1), %%ecx\n\t"
; 2248 :             "adcxl\t20(%2), %%ecx\n\t"
; 2249 :             "movl\t%%ecx, 20(%3)\n\t"
; 2250 :             "movl\t24(%1), %%ecx\n\t"
; 2251 :             "adcxl\t24(%2), %%ecx\n\t"
; 2252 :             "movl\t%%ecx, 24(%3)\n\t"
; 2253 :             "movl\t28(%1), %%ecx\n\t"
; 2254 :             "adcxl\t28(%2), %%ecx\n\t"
; 2255 :             "movl\t%%ecx, 28(%3)\n\t"
; 2256 :             "movl\t32(%1), %%ecx\n\t"
; 2257 :             "adcxl\t32(%2), %%ecx\n\t"
; 2258 :             "movl\t%%ecx, 32(%3)\n\t"
; 2259 :             "movl\t36(%1), %%ecx\n\t"
; 2260 :             "adcxl\t36(%2), %%ecx\n\t"
; 2261 :             "movl\t%%ecx, 36(%3)\n\t"
; 2262 :             "movl\t40(%1), %%ecx\n\t"
; 2263 :             "adcxl\t40(%2), %%ecx\n\t"
; 2264 :             "movl\t%%ecx, 40(%3)\n\t"
; 2265 :             "movl\t44(%1), %%ecx\n\t"
; 2266 :             "adcxl\t44(%2), %%ecx\n\t"
; 2267 :             "movl\t%%ecx, 44(%3)\n\t"
; 2268 :             "movl\t48(%1), %%ecx\n\t"
; 2269 :             "adcxl\t48(%2), %%ecx\n\t"
; 2270 :             "movl\t%%ecx, 48(%3)\n\t"
; 2271 :             "movl\t52(%1), %%ecx\n\t"
; 2272 :             "adcxl\t52(%2), %%ecx\n\t"
; 2273 :             "movl\t%%ecx, 52(%3)\n\t"
; 2274 :             "movl\t56(%1), %%ecx\n\t"
; 2275 :             "adcxl\t56(%2), %%ecx\n\t"
; 2276 :             "movl\t%%ecx, 56(%3)\n\t"
; 2277 :             "movl\t60(%1), %%ecx\n\t"
; 2278 :             "adcxl\t60(%2), %%ecx\n\t"
; 2279 :             "movl\t%%ecx, 60(%3)\n\t"
; 2280 :             "setc\t%0"
; 2281 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 2282 :             :
; 2283 :             : "cc", "memory", "%ecx"
; 2284 :             );
; 2285 : #elif defined(_M_IX64)
; 2286 :         __asm__ volatile (
; 2287 :             "addb\t$-1, %0\n\t"
; 2288 :             "movq\t(%1), %%rcx\n\t"
; 2289 :             "adcxq\t(%2), %%rcx\n\t"
; 2290 :             "movq\t%%rcx, (%3)\n\t"
; 2291 :             "movq\t8(%1), %%rcx\n\t"
; 2292 :             "adcxq\t8(%2), %%rcx\n\t"
; 2293 :             "movq\t%%rcx, 8(%3)\n\t"
; 2294 :             "movq\t16(%1), %%rcx\n\t"
; 2295 :             "adcxq\t16(%2), %%rcx\n\t"
; 2296 :             "movq\t%%rcx, 16(%3)\n\t"
; 2297 :             "movq\t24(%1), %%rcx\n\t"
; 2298 :             "adcxq\t24(%2), %%rcx\n\t"
; 2299 :             "movq\t%%rcx, 24(%3)\n\t"
; 2300 :             "movq\t32(%1), %%rcx\n\t"
; 2301 :             "adcxq\t32(%2), %%rcx\n\t"
; 2302 :             "movq\t%%rcx, 32(%3)\n\t"
; 2303 :             "movq\t40(%1), %%rcx\n\t"
; 2304 :             "adcxq\t40(%2), %%rcx\n\t"
; 2305 :             "movq\t%%rcx, 40(%3)\n\t"
; 2306 :             "movq\t48(%1), %%rcx\n\t"
; 2307 :             "adcxq\t48(%2), %%rcx\n\t"
; 2308 :             "movq\t%%rcx, 48(%3)\n\t"
; 2309 :             "movq\t56(%1), %%rcx\n\t"
; 2310 :             "adcxq\t56(%2), %%rcx\n\t"
; 2311 :             "movq\t%%rcx, 56(%3)\n\t"
; 2312 :             "movq\t64(%1), %%rcx\n\t"
; 2313 :             "adcxq\t64(%2), %%rcx\n\t"
; 2314 :             "movq\t%%rcx, 64(%3)\n\t"
; 2315 :             "movq\t72(%1), %%rcx\n\t"
; 2316 :             "adcxq\t72(%2), %%rcx\n\t"
; 2317 :             "movq\t%%rcx, 72(%3)\n\t"
; 2318 :             "movq\t80(%1), %%rcx\n\t"
; 2319 :             "adcxq\t80(%2), %%rcx\n\t"
; 2320 :             "movq\t%%rcx, 80(%3)\n\t"
; 2321 :             "movq\t88(%1), %%rcx\n\t"
; 2322 :             "adcxq\t88(%2), %%rcx\n\t"
; 2323 :             "movq\t%%rcx, 88(%3)\n\t"
; 2324 :             "movq\t96(%1), %%rcx\n\t"
; 2325 :             "adcxq\t96(%2), %%rcx\n\t"
; 2326 :             "movq\t%%rcx, 96(%3)\n\t"
; 2327 :             "movq\t104(%1), %%rcx\n\t"
; 2328 :             "adcxq\t104(%2), %%rcx\n\t"
; 2329 :             "movq\t%%rcx, 104(%3)\n\t"
; 2330 :             "movq\t112(%1), %%rcx\n\t"
; 2331 :             "adcxq\t112(%2), %%rcx\n\t"
; 2332 :             "movq\t%%rcx, 112(%3)\n\t"
; 2333 :             "movq\t120(%1), %%rcx\n\t"
; 2334 :             "adcxq\t120(%2), %%rcx\n\t"
; 2335 :             "movq\t%%rcx, 120(%3)\n\t"
; 2336 :             "setc\t%0"
; 2337 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 2338 :             :
; 2339 :             : "cc", "memory", "%rcx"
; 2340 :             );
; 2341 : #else
; 2342 : #error unknown platform
; 2343 : #endif
; 2344 : #else
; 2345 : #error unknown compiler
; 2346 : #endif
; 2347 :         return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 2348 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_16WORDS_ADCX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\autogenerated_inline_func.h
;	COMDAT _ADD_16WORDS_ADC
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_16WORDS_ADC PROC					; COMDAT

; 2069 :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__89DB6AB9_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 2070 : #ifdef _MSC_VER
; 2071 :         c = _ADD_UNIT(c, xp[0], yp[0], &zp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2072 :         c = _ADD_UNIT(c, xp[1], yp[1], &zp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2073 :         c = _ADD_UNIT(c, xp[2], yp[2], &zp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	edx, 8
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2074 :         c = _ADD_UNIT(c, xp[3], yp[3], &zp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	edx, 8
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2075 :         c = _ADD_UNIT(c, xp[4], yp[4], &zp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	edx, 8
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2076 :         c = _ADD_UNIT(c, xp[5], yp[5], &zp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	edx, 8
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2077 :         c = _ADD_UNIT(c, xp[6], yp[6], &zp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	edx, 8
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2078 :         c = _ADD_UNIT(c, xp[7], yp[7], &zp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	edx, 8
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2079 :         c = _ADD_UNIT(c, xp[8], yp[8], &zp[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	edx, 8
	imul	rdx, rdx, 8
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2080 :         c = _ADD_UNIT(c, xp[9], yp[9], &zp[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	edx, 8
	imul	rdx, rdx, 9
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2081 :         c = _ADD_UNIT(c, xp[10], yp[10], &zp[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	edx, 8
	imul	rdx, rdx, 10
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2082 :         c = _ADD_UNIT(c, xp[11], yp[11], &zp[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	edx, 8
	imul	rdx, rdx, 11
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2083 :         c = _ADD_UNIT(c, xp[12], yp[12], &zp[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	edx, 8
	imul	rdx, rdx, 12
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2084 :         c = _ADD_UNIT(c, xp[13], yp[13], &zp[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	edx, 8
	imul	rdx, rdx, 13
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2085 :         c = _ADD_UNIT(c, xp[14], yp[14], &zp[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	edx, 8
	imul	rdx, rdx, 14
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2086 :         c = _ADD_UNIT(c, xp[15], yp[15], &zp[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	edx, 8
	imul	rdx, rdx, 15
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 2087 : #elif defined(__GNUC__)
; 2088 : #ifdef _M_IX86
; 2089 :         __asm__ volatile (
; 2090 :             "addb\t$-1, %0\n\t"
; 2091 :             "movl\t(%1), %%ecx\n\t"
; 2092 :             "adcl\t(%2), %%ecx\n\t"
; 2093 :             "movl\t%%ecx, (%3)\n\t"
; 2094 :             "movl\t4(%1), %%ecx\n\t"
; 2095 :             "adcl\t4(%2), %%ecx\n\t"
; 2096 :             "movl\t%%ecx, 4(%3)\n\t"
; 2097 :             "movl\t8(%1), %%ecx\n\t"
; 2098 :             "adcl\t8(%2), %%ecx\n\t"
; 2099 :             "movl\t%%ecx, 8(%3)\n\t"
; 2100 :             "movl\t12(%1), %%ecx\n\t"
; 2101 :             "adcl\t12(%2), %%ecx\n\t"
; 2102 :             "movl\t%%ecx, 12(%3)\n\t"
; 2103 :             "movl\t16(%1), %%ecx\n\t"
; 2104 :             "adcl\t16(%2), %%ecx\n\t"
; 2105 :             "movl\t%%ecx, 16(%3)\n\t"
; 2106 :             "movl\t20(%1), %%ecx\n\t"
; 2107 :             "adcl\t20(%2), %%ecx\n\t"
; 2108 :             "movl\t%%ecx, 20(%3)\n\t"
; 2109 :             "movl\t24(%1), %%ecx\n\t"
; 2110 :             "adcl\t24(%2), %%ecx\n\t"
; 2111 :             "movl\t%%ecx, 24(%3)\n\t"
; 2112 :             "movl\t28(%1), %%ecx\n\t"
; 2113 :             "adcl\t28(%2), %%ecx\n\t"
; 2114 :             "movl\t%%ecx, 28(%3)\n\t"
; 2115 :             "movl\t32(%1), %%ecx\n\t"
; 2116 :             "adcl\t32(%2), %%ecx\n\t"
; 2117 :             "movl\t%%ecx, 32(%3)\n\t"
; 2118 :             "movl\t36(%1), %%ecx\n\t"
; 2119 :             "adcl\t36(%2), %%ecx\n\t"
; 2120 :             "movl\t%%ecx, 36(%3)\n\t"
; 2121 :             "movl\t40(%1), %%ecx\n\t"
; 2122 :             "adcl\t40(%2), %%ecx\n\t"
; 2123 :             "movl\t%%ecx, 40(%3)\n\t"
; 2124 :             "movl\t44(%1), %%ecx\n\t"
; 2125 :             "adcl\t44(%2), %%ecx\n\t"
; 2126 :             "movl\t%%ecx, 44(%3)\n\t"
; 2127 :             "movl\t48(%1), %%ecx\n\t"
; 2128 :             "adcl\t48(%2), %%ecx\n\t"
; 2129 :             "movl\t%%ecx, 48(%3)\n\t"
; 2130 :             "movl\t52(%1), %%ecx\n\t"
; 2131 :             "adcl\t52(%2), %%ecx\n\t"
; 2132 :             "movl\t%%ecx, 52(%3)\n\t"
; 2133 :             "movl\t56(%1), %%ecx\n\t"
; 2134 :             "adcl\t56(%2), %%ecx\n\t"
; 2135 :             "movl\t%%ecx, 56(%3)\n\t"
; 2136 :             "movl\t60(%1), %%ecx\n\t"
; 2137 :             "adcl\t60(%2), %%ecx\n\t"
; 2138 :             "movl\t%%ecx, 60(%3)\n\t"
; 2139 :             "setc\t%0"
; 2140 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 2141 :             :
; 2142 :             : "cc", "memory", "%ecx"
; 2143 :             );
; 2144 : #elif defined(_M_IX64)
; 2145 :         __asm__ volatile (
; 2146 :             "addb\t$-1, %0\n\t"
; 2147 :             "movq\t(%1), %%rcx\n\t"
; 2148 :             "adcq\t(%2), %%rcx\n\t"
; 2149 :             "movq\t%%rcx, (%3)\n\t"
; 2150 :             "movq\t8(%1), %%rcx\n\t"
; 2151 :             "adcq\t8(%2), %%rcx\n\t"
; 2152 :             "movq\t%%rcx, 8(%3)\n\t"
; 2153 :             "movq\t16(%1), %%rcx\n\t"
; 2154 :             "adcq\t16(%2), %%rcx\n\t"
; 2155 :             "movq\t%%rcx, 16(%3)\n\t"
; 2156 :             "movq\t24(%1), %%rcx\n\t"
; 2157 :             "adcq\t24(%2), %%rcx\n\t"
; 2158 :             "movq\t%%rcx, 24(%3)\n\t"
; 2159 :             "movq\t32(%1), %%rcx\n\t"
; 2160 :             "adcq\t32(%2), %%rcx\n\t"
; 2161 :             "movq\t%%rcx, 32(%3)\n\t"
; 2162 :             "movq\t40(%1), %%rcx\n\t"
; 2163 :             "adcq\t40(%2), %%rcx\n\t"
; 2164 :             "movq\t%%rcx, 40(%3)\n\t"
; 2165 :             "movq\t48(%1), %%rcx\n\t"
; 2166 :             "adcq\t48(%2), %%rcx\n\t"
; 2167 :             "movq\t%%rcx, 48(%3)\n\t"
; 2168 :             "movq\t56(%1), %%rcx\n\t"
; 2169 :             "adcq\t56(%2), %%rcx\n\t"
; 2170 :             "movq\t%%rcx, 56(%3)\n\t"
; 2171 :             "movq\t64(%1), %%rcx\n\t"
; 2172 :             "adcq\t64(%2), %%rcx\n\t"
; 2173 :             "movq\t%%rcx, 64(%3)\n\t"
; 2174 :             "movq\t72(%1), %%rcx\n\t"
; 2175 :             "adcq\t72(%2), %%rcx\n\t"
; 2176 :             "movq\t%%rcx, 72(%3)\n\t"
; 2177 :             "movq\t80(%1), %%rcx\n\t"
; 2178 :             "adcq\t80(%2), %%rcx\n\t"
; 2179 :             "movq\t%%rcx, 80(%3)\n\t"
; 2180 :             "movq\t88(%1), %%rcx\n\t"
; 2181 :             "adcq\t88(%2), %%rcx\n\t"
; 2182 :             "movq\t%%rcx, 88(%3)\n\t"
; 2183 :             "movq\t96(%1), %%rcx\n\t"
; 2184 :             "adcq\t96(%2), %%rcx\n\t"
; 2185 :             "movq\t%%rcx, 96(%3)\n\t"
; 2186 :             "movq\t104(%1), %%rcx\n\t"
; 2187 :             "adcq\t104(%2), %%rcx\n\t"
; 2188 :             "movq\t%%rcx, 104(%3)\n\t"
; 2189 :             "movq\t112(%1), %%rcx\n\t"
; 2190 :             "adcq\t112(%2), %%rcx\n\t"
; 2191 :             "movq\t%%rcx, 112(%3)\n\t"
; 2192 :             "movq\t120(%1), %%rcx\n\t"
; 2193 :             "adcq\t120(%2), %%rcx\n\t"
; 2194 :             "movq\t%%rcx, 120(%3)\n\t"
; 2195 :             "setc\t%0"
; 2196 :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 2197 :             :
; 2198 :             : "cc", "memory", "%rcx"
; 2199 :             );
; 2200 : #else
; 2201 : #error unknown platform
; 2202 : #endif
; 2203 : #else
; 2204 : #error unknown compiler
; 2205 : #endif
; 2206 :         return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 2207 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_16WORDS_ADC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\autogenerated_inline_func.h
;	COMDAT _ADD_32WORDS_ADCX
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_32WORDS_ADCX PROC					; COMDAT

; 298  :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__89DB6AB9_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 299  : #ifdef _MSC_VER
; 300  :         c = _ADDX_UNIT(c, xp[0], yp[0], &zp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 301  :         c = _ADDX_UNIT(c, xp[1], yp[1], &zp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 302  :         c = _ADDX_UNIT(c, xp[2], yp[2], &zp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	edx, 8
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 303  :         c = _ADDX_UNIT(c, xp[3], yp[3], &zp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	edx, 8
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 304  :         c = _ADDX_UNIT(c, xp[4], yp[4], &zp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	edx, 8
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 305  :         c = _ADDX_UNIT(c, xp[5], yp[5], &zp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	edx, 8
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 306  :         c = _ADDX_UNIT(c, xp[6], yp[6], &zp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	edx, 8
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 307  :         c = _ADDX_UNIT(c, xp[7], yp[7], &zp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	edx, 8
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 308  :         c = _ADDX_UNIT(c, xp[8], yp[8], &zp[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	edx, 8
	imul	rdx, rdx, 8
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 309  :         c = _ADDX_UNIT(c, xp[9], yp[9], &zp[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	edx, 8
	imul	rdx, rdx, 9
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 310  :         c = _ADDX_UNIT(c, xp[10], yp[10], &zp[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	edx, 8
	imul	rdx, rdx, 10
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 311  :         c = _ADDX_UNIT(c, xp[11], yp[11], &zp[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	edx, 8
	imul	rdx, rdx, 11
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 312  :         c = _ADDX_UNIT(c, xp[12], yp[12], &zp[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	edx, 8
	imul	rdx, rdx, 12
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 313  :         c = _ADDX_UNIT(c, xp[13], yp[13], &zp[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	edx, 8
	imul	rdx, rdx, 13
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 314  :         c = _ADDX_UNIT(c, xp[14], yp[14], &zp[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	edx, 8
	imul	rdx, rdx, 14
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 315  :         c = _ADDX_UNIT(c, xp[15], yp[15], &zp[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	edx, 8
	imul	rdx, rdx, 15
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 316  :         c = _ADDX_UNIT(c, xp[16], yp[16], &zp[16]);

	mov	eax, 8
	imul	rax, rax, 16
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 16
	mov	edx, 8
	imul	rdx, rdx, 16
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 317  :         c = _ADDX_UNIT(c, xp[17], yp[17], &zp[17]);

	mov	eax, 8
	imul	rax, rax, 17
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 17
	mov	edx, 8
	imul	rdx, rdx, 17
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 318  :         c = _ADDX_UNIT(c, xp[18], yp[18], &zp[18]);

	mov	eax, 8
	imul	rax, rax, 18
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 18
	mov	edx, 8
	imul	rdx, rdx, 18
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 319  :         c = _ADDX_UNIT(c, xp[19], yp[19], &zp[19]);

	mov	eax, 8
	imul	rax, rax, 19
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 19
	mov	edx, 8
	imul	rdx, rdx, 19
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 320  :         c = _ADDX_UNIT(c, xp[20], yp[20], &zp[20]);

	mov	eax, 8
	imul	rax, rax, 20
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 20
	mov	edx, 8
	imul	rdx, rdx, 20
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 321  :         c = _ADDX_UNIT(c, xp[21], yp[21], &zp[21]);

	mov	eax, 8
	imul	rax, rax, 21
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 21
	mov	edx, 8
	imul	rdx, rdx, 21
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 322  :         c = _ADDX_UNIT(c, xp[22], yp[22], &zp[22]);

	mov	eax, 8
	imul	rax, rax, 22
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 22
	mov	edx, 8
	imul	rdx, rdx, 22
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 323  :         c = _ADDX_UNIT(c, xp[23], yp[23], &zp[23]);

	mov	eax, 8
	imul	rax, rax, 23
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 23
	mov	edx, 8
	imul	rdx, rdx, 23
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 324  :         c = _ADDX_UNIT(c, xp[24], yp[24], &zp[24]);

	mov	eax, 8
	imul	rax, rax, 24
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 24
	mov	edx, 8
	imul	rdx, rdx, 24
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 325  :         c = _ADDX_UNIT(c, xp[25], yp[25], &zp[25]);

	mov	eax, 8
	imul	rax, rax, 25
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 25
	mov	edx, 8
	imul	rdx, rdx, 25
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 326  :         c = _ADDX_UNIT(c, xp[26], yp[26], &zp[26]);

	mov	eax, 8
	imul	rax, rax, 26
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 26
	mov	edx, 8
	imul	rdx, rdx, 26
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 327  :         c = _ADDX_UNIT(c, xp[27], yp[27], &zp[27]);

	mov	eax, 8
	imul	rax, rax, 27
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 27
	mov	edx, 8
	imul	rdx, rdx, 27
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 328  :         c = _ADDX_UNIT(c, xp[28], yp[28], &zp[28]);

	mov	eax, 8
	imul	rax, rax, 28
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 28
	mov	edx, 8
	imul	rdx, rdx, 28
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 329  :         c = _ADDX_UNIT(c, xp[29], yp[29], &zp[29]);

	mov	eax, 8
	imul	rax, rax, 29
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 29
	mov	edx, 8
	imul	rdx, rdx, 29
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 330  :         c = _ADDX_UNIT(c, xp[30], yp[30], &zp[30]);

	mov	eax, 8
	imul	rax, rax, 30
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 30
	mov	edx, 8
	imul	rdx, rdx, 30
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 331  :         c = _ADDX_UNIT(c, xp[31], yp[31], &zp[31]);

	mov	eax, 8
	imul	rax, rax, 31
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 31
	mov	edx, 8
	imul	rdx, rdx, 31
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT
	mov	BYTE PTR c$[rbp], al

; 332  : #elif defined(__GNUC__)
; 333  : #ifdef _M_IX86
; 334  :         __asm__ volatile (
; 335  :             "addb\t$-1, %0\n\t"
; 336  :             "movl\t(%1), %%ecx\n\t"
; 337  :             "adcxl\t(%2), %%ecx\n\t"
; 338  :             "movl\t%%ecx, (%3)\n\t"
; 339  :             "movl\t4(%1), %%ecx\n\t"
; 340  :             "adcxl\t4(%2), %%ecx\n\t"
; 341  :             "movl\t%%ecx, 4(%3)\n\t"
; 342  :             "movl\t8(%1), %%ecx\n\t"
; 343  :             "adcxl\t8(%2), %%ecx\n\t"
; 344  :             "movl\t%%ecx, 8(%3)\n\t"
; 345  :             "movl\t12(%1), %%ecx\n\t"
; 346  :             "adcxl\t12(%2), %%ecx\n\t"
; 347  :             "movl\t%%ecx, 12(%3)\n\t"
; 348  :             "movl\t16(%1), %%ecx\n\t"
; 349  :             "adcxl\t16(%2), %%ecx\n\t"
; 350  :             "movl\t%%ecx, 16(%3)\n\t"
; 351  :             "movl\t20(%1), %%ecx\n\t"
; 352  :             "adcxl\t20(%2), %%ecx\n\t"
; 353  :             "movl\t%%ecx, 20(%3)\n\t"
; 354  :             "movl\t24(%1), %%ecx\n\t"
; 355  :             "adcxl\t24(%2), %%ecx\n\t"
; 356  :             "movl\t%%ecx, 24(%3)\n\t"
; 357  :             "movl\t28(%1), %%ecx\n\t"
; 358  :             "adcxl\t28(%2), %%ecx\n\t"
; 359  :             "movl\t%%ecx, 28(%3)\n\t"
; 360  :             "movl\t32(%1), %%ecx\n\t"
; 361  :             "adcxl\t32(%2), %%ecx\n\t"
; 362  :             "movl\t%%ecx, 32(%3)\n\t"
; 363  :             "movl\t36(%1), %%ecx\n\t"
; 364  :             "adcxl\t36(%2), %%ecx\n\t"
; 365  :             "movl\t%%ecx, 36(%3)\n\t"
; 366  :             "movl\t40(%1), %%ecx\n\t"
; 367  :             "adcxl\t40(%2), %%ecx\n\t"
; 368  :             "movl\t%%ecx, 40(%3)\n\t"
; 369  :             "movl\t44(%1), %%ecx\n\t"
; 370  :             "adcxl\t44(%2), %%ecx\n\t"
; 371  :             "movl\t%%ecx, 44(%3)\n\t"
; 372  :             "movl\t48(%1), %%ecx\n\t"
; 373  :             "adcxl\t48(%2), %%ecx\n\t"
; 374  :             "movl\t%%ecx, 48(%3)\n\t"
; 375  :             "movl\t52(%1), %%ecx\n\t"
; 376  :             "adcxl\t52(%2), %%ecx\n\t"
; 377  :             "movl\t%%ecx, 52(%3)\n\t"
; 378  :             "movl\t56(%1), %%ecx\n\t"
; 379  :             "adcxl\t56(%2), %%ecx\n\t"
; 380  :             "movl\t%%ecx, 56(%3)\n\t"
; 381  :             "movl\t60(%1), %%ecx\n\t"
; 382  :             "adcxl\t60(%2), %%ecx\n\t"
; 383  :             "movl\t%%ecx, 60(%3)\n\t"
; 384  :             "movl\t64(%1), %%ecx\n\t"
; 385  :             "adcxl\t64(%2), %%ecx\n\t"
; 386  :             "movl\t%%ecx, 64(%3)\n\t"
; 387  :             "movl\t68(%1), %%ecx\n\t"
; 388  :             "adcxl\t68(%2), %%ecx\n\t"
; 389  :             "movl\t%%ecx, 68(%3)\n\t"
; 390  :             "movl\t72(%1), %%ecx\n\t"
; 391  :             "adcxl\t72(%2), %%ecx\n\t"
; 392  :             "movl\t%%ecx, 72(%3)\n\t"
; 393  :             "movl\t76(%1), %%ecx\n\t"
; 394  :             "adcxl\t76(%2), %%ecx\n\t"
; 395  :             "movl\t%%ecx, 76(%3)\n\t"
; 396  :             "movl\t80(%1), %%ecx\n\t"
; 397  :             "adcxl\t80(%2), %%ecx\n\t"
; 398  :             "movl\t%%ecx, 80(%3)\n\t"
; 399  :             "movl\t84(%1), %%ecx\n\t"
; 400  :             "adcxl\t84(%2), %%ecx\n\t"
; 401  :             "movl\t%%ecx, 84(%3)\n\t"
; 402  :             "movl\t88(%1), %%ecx\n\t"
; 403  :             "adcxl\t88(%2), %%ecx\n\t"
; 404  :             "movl\t%%ecx, 88(%3)\n\t"
; 405  :             "movl\t92(%1), %%ecx\n\t"
; 406  :             "adcxl\t92(%2), %%ecx\n\t"
; 407  :             "movl\t%%ecx, 92(%3)\n\t"
; 408  :             "movl\t96(%1), %%ecx\n\t"
; 409  :             "adcxl\t96(%2), %%ecx\n\t"
; 410  :             "movl\t%%ecx, 96(%3)\n\t"
; 411  :             "movl\t100(%1), %%ecx\n\t"
; 412  :             "adcxl\t100(%2), %%ecx\n\t"
; 413  :             "movl\t%%ecx, 100(%3)\n\t"
; 414  :             "movl\t104(%1), %%ecx\n\t"
; 415  :             "adcxl\t104(%2), %%ecx\n\t"
; 416  :             "movl\t%%ecx, 104(%3)\n\t"
; 417  :             "movl\t108(%1), %%ecx\n\t"
; 418  :             "adcxl\t108(%2), %%ecx\n\t"
; 419  :             "movl\t%%ecx, 108(%3)\n\t"
; 420  :             "movl\t112(%1), %%ecx\n\t"
; 421  :             "adcxl\t112(%2), %%ecx\n\t"
; 422  :             "movl\t%%ecx, 112(%3)\n\t"
; 423  :             "movl\t116(%1), %%ecx\n\t"
; 424  :             "adcxl\t116(%2), %%ecx\n\t"
; 425  :             "movl\t%%ecx, 116(%3)\n\t"
; 426  :             "movl\t120(%1), %%ecx\n\t"
; 427  :             "adcxl\t120(%2), %%ecx\n\t"
; 428  :             "movl\t%%ecx, 120(%3)\n\t"
; 429  :             "movl\t124(%1), %%ecx\n\t"
; 430  :             "adcxl\t124(%2), %%ecx\n\t"
; 431  :             "movl\t%%ecx, 124(%3)\n\t"
; 432  :             "setc\t%0"
; 433  :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 434  :             :
; 435  :             : "cc", "memory", "%ecx"
; 436  :             );
; 437  : #elif defined(_M_IX64)
; 438  :         __asm__ volatile (
; 439  :             "addb\t$-1, %0\n\t"
; 440  :             "movq\t(%1), %%rcx\n\t"
; 441  :             "adcxq\t(%2), %%rcx\n\t"
; 442  :             "movq\t%%rcx, (%3)\n\t"
; 443  :             "movq\t8(%1), %%rcx\n\t"
; 444  :             "adcxq\t8(%2), %%rcx\n\t"
; 445  :             "movq\t%%rcx, 8(%3)\n\t"
; 446  :             "movq\t16(%1), %%rcx\n\t"
; 447  :             "adcxq\t16(%2), %%rcx\n\t"
; 448  :             "movq\t%%rcx, 16(%3)\n\t"
; 449  :             "movq\t24(%1), %%rcx\n\t"
; 450  :             "adcxq\t24(%2), %%rcx\n\t"
; 451  :             "movq\t%%rcx, 24(%3)\n\t"
; 452  :             "movq\t32(%1), %%rcx\n\t"
; 453  :             "adcxq\t32(%2), %%rcx\n\t"
; 454  :             "movq\t%%rcx, 32(%3)\n\t"
; 455  :             "movq\t40(%1), %%rcx\n\t"
; 456  :             "adcxq\t40(%2), %%rcx\n\t"
; 457  :             "movq\t%%rcx, 40(%3)\n\t"
; 458  :             "movq\t48(%1), %%rcx\n\t"
; 459  :             "adcxq\t48(%2), %%rcx\n\t"
; 460  :             "movq\t%%rcx, 48(%3)\n\t"
; 461  :             "movq\t56(%1), %%rcx\n\t"
; 462  :             "adcxq\t56(%2), %%rcx\n\t"
; 463  :             "movq\t%%rcx, 56(%3)\n\t"
; 464  :             "movq\t64(%1), %%rcx\n\t"
; 465  :             "adcxq\t64(%2), %%rcx\n\t"
; 466  :             "movq\t%%rcx, 64(%3)\n\t"
; 467  :             "movq\t72(%1), %%rcx\n\t"
; 468  :             "adcxq\t72(%2), %%rcx\n\t"
; 469  :             "movq\t%%rcx, 72(%3)\n\t"
; 470  :             "movq\t80(%1), %%rcx\n\t"
; 471  :             "adcxq\t80(%2), %%rcx\n\t"
; 472  :             "movq\t%%rcx, 80(%3)\n\t"
; 473  :             "movq\t88(%1), %%rcx\n\t"
; 474  :             "adcxq\t88(%2), %%rcx\n\t"
; 475  :             "movq\t%%rcx, 88(%3)\n\t"
; 476  :             "movq\t96(%1), %%rcx\n\t"
; 477  :             "adcxq\t96(%2), %%rcx\n\t"
; 478  :             "movq\t%%rcx, 96(%3)\n\t"
; 479  :             "movq\t104(%1), %%rcx\n\t"
; 480  :             "adcxq\t104(%2), %%rcx\n\t"
; 481  :             "movq\t%%rcx, 104(%3)\n\t"
; 482  :             "movq\t112(%1), %%rcx\n\t"
; 483  :             "adcxq\t112(%2), %%rcx\n\t"
; 484  :             "movq\t%%rcx, 112(%3)\n\t"
; 485  :             "movq\t120(%1), %%rcx\n\t"
; 486  :             "adcxq\t120(%2), %%rcx\n\t"
; 487  :             "movq\t%%rcx, 120(%3)\n\t"
; 488  :             "movq\t128(%1), %%rcx\n\t"
; 489  :             "adcxq\t128(%2), %%rcx\n\t"
; 490  :             "movq\t%%rcx, 128(%3)\n\t"
; 491  :             "movq\t136(%1), %%rcx\n\t"
; 492  :             "adcxq\t136(%2), %%rcx\n\t"
; 493  :             "movq\t%%rcx, 136(%3)\n\t"
; 494  :             "movq\t144(%1), %%rcx\n\t"
; 495  :             "adcxq\t144(%2), %%rcx\n\t"
; 496  :             "movq\t%%rcx, 144(%3)\n\t"
; 497  :             "movq\t152(%1), %%rcx\n\t"
; 498  :             "adcxq\t152(%2), %%rcx\n\t"
; 499  :             "movq\t%%rcx, 152(%3)\n\t"
; 500  :             "movq\t160(%1), %%rcx\n\t"
; 501  :             "adcxq\t160(%2), %%rcx\n\t"
; 502  :             "movq\t%%rcx, 160(%3)\n\t"
; 503  :             "movq\t168(%1), %%rcx\n\t"
; 504  :             "adcxq\t168(%2), %%rcx\n\t"
; 505  :             "movq\t%%rcx, 168(%3)\n\t"
; 506  :             "movq\t176(%1), %%rcx\n\t"
; 507  :             "adcxq\t176(%2), %%rcx\n\t"
; 508  :             "movq\t%%rcx, 176(%3)\n\t"
; 509  :             "movq\t184(%1), %%rcx\n\t"
; 510  :             "adcxq\t184(%2), %%rcx\n\t"
; 511  :             "movq\t%%rcx, 184(%3)\n\t"
; 512  :             "movq\t192(%1), %%rcx\n\t"
; 513  :             "adcxq\t192(%2), %%rcx\n\t"
; 514  :             "movq\t%%rcx, 192(%3)\n\t"
; 515  :             "movq\t200(%1), %%rcx\n\t"
; 516  :             "adcxq\t200(%2), %%rcx\n\t"
; 517  :             "movq\t%%rcx, 200(%3)\n\t"
; 518  :             "movq\t208(%1), %%rcx\n\t"
; 519  :             "adcxq\t208(%2), %%rcx\n\t"
; 520  :             "movq\t%%rcx, 208(%3)\n\t"
; 521  :             "movq\t216(%1), %%rcx\n\t"
; 522  :             "adcxq\t216(%2), %%rcx\n\t"
; 523  :             "movq\t%%rcx, 216(%3)\n\t"
; 524  :             "movq\t224(%1), %%rcx\n\t"
; 525  :             "adcxq\t224(%2), %%rcx\n\t"
; 526  :             "movq\t%%rcx, 224(%3)\n\t"
; 527  :             "movq\t232(%1), %%rcx\n\t"
; 528  :             "adcxq\t232(%2), %%rcx\n\t"
; 529  :             "movq\t%%rcx, 232(%3)\n\t"
; 530  :             "movq\t240(%1), %%rcx\n\t"
; 531  :             "adcxq\t240(%2), %%rcx\n\t"
; 532  :             "movq\t%%rcx, 240(%3)\n\t"
; 533  :             "movq\t248(%1), %%rcx\n\t"
; 534  :             "adcxq\t248(%2), %%rcx\n\t"
; 535  :             "movq\t%%rcx, 248(%3)\n\t"
; 536  :             "setc\t%0"
; 537  :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 538  :             :
; 539  :             : "cc", "memory", "%rcx"
; 540  :             );
; 541  : #else
; 542  : #error unknown platform
; 543  : #endif
; 544  : #else
; 545  : #error unknown compiler
; 546  : #endif
; 547  :         return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 548  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_32WORDS_ADCX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\autogenerated_inline_func.h
;	COMDAT _ADD_32WORDS_ADC
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_32WORDS_ADC PROC					; COMDAT

; 45   :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__89DB6AB9_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 46   : #ifdef _MSC_VER
; 47   :         c = _ADD_UNIT(c, xp[0], yp[0], &zp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 48   :         c = _ADD_UNIT(c, xp[1], yp[1], &zp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 49   :         c = _ADD_UNIT(c, xp[2], yp[2], &zp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	edx, 8
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 50   :         c = _ADD_UNIT(c, xp[3], yp[3], &zp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	edx, 8
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 51   :         c = _ADD_UNIT(c, xp[4], yp[4], &zp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	edx, 8
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 52   :         c = _ADD_UNIT(c, xp[5], yp[5], &zp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	edx, 8
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 53   :         c = _ADD_UNIT(c, xp[6], yp[6], &zp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	edx, 8
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 54   :         c = _ADD_UNIT(c, xp[7], yp[7], &zp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	edx, 8
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 55   :         c = _ADD_UNIT(c, xp[8], yp[8], &zp[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	edx, 8
	imul	rdx, rdx, 8
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 56   :         c = _ADD_UNIT(c, xp[9], yp[9], &zp[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	edx, 8
	imul	rdx, rdx, 9
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 57   :         c = _ADD_UNIT(c, xp[10], yp[10], &zp[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	edx, 8
	imul	rdx, rdx, 10
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 58   :         c = _ADD_UNIT(c, xp[11], yp[11], &zp[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	edx, 8
	imul	rdx, rdx, 11
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 59   :         c = _ADD_UNIT(c, xp[12], yp[12], &zp[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	edx, 8
	imul	rdx, rdx, 12
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 60   :         c = _ADD_UNIT(c, xp[13], yp[13], &zp[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	edx, 8
	imul	rdx, rdx, 13
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 61   :         c = _ADD_UNIT(c, xp[14], yp[14], &zp[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	edx, 8
	imul	rdx, rdx, 14
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 62   :         c = _ADD_UNIT(c, xp[15], yp[15], &zp[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	edx, 8
	imul	rdx, rdx, 15
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 63   :         c = _ADD_UNIT(c, xp[16], yp[16], &zp[16]);

	mov	eax, 8
	imul	rax, rax, 16
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 16
	mov	edx, 8
	imul	rdx, rdx, 16
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 64   :         c = _ADD_UNIT(c, xp[17], yp[17], &zp[17]);

	mov	eax, 8
	imul	rax, rax, 17
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 17
	mov	edx, 8
	imul	rdx, rdx, 17
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 65   :         c = _ADD_UNIT(c, xp[18], yp[18], &zp[18]);

	mov	eax, 8
	imul	rax, rax, 18
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 18
	mov	edx, 8
	imul	rdx, rdx, 18
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 66   :         c = _ADD_UNIT(c, xp[19], yp[19], &zp[19]);

	mov	eax, 8
	imul	rax, rax, 19
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 19
	mov	edx, 8
	imul	rdx, rdx, 19
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 67   :         c = _ADD_UNIT(c, xp[20], yp[20], &zp[20]);

	mov	eax, 8
	imul	rax, rax, 20
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 20
	mov	edx, 8
	imul	rdx, rdx, 20
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 68   :         c = _ADD_UNIT(c, xp[21], yp[21], &zp[21]);

	mov	eax, 8
	imul	rax, rax, 21
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 21
	mov	edx, 8
	imul	rdx, rdx, 21
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 69   :         c = _ADD_UNIT(c, xp[22], yp[22], &zp[22]);

	mov	eax, 8
	imul	rax, rax, 22
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 22
	mov	edx, 8
	imul	rdx, rdx, 22
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 70   :         c = _ADD_UNIT(c, xp[23], yp[23], &zp[23]);

	mov	eax, 8
	imul	rax, rax, 23
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 23
	mov	edx, 8
	imul	rdx, rdx, 23
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 71   :         c = _ADD_UNIT(c, xp[24], yp[24], &zp[24]);

	mov	eax, 8
	imul	rax, rax, 24
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 24
	mov	edx, 8
	imul	rdx, rdx, 24
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 72   :         c = _ADD_UNIT(c, xp[25], yp[25], &zp[25]);

	mov	eax, 8
	imul	rax, rax, 25
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 25
	mov	edx, 8
	imul	rdx, rdx, 25
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 73   :         c = _ADD_UNIT(c, xp[26], yp[26], &zp[26]);

	mov	eax, 8
	imul	rax, rax, 26
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 26
	mov	edx, 8
	imul	rdx, rdx, 26
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 74   :         c = _ADD_UNIT(c, xp[27], yp[27], &zp[27]);

	mov	eax, 8
	imul	rax, rax, 27
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 27
	mov	edx, 8
	imul	rdx, rdx, 27
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 75   :         c = _ADD_UNIT(c, xp[28], yp[28], &zp[28]);

	mov	eax, 8
	imul	rax, rax, 28
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 28
	mov	edx, 8
	imul	rdx, rdx, 28
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 76   :         c = _ADD_UNIT(c, xp[29], yp[29], &zp[29]);

	mov	eax, 8
	imul	rax, rax, 29
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 29
	mov	edx, 8
	imul	rdx, rdx, 29
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 77   :         c = _ADD_UNIT(c, xp[30], yp[30], &zp[30]);

	mov	eax, 8
	imul	rax, rax, 30
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 30
	mov	edx, 8
	imul	rdx, rdx, 30
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 78   :         c = _ADD_UNIT(c, xp[31], yp[31], &zp[31]);

	mov	eax, 8
	imul	rax, rax, 31
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 31
	mov	edx, 8
	imul	rdx, rdx, 31
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	rdx, QWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR c$[rbp], al

; 79   : #elif defined(__GNUC__)
; 80   : #ifdef _M_IX86
; 81   :         __asm__ volatile (
; 82   :             "addb\t$-1, %0\n\t"
; 83   :             "movl\t(%1), %%ecx\n\t"
; 84   :             "adcl\t(%2), %%ecx\n\t"
; 85   :             "movl\t%%ecx, (%3)\n\t"
; 86   :             "movl\t4(%1), %%ecx\n\t"
; 87   :             "adcl\t4(%2), %%ecx\n\t"
; 88   :             "movl\t%%ecx, 4(%3)\n\t"
; 89   :             "movl\t8(%1), %%ecx\n\t"
; 90   :             "adcl\t8(%2), %%ecx\n\t"
; 91   :             "movl\t%%ecx, 8(%3)\n\t"
; 92   :             "movl\t12(%1), %%ecx\n\t"
; 93   :             "adcl\t12(%2), %%ecx\n\t"
; 94   :             "movl\t%%ecx, 12(%3)\n\t"
; 95   :             "movl\t16(%1), %%ecx\n\t"
; 96   :             "adcl\t16(%2), %%ecx\n\t"
; 97   :             "movl\t%%ecx, 16(%3)\n\t"
; 98   :             "movl\t20(%1), %%ecx\n\t"
; 99   :             "adcl\t20(%2), %%ecx\n\t"
; 100  :             "movl\t%%ecx, 20(%3)\n\t"
; 101  :             "movl\t24(%1), %%ecx\n\t"
; 102  :             "adcl\t24(%2), %%ecx\n\t"
; 103  :             "movl\t%%ecx, 24(%3)\n\t"
; 104  :             "movl\t28(%1), %%ecx\n\t"
; 105  :             "adcl\t28(%2), %%ecx\n\t"
; 106  :             "movl\t%%ecx, 28(%3)\n\t"
; 107  :             "movl\t32(%1), %%ecx\n\t"
; 108  :             "adcl\t32(%2), %%ecx\n\t"
; 109  :             "movl\t%%ecx, 32(%3)\n\t"
; 110  :             "movl\t36(%1), %%ecx\n\t"
; 111  :             "adcl\t36(%2), %%ecx\n\t"
; 112  :             "movl\t%%ecx, 36(%3)\n\t"
; 113  :             "movl\t40(%1), %%ecx\n\t"
; 114  :             "adcl\t40(%2), %%ecx\n\t"
; 115  :             "movl\t%%ecx, 40(%3)\n\t"
; 116  :             "movl\t44(%1), %%ecx\n\t"
; 117  :             "adcl\t44(%2), %%ecx\n\t"
; 118  :             "movl\t%%ecx, 44(%3)\n\t"
; 119  :             "movl\t48(%1), %%ecx\n\t"
; 120  :             "adcl\t48(%2), %%ecx\n\t"
; 121  :             "movl\t%%ecx, 48(%3)\n\t"
; 122  :             "movl\t52(%1), %%ecx\n\t"
; 123  :             "adcl\t52(%2), %%ecx\n\t"
; 124  :             "movl\t%%ecx, 52(%3)\n\t"
; 125  :             "movl\t56(%1), %%ecx\n\t"
; 126  :             "adcl\t56(%2), %%ecx\n\t"
; 127  :             "movl\t%%ecx, 56(%3)\n\t"
; 128  :             "movl\t60(%1), %%ecx\n\t"
; 129  :             "adcl\t60(%2), %%ecx\n\t"
; 130  :             "movl\t%%ecx, 60(%3)\n\t"
; 131  :             "movl\t64(%1), %%ecx\n\t"
; 132  :             "adcl\t64(%2), %%ecx\n\t"
; 133  :             "movl\t%%ecx, 64(%3)\n\t"
; 134  :             "movl\t68(%1), %%ecx\n\t"
; 135  :             "adcl\t68(%2), %%ecx\n\t"
; 136  :             "movl\t%%ecx, 68(%3)\n\t"
; 137  :             "movl\t72(%1), %%ecx\n\t"
; 138  :             "adcl\t72(%2), %%ecx\n\t"
; 139  :             "movl\t%%ecx, 72(%3)\n\t"
; 140  :             "movl\t76(%1), %%ecx\n\t"
; 141  :             "adcl\t76(%2), %%ecx\n\t"
; 142  :             "movl\t%%ecx, 76(%3)\n\t"
; 143  :             "movl\t80(%1), %%ecx\n\t"
; 144  :             "adcl\t80(%2), %%ecx\n\t"
; 145  :             "movl\t%%ecx, 80(%3)\n\t"
; 146  :             "movl\t84(%1), %%ecx\n\t"
; 147  :             "adcl\t84(%2), %%ecx\n\t"
; 148  :             "movl\t%%ecx, 84(%3)\n\t"
; 149  :             "movl\t88(%1), %%ecx\n\t"
; 150  :             "adcl\t88(%2), %%ecx\n\t"
; 151  :             "movl\t%%ecx, 88(%3)\n\t"
; 152  :             "movl\t92(%1), %%ecx\n\t"
; 153  :             "adcl\t92(%2), %%ecx\n\t"
; 154  :             "movl\t%%ecx, 92(%3)\n\t"
; 155  :             "movl\t96(%1), %%ecx\n\t"
; 156  :             "adcl\t96(%2), %%ecx\n\t"
; 157  :             "movl\t%%ecx, 96(%3)\n\t"
; 158  :             "movl\t100(%1), %%ecx\n\t"
; 159  :             "adcl\t100(%2), %%ecx\n\t"
; 160  :             "movl\t%%ecx, 100(%3)\n\t"
; 161  :             "movl\t104(%1), %%ecx\n\t"
; 162  :             "adcl\t104(%2), %%ecx\n\t"
; 163  :             "movl\t%%ecx, 104(%3)\n\t"
; 164  :             "movl\t108(%1), %%ecx\n\t"
; 165  :             "adcl\t108(%2), %%ecx\n\t"
; 166  :             "movl\t%%ecx, 108(%3)\n\t"
; 167  :             "movl\t112(%1), %%ecx\n\t"
; 168  :             "adcl\t112(%2), %%ecx\n\t"
; 169  :             "movl\t%%ecx, 112(%3)\n\t"
; 170  :             "movl\t116(%1), %%ecx\n\t"
; 171  :             "adcl\t116(%2), %%ecx\n\t"
; 172  :             "movl\t%%ecx, 116(%3)\n\t"
; 173  :             "movl\t120(%1), %%ecx\n\t"
; 174  :             "adcl\t120(%2), %%ecx\n\t"
; 175  :             "movl\t%%ecx, 120(%3)\n\t"
; 176  :             "movl\t124(%1), %%ecx\n\t"
; 177  :             "adcl\t124(%2), %%ecx\n\t"
; 178  :             "movl\t%%ecx, 124(%3)\n\t"
; 179  :             "setc\t%0"
; 180  :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 181  :             :
; 182  :             : "cc", "memory", "%ecx"
; 183  :             );
; 184  : #elif defined(_M_IX64)
; 185  :         __asm__ volatile (
; 186  :             "addb\t$-1, %0\n\t"
; 187  :             "movq\t(%1), %%rcx\n\t"
; 188  :             "adcq\t(%2), %%rcx\n\t"
; 189  :             "movq\t%%rcx, (%3)\n\t"
; 190  :             "movq\t8(%1), %%rcx\n\t"
; 191  :             "adcq\t8(%2), %%rcx\n\t"
; 192  :             "movq\t%%rcx, 8(%3)\n\t"
; 193  :             "movq\t16(%1), %%rcx\n\t"
; 194  :             "adcq\t16(%2), %%rcx\n\t"
; 195  :             "movq\t%%rcx, 16(%3)\n\t"
; 196  :             "movq\t24(%1), %%rcx\n\t"
; 197  :             "adcq\t24(%2), %%rcx\n\t"
; 198  :             "movq\t%%rcx, 24(%3)\n\t"
; 199  :             "movq\t32(%1), %%rcx\n\t"
; 200  :             "adcq\t32(%2), %%rcx\n\t"
; 201  :             "movq\t%%rcx, 32(%3)\n\t"
; 202  :             "movq\t40(%1), %%rcx\n\t"
; 203  :             "adcq\t40(%2), %%rcx\n\t"
; 204  :             "movq\t%%rcx, 40(%3)\n\t"
; 205  :             "movq\t48(%1), %%rcx\n\t"
; 206  :             "adcq\t48(%2), %%rcx\n\t"
; 207  :             "movq\t%%rcx, 48(%3)\n\t"
; 208  :             "movq\t56(%1), %%rcx\n\t"
; 209  :             "adcq\t56(%2), %%rcx\n\t"
; 210  :             "movq\t%%rcx, 56(%3)\n\t"
; 211  :             "movq\t64(%1), %%rcx\n\t"
; 212  :             "adcq\t64(%2), %%rcx\n\t"
; 213  :             "movq\t%%rcx, 64(%3)\n\t"
; 214  :             "movq\t72(%1), %%rcx\n\t"
; 215  :             "adcq\t72(%2), %%rcx\n\t"
; 216  :             "movq\t%%rcx, 72(%3)\n\t"
; 217  :             "movq\t80(%1), %%rcx\n\t"
; 218  :             "adcq\t80(%2), %%rcx\n\t"
; 219  :             "movq\t%%rcx, 80(%3)\n\t"
; 220  :             "movq\t88(%1), %%rcx\n\t"
; 221  :             "adcq\t88(%2), %%rcx\n\t"
; 222  :             "movq\t%%rcx, 88(%3)\n\t"
; 223  :             "movq\t96(%1), %%rcx\n\t"
; 224  :             "adcq\t96(%2), %%rcx\n\t"
; 225  :             "movq\t%%rcx, 96(%3)\n\t"
; 226  :             "movq\t104(%1), %%rcx\n\t"
; 227  :             "adcq\t104(%2), %%rcx\n\t"
; 228  :             "movq\t%%rcx, 104(%3)\n\t"
; 229  :             "movq\t112(%1), %%rcx\n\t"
; 230  :             "adcq\t112(%2), %%rcx\n\t"
; 231  :             "movq\t%%rcx, 112(%3)\n\t"
; 232  :             "movq\t120(%1), %%rcx\n\t"
; 233  :             "adcq\t120(%2), %%rcx\n\t"
; 234  :             "movq\t%%rcx, 120(%3)\n\t"
; 235  :             "movq\t128(%1), %%rcx\n\t"
; 236  :             "adcq\t128(%2), %%rcx\n\t"
; 237  :             "movq\t%%rcx, 128(%3)\n\t"
; 238  :             "movq\t136(%1), %%rcx\n\t"
; 239  :             "adcq\t136(%2), %%rcx\n\t"
; 240  :             "movq\t%%rcx, 136(%3)\n\t"
; 241  :             "movq\t144(%1), %%rcx\n\t"
; 242  :             "adcq\t144(%2), %%rcx\n\t"
; 243  :             "movq\t%%rcx, 144(%3)\n\t"
; 244  :             "movq\t152(%1), %%rcx\n\t"
; 245  :             "adcq\t152(%2), %%rcx\n\t"
; 246  :             "movq\t%%rcx, 152(%3)\n\t"
; 247  :             "movq\t160(%1), %%rcx\n\t"
; 248  :             "adcq\t160(%2), %%rcx\n\t"
; 249  :             "movq\t%%rcx, 160(%3)\n\t"
; 250  :             "movq\t168(%1), %%rcx\n\t"
; 251  :             "adcq\t168(%2), %%rcx\n\t"
; 252  :             "movq\t%%rcx, 168(%3)\n\t"
; 253  :             "movq\t176(%1), %%rcx\n\t"
; 254  :             "adcq\t176(%2), %%rcx\n\t"
; 255  :             "movq\t%%rcx, 176(%3)\n\t"
; 256  :             "movq\t184(%1), %%rcx\n\t"
; 257  :             "adcq\t184(%2), %%rcx\n\t"
; 258  :             "movq\t%%rcx, 184(%3)\n\t"
; 259  :             "movq\t192(%1), %%rcx\n\t"
; 260  :             "adcq\t192(%2), %%rcx\n\t"
; 261  :             "movq\t%%rcx, 192(%3)\n\t"
; 262  :             "movq\t200(%1), %%rcx\n\t"
; 263  :             "adcq\t200(%2), %%rcx\n\t"
; 264  :             "movq\t%%rcx, 200(%3)\n\t"
; 265  :             "movq\t208(%1), %%rcx\n\t"
; 266  :             "adcq\t208(%2), %%rcx\n\t"
; 267  :             "movq\t%%rcx, 208(%3)\n\t"
; 268  :             "movq\t216(%1), %%rcx\n\t"
; 269  :             "adcq\t216(%2), %%rcx\n\t"
; 270  :             "movq\t%%rcx, 216(%3)\n\t"
; 271  :             "movq\t224(%1), %%rcx\n\t"
; 272  :             "adcq\t224(%2), %%rcx\n\t"
; 273  :             "movq\t%%rcx, 224(%3)\n\t"
; 274  :             "movq\t232(%1), %%rcx\n\t"
; 275  :             "adcq\t232(%2), %%rcx\n\t"
; 276  :             "movq\t%%rcx, 232(%3)\n\t"
; 277  :             "movq\t240(%1), %%rcx\n\t"
; 278  :             "adcq\t240(%2), %%rcx\n\t"
; 279  :             "movq\t%%rcx, 240(%3)\n\t"
; 280  :             "movq\t248(%1), %%rcx\n\t"
; 281  :             "adcq\t248(%2), %%rcx\n\t"
; 282  :             "movq\t%%rcx, 248(%3)\n\t"
; 283  :             "setc\t%0"
; 284  :             : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 285  :             :
; 286  :             : "cc", "memory", "%rcx"
; 287  :             );
; 288  : #else
; 289  : #error unknown platform
; 290  : #endif
; 291  : #else
; 292  : #error unknown compiler
; 293  : #endif
; 294  :         return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 295  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_32WORDS_ADC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _LZCNT_ALT_UNIT
_TEXT	SEGMENT
pos$ = 4
x$ = 256
_LZCNT_ALT_UNIT PROC					; COMDAT

; 840  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 841  :     if (x == 0)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN2@LZCNT_ALT_

; 842  :         return (sizeof(x) * 8);

	mov	eax, 64					; 00000040H
	jmp	SHORT $LN1@LZCNT_ALT_
$LN2@LZCNT_ALT_:

; 843  : #ifdef _M_IX86
; 844  :     _UINT32_T pos;
; 845  : #ifdef _MSC_VER
; 846  :     _BitScanReverse(&pos, x);
; 847  : #elif defined(__GNUC__)
; 848  :     __asm__("bsrl %1, %0" : "=r"(pos) : "rm"(x));
; 849  : #else
; 850  : #error unknown compiler
; 851  : #endif
; 852  : #elif defined(_M_X64)
; 853  : #ifdef _MSC_VER
; 854  :     _UINT32_T pos;
; 855  :     _BitScanReverse64(&pos, x);

	mov	rax, QWORD PTR x$[rbp]
	bsr	rax, rax
	mov	DWORD PTR pos$[rbp], eax

; 856  : #elif defined(__GNUC__)
; 857  :     _UINT64_T pos;
; 858  :     __asm__("bsrq %1, %0" : "=r"(pos) : "rm"(x));
; 859  : #else
; 860  : #error unknown compiler
; 861  : #endif
; 862  : #else
; 863  : #error unknown platform
; 864  : #endif
; 865  :     return (sizeof(x) * 8 - 1 - pos);

	mov	eax, DWORD PTR pos$[rbp]
	mov	ecx, 63					; 0000003fH
	sub	rcx, rax
	mov	rax, rcx
$LN1@LZCNT_ALT_:

; 866  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_LZCNT_ALT_UNIT$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_LZCNT_ALT_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _LZCNT_ALT_32
_TEXT	SEGMENT
pos$ = 4
x$ = 256
_LZCNT_ALT_32 PROC					; COMDAT

; 807  : {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 808  :     if (x == 0)

	cmp	DWORD PTR x$[rbp], 0
	jne	SHORT $LN2@LZCNT_ALT_

; 809  :         return (sizeof(x) * 8);

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN1@LZCNT_ALT_
$LN2@LZCNT_ALT_:

; 810  :     _UINT32_T pos;
; 811  : #ifdef _MSC_VER
; 812  :     _BitScanReverse(&pos, x);

	mov	eax, DWORD PTR x$[rbp]
	bsr	eax, eax
	mov	DWORD PTR pos$[rbp], eax

; 813  : #elif defined(__GNUC__)
; 814  :     __asm__( "bsrl %1, %0" : "=r"(pos) : "rm"(x) );
; 815  : #else
; 816  : #error unknown compiler
; 817  : #endif
; 818  :     return (sizeof(x) * 8 - 1 - pos);

	mov	eax, DWORD PTR pos$[rbp]
	mov	ecx, 31
	sub	rcx, rax
	mov	rax, rcx
$LN1@LZCNT_ALT_:

; 819  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_LZCNT_ALT_32$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_LZCNT_ALT_32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _ADDX_UNIT
_TEXT	SEGMENT
carry$ = 224
u$ = 232
v$ = 240
w$ = 248
_ADDX_UNIT PROC						; COMDAT

; 452  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 453  : #ifdef _M_IX86
; 454  :     return (_addcarryx_u32(carry, u, v, w));
; 455  : #elif defined(_M_X64)
; 456  :     return (_addcarryx_u64(carry, u, v, w));

	mov	rax, QWORD PTR u$[rbp]
	movzx	ecx, BYTE PTR carry$[rbp]
	add	cl, -1
	adcx	rax, QWORD PTR v$[rbp]
	setb	cl
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx], rax
	movzx	eax, cl

; 457  : #else
; 458  : #error unknown platform
; 459  : #endif
; 460  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADDX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _ADD_UNIT
_TEXT	SEGMENT
carry$ = 224
u$ = 232
v$ = 240
w$ = 248
_ADD_UNIT PROC						; COMDAT

; 424  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 425  : #ifdef _M_IX86
; 426  :     return (_addcarry_u32(carry, u, v, w));
; 427  : #elif defined(_M_X64)
; 428  :     return (_addcarry_u64(carry, u, v, w));

	mov	rax, QWORD PTR u$[rbp]
	movzx	ecx, BYTE PTR carry$[rbp]
	add	cl, -1
	adc	rax, QWORD PTR v$[rbp]
	setb	cl
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx], rax
	movzx	eax, cl

; 429  : #else
; 430  : #error unknown platform
; 431  : #endif
; 432  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _MAXIMUM_UNIT
_TEXT	SEGMENT
tv65 = 192
x$ = 240
y$ = 248
_MAXIMUM_UNIT PROC					; COMDAT

; 414  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 415  :     return (x >= y ? x : y);

	mov	rax, QWORD PTR y$[rbp]
	cmp	QWORD PTR x$[rbp], rax
	jb	SHORT $LN3@MAXIMUM_UN
	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR tv65[rbp], rax
	jmp	SHORT $LN4@MAXIMUM_UN
$LN3@MAXIMUM_UN:
	mov	rax, QWORD PTR y$[rbp]
	mov	QWORD PTR tv65[rbp], rax
$LN4@MAXIMUM_UN:
	mov	rax, QWORD PTR tv65[rbp]

; 416  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
_MAXIMUM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _FROMDWORDTOWORD
_TEXT	SEGMENT
value$ = 224
result_high$ = 232
_FROMDWORDTOWORD PROC					; COMDAT

; 393  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 394  :     *result_high = (_UINT32_T)(value >> 32);

	mov	rax, QWORD PTR value$[rbp]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR result_high$[rbp]
	mov	DWORD PTR [rcx], eax

; 395  :     return ((_UINT32_T)value);

	mov	eax, DWORD PTR value$[rbp]

; 396  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FROMDWORDTOWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_add.c
;	COMDAT PMC_Add_X_X
_TEXT	SEGMENT
nx$ = 8
ny$ = 40
result$ = 68
nz$ = 104
x_bit_count$5 = 136
y_bit_count$6 = 168
z_bit_count$7 = 200
nz_light_check_code$8 = 232
x$ = 480
y$ = 488
o$ = 496
PMC_Add_X_X PROC					; COMDAT

; 515  : {

$LN20:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 488				; 000001e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 122				; 0000007aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+520]
	lea	rcx, OFFSET FLAT:__A78DCA81_pmc_add@c
	call	__CheckForDebuggerJustMyCode

; 516  :     if (x == NULL)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN2@PMC_Add_X_

; 517  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Add_X_
$LN2@PMC_Add_X_:

; 518  :     if (y == NULL)

	cmp	QWORD PTR y$[rbp], 0
	jne	SHORT $LN3@PMC_Add_X_

; 519  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Add_X_
$LN3@PMC_Add_X_:

; 520  :     if (o == NULL)

	cmp	QWORD PTR o$[rbp], 0
	jne	SHORT $LN4@PMC_Add_X_

; 521  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Add_X_
$LN4@PMC_Add_X_:

; 522  :     NUMBER_HEADER* nx = (NUMBER_HEADER*)x;

	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR nx$[rbp], rax

; 523  :     NUMBER_HEADER* ny = (NUMBER_HEADER*)y;

	mov	rax, QWORD PTR y$[rbp]
	mov	QWORD PTR ny$[rbp], rax

; 524  :     PMC_STATUS_CODE result;
; 525  :     if ((result = CheckNumber(nx)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nx$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Add_X_

; 526  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN5@PMC_Add_X_:

; 527  :     if ((result = CheckNumber(ny)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR ny$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_Add_X_

; 528  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN6@PMC_Add_X_:

; 529  :     NUMBER_HEADER* nz;
; 530  :     if (nx->IS_ZERO)

	mov	rax, QWORD PTR nx$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@PMC_Add_X_

; 531  :     {
; 532  :         if (ny->IS_ZERO)

	mov	rax, QWORD PTR ny$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@PMC_Add_X_

; 533  :             nz = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nz$[rbp], rax
	jmp	SHORT $LN10@PMC_Add_X_
$LN9@PMC_Add_X_:

; 534  :         else
; 535  :         {
; 536  :             if ((result = DuplicateNumber(ny, &nz)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nz$[rbp]
	mov	rcx, QWORD PTR ny$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN11@PMC_Add_X_

; 537  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN11@PMC_Add_X_:
$LN10@PMC_Add_X_:

; 538  :         }
; 539  :     }

	jmp	$LN8@PMC_Add_X_
$LN7@PMC_Add_X_:

; 540  :     else
; 541  :     {
; 542  :         if (ny->IS_ZERO)

	mov	rax, QWORD PTR ny$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@PMC_Add_X_

; 543  :         {
; 544  :             if ((result = DuplicateNumber(nx, &nz)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nz$[rbp]
	mov	rcx, QWORD PTR nx$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN14@PMC_Add_X_

; 545  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN14@PMC_Add_X_:

; 546  :         }

	jmp	$LN13@PMC_Add_X_
$LN12@PMC_Add_X_:

; 547  :         else
; 548  :         {
; 549  :             __UNIT_TYPE x_bit_count = nx->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nx$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR x_bit_count$5[rbp], rax

; 550  :             __UNIT_TYPE y_bit_count = ny->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR ny$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR y_bit_count$6[rbp], rax

; 551  :             __UNIT_TYPE z_bit_count = _MAXIMUM_UNIT(x_bit_count, y_bit_count) + 1;

	mov	rdx, QWORD PTR y_bit_count$6[rbp]
	mov	rcx, QWORD PTR x_bit_count$5[rbp]
	call	_MAXIMUM_UNIT
	inc	rax
	mov	QWORD PTR z_bit_count$7[rbp], rax

; 552  :             __UNIT_TYPE nz_light_check_code;
; 553  :             if ((result = AllocateNumber(&nz, z_bit_count, &nz_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nz_light_check_code$8[rbp]
	mov	rdx, QWORD PTR z_bit_count$7[rbp]
	lea	rcx, QWORD PTR nz$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN15@PMC_Add_X_

; 554  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN15@PMC_Add_X_:

; 555  :             if ((result = Add_X_X(nx, ny, nz)) != PMC_STATUS_OK)

	mov	r8, QWORD PTR nz$[rbp]
	mov	rdx, QWORD PTR ny$[rbp]
	mov	rcx, QWORD PTR nx$[rbp]
	call	Add_X_X
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN16@PMC_Add_X_

; 556  :             {
; 557  :                 DeallocateNumber(nz);

	mov	rcx, QWORD PTR nz$[rbp]
	call	DeallocateNumber

; 558  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Add_X_
$LN16@PMC_Add_X_:

; 559  :             }
; 560  :             if ((result = CheckBlockLight(nz->BLOCK, nz_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nz_light_check_code$8[rbp]
	mov	rax, QWORD PTR nz$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN17@PMC_Add_X_

; 561  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Add_X_
$LN17@PMC_Add_X_:

; 562  :             CommitNumber(nz);

	mov	rcx, QWORD PTR nz$[rbp]
	call	CommitNumber
$LN13@PMC_Add_X_:
$LN8@PMC_Add_X_:

; 563  :         }
; 564  :     }
; 565  :     *o = nz;

	mov	rax, QWORD PTR o$[rbp]
	mov	rcx, QWORD PTR nz$[rbp]
	mov	QWORD PTR [rax], rcx

; 566  : #ifdef _DEBUG
; 567  :     if ((result = CheckNumber(*o)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR o$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN18@PMC_Add_X_

; 568  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Add_X_
$LN18@PMC_Add_X_:

; 569  : #endif
; 570  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Add_X_:

; 571  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:PMC_Add_X_X$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+456]
	pop	rdi
	pop	rbp
	ret	0
PMC_Add_X_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_add.c
;	COMDAT PMC_Add_X_L
_TEXT	SEGMENT
nx$ = 8
result$ = 36
nz$ = 72
x_bit_count$8 = 104
y_hi$9 = 132
y_lo$10 = 164
y_bit_count$11 = 200
z_bit_count$12 = 232
nz_light_check_code$13 = 264
y_bit_count$14 = 296
z_bit_count$15 = 328
nz_light_check_code$16 = 360
x_bit_count$17 = 392
y_bit_count$18 = 424
z_bit_count$19 = 456
nz_light_check_code$20 = 488
x$ = 736
y$ = 744
o$ = 752
PMC_Add_X_L PROC					; COMDAT

; 390  : {

$LN29:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 744				; 000002e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 186				; 000000baH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+776]
	lea	rcx, OFFSET FLAT:__A78DCA81_pmc_add@c
	call	__CheckForDebuggerJustMyCode

; 391  :     if (__UNIT_TYPE_BIT_COUNT * 2 < sizeof(y) * 8)

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_Add_X_

; 392  :     {
; 393  :         // _UINT64_T が 2 ワードで表現しきれない処理系には対応しない
; 394  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_Add_X_
$LN2@PMC_Add_X_:

; 395  :     }
; 396  :     if (x == NULL)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN3@PMC_Add_X_

; 397  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Add_X_
$LN3@PMC_Add_X_:

; 398  :     if (o == NULL)

	cmp	QWORD PTR o$[rbp], 0
	jne	SHORT $LN4@PMC_Add_X_

; 399  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Add_X_
$LN4@PMC_Add_X_:

; 400  :     NUMBER_HEADER* nx = (NUMBER_HEADER*)x;

	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR nx$[rbp], rax

; 401  :     PMC_STATUS_CODE result;
; 402  :     if ((result = CheckNumber(nx)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nx$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Add_X_

; 403  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN5@PMC_Add_X_:

; 404  :     NUMBER_HEADER* nz;
; 405  :     if (nx->IS_ZERO)

	mov	rax, QWORD PTR nx$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@PMC_Add_X_

; 406  :     {
; 407  :         // x が 0 である場合
; 408  : 
; 409  :         if (y == 0)

	cmp	QWORD PTR y$[rbp], 0
	jne	SHORT $LN8@PMC_Add_X_

; 410  :         {
; 411  :             // y が 0 である場合
; 412  : 
; 413  :             // x と y がともに 0 であるので、加算結果の 0 を呼び出し元に返す。
; 414  :             *o = &number_zero;

	mov	rax, QWORD PTR o$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 415  :         }

	jmp	SHORT $LN9@PMC_Add_X_
$LN8@PMC_Add_X_:

; 416  :         else
; 417  :         {
; 418  :             // y が 0 ではない場合
; 419  : 
; 420  :             // 加算結果となる y の値を持つ NUMBER_HEADER 構造体を獲得し、呼び出し元へ返す。
; 421  :             if ((result = From_L_Imp(y, &nz)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nz$[rbp]
	mov	rcx, QWORD PTR y$[rbp]
	call	From_L_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN10@PMC_Add_X_

; 422  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN10@PMC_Add_X_:

; 423  :             *o = nz;

	mov	rax, QWORD PTR o$[rbp]
	mov	rcx, QWORD PTR nz$[rbp]
	mov	QWORD PTR [rax], rcx
$LN9@PMC_Add_X_:

; 424  :         }
; 425  :     }

	jmp	$LN7@PMC_Add_X_
$LN6@PMC_Add_X_:

; 426  :     else
; 427  :     {
; 428  :         // x が 0 ではない場合
; 429  : 
; 430  :         if (y == 0)

	cmp	QWORD PTR y$[rbp], 0
	jne	SHORT $LN11@PMC_Add_X_

; 431  :         {
; 432  :             // y が 0 である場合
; 433  : 
; 434  :             // 加算結果となる x の値を持つ NUMBER_HEADER 構造体を獲得し、呼び出し元へ返す。
; 435  :             if ((result = DuplicateNumber(nx, &nz)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nz$[rbp]
	mov	rcx, QWORD PTR nx$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN13@PMC_Add_X_

; 436  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN13@PMC_Add_X_:

; 437  :         }

	jmp	$LN12@PMC_Add_X_
$LN11@PMC_Add_X_:

; 438  :         else
; 439  :         {
; 440  :             // x と y がともに 0 ではない場合
; 441  : 
; 442  :             // x と y の和を計算する
; 443  :             if (__UNIT_TYPE_BIT_COUNT < sizeof(y) * 8)

	xor	eax, eax
	test	eax, eax
	je	$LN14@PMC_Add_X_

; 444  :             {
; 445  :                 // _UINT64_T が 1 ワードで表現しきれない場合
; 446  : 
; 447  :                 __UNIT_TYPE x_bit_count = nx->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nx$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR x_bit_count$8[rbp], rax

; 448  :                 _UINT32_T y_hi;
; 449  :                 _UINT32_T y_lo = _FROMDWORDTOWORD(y, &y_hi);

	lea	rdx, QWORD PTR y_hi$9[rbp]
	mov	rcx, QWORD PTR y$[rbp]
	call	_FROMDWORDTOWORD
	mov	DWORD PTR y_lo$10[rbp], eax

; 450  :                 if (y_hi == 0)

	cmp	DWORD PTR y_hi$9[rbp], 0
	jne	$LN16@PMC_Add_X_

; 451  :                 {
; 452  :                     // y の値が 32bit で表現可能な場合
; 453  :                     __UNIT_TYPE y_bit_count = sizeof(y_lo) * 8 - _LZCNT_ALT_32(y_lo);

	mov	ecx, DWORD PTR y_lo$10[rbp]
	call	_LZCNT_ALT_32
	mov	eax, eax
	mov	ecx, 32					; 00000020H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR y_bit_count$11[rbp], rax

; 454  :                     __UNIT_TYPE z_bit_count = _MAXIMUM_UNIT(x_bit_count, y_bit_count) + 1;

	mov	rdx, QWORD PTR y_bit_count$11[rbp]
	mov	rcx, QWORD PTR x_bit_count$8[rbp]
	call	_MAXIMUM_UNIT
	inc	rax
	mov	QWORD PTR z_bit_count$12[rbp], rax

; 455  :                     __UNIT_TYPE nz_light_check_code;
; 456  :                     if ((result = AllocateNumber(&nz, z_bit_count, &nz_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nz_light_check_code$13[rbp]
	mov	rdx, QWORD PTR z_bit_count$12[rbp]
	lea	rcx, QWORD PTR nz$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN18@PMC_Add_X_

; 457  :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN18@PMC_Add_X_:

; 458  :                     if ((result = Add_X_1W(nx, y_lo, nz)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR y_lo$10[rbp]
	mov	r8, QWORD PTR nz$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR nx$[rbp]
	call	Add_X_1W
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN19@PMC_Add_X_

; 459  :                     {
; 460  :                         DeallocateNumber(nz);

	mov	rcx, QWORD PTR nz$[rbp]
	call	DeallocateNumber

; 461  :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN19@PMC_Add_X_:

; 462  :                     }
; 463  :                     if ((result = CheckBlockLight(nz->BLOCK, nz_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nz_light_check_code$13[rbp]
	mov	rax, QWORD PTR nz$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN20@PMC_Add_X_

; 464  :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN20@PMC_Add_X_:

; 465  :                 }

	jmp	$LN17@PMC_Add_X_
$LN16@PMC_Add_X_:

; 466  :                 else
; 467  :                 {
; 468  :                     // y の値が 32bit では表現できない場合
; 469  :                     __UNIT_TYPE y_bit_count = sizeof(y) * 8 - _LZCNT_ALT_32(y_hi);

	mov	ecx, DWORD PTR y_hi$9[rbp]
	call	_LZCNT_ALT_32
	mov	eax, eax
	mov	ecx, 64					; 00000040H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR y_bit_count$14[rbp], rax

; 470  :                     __UNIT_TYPE z_bit_count = _MAXIMUM_UNIT(x_bit_count, y_bit_count) + 1;

	mov	rdx, QWORD PTR y_bit_count$14[rbp]
	mov	rcx, QWORD PTR x_bit_count$8[rbp]
	call	_MAXIMUM_UNIT
	inc	rax
	mov	QWORD PTR z_bit_count$15[rbp], rax

; 471  :                     __UNIT_TYPE nz_light_check_code;
; 472  :                     if ((result = AllocateNumber(&nz, z_bit_count, &nz_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nz_light_check_code$16[rbp]
	mov	rdx, QWORD PTR z_bit_count$15[rbp]
	lea	rcx, QWORD PTR nz$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN21@PMC_Add_X_

; 473  :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN21@PMC_Add_X_:

; 474  :                     if ((result = Add_X_2W(nx, y_hi, y_lo, nz)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR y_lo$10[rbp]
	mov	ecx, DWORD PTR y_hi$9[rbp]
	mov	r9, QWORD PTR nz$[rbp]
	mov	r8d, eax
	mov	edx, ecx
	mov	rcx, QWORD PTR nx$[rbp]
	call	Add_X_2W
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN22@PMC_Add_X_

; 475  :                     {
; 476  :                         DeallocateNumber(nz);

	mov	rcx, QWORD PTR nz$[rbp]
	call	DeallocateNumber

; 477  :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN22@PMC_Add_X_:

; 478  :                     }
; 479  :                     if ((result = CheckBlockLight(nz->BLOCK, nz_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nz_light_check_code$16[rbp]
	mov	rax, QWORD PTR nz$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN23@PMC_Add_X_

; 480  :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN23@PMC_Add_X_:
$LN17@PMC_Add_X_:

; 481  :                 }
; 482  :                 CommitNumber(nz);

	mov	rcx, QWORD PTR nz$[rbp]
	call	CommitNumber

; 483  :             }

	jmp	$LN15@PMC_Add_X_
$LN14@PMC_Add_X_:

; 484  :             else
; 485  :             {
; 486  :                 // _UINT64_T が 1 ワードで表現できる場合
; 487  : 
; 488  :                 __UNIT_TYPE x_bit_count = nx->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nx$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR x_bit_count$17[rbp], rax

; 489  :                 __UNIT_TYPE y_bit_count = sizeof(y) * 8 - _LZCNT_ALT_UNIT((__UNIT_TYPE)y);

	mov	rcx, QWORD PTR y$[rbp]
	call	_LZCNT_ALT_UNIT
	mov	ecx, 64					; 00000040H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR y_bit_count$18[rbp], rax

; 490  :                 __UNIT_TYPE z_bit_count = _MAXIMUM_UNIT(x_bit_count, y_bit_count) + 1;

	mov	rdx, QWORD PTR y_bit_count$18[rbp]
	mov	rcx, QWORD PTR x_bit_count$17[rbp]
	call	_MAXIMUM_UNIT
	inc	rax
	mov	QWORD PTR z_bit_count$19[rbp], rax

; 491  :                 __UNIT_TYPE nz_light_check_code;
; 492  :                 if ((result = AllocateNumber(&nz, z_bit_count, &nz_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nz_light_check_code$20[rbp]
	mov	rdx, QWORD PTR z_bit_count$19[rbp]
	lea	rcx, QWORD PTR nz$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN24@PMC_Add_X_

; 493  :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN24@PMC_Add_X_:

; 494  :                 if ((result = Add_X_1W(nx, (__UNIT_TYPE)y, nz)) != PMC_STATUS_OK)

	mov	r8, QWORD PTR nz$[rbp]
	mov	rdx, QWORD PTR y$[rbp]
	mov	rcx, QWORD PTR nx$[rbp]
	call	Add_X_1W
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN25@PMC_Add_X_

; 495  :                 {
; 496  :                     DeallocateNumber(nz);

	mov	rcx, QWORD PTR nz$[rbp]
	call	DeallocateNumber

; 497  :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Add_X_
$LN25@PMC_Add_X_:

; 498  :                 }
; 499  :                 if ((result = CheckBlockLight(nz->BLOCK, nz_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nz_light_check_code$20[rbp]
	mov	rax, QWORD PTR nz$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN26@PMC_Add_X_

; 500  :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Add_X_
$LN26@PMC_Add_X_:

; 501  :                 CommitNumber(nz);

	mov	rcx, QWORD PTR nz$[rbp]
	call	CommitNumber
$LN15@PMC_Add_X_:
$LN12@PMC_Add_X_:

; 502  :             }
; 503  : 
; 504  :         }
; 505  :         *o = nz;

	mov	rax, QWORD PTR o$[rbp]
	mov	rcx, QWORD PTR nz$[rbp]
	mov	QWORD PTR [rax], rcx
$LN7@PMC_Add_X_:

; 506  :     }
; 507  : #ifdef _DEBUG
; 508  :     if ((result = CheckNumber(*o)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR o$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN27@PMC_Add_X_

; 509  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Add_X_
$LN27@PMC_Add_X_:

; 510  : #endif
; 511  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Add_X_:

; 512  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:PMC_Add_X_L$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+712]
	pop	rdi
	pop	rbp
	ret	0
PMC_Add_X_L ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_add.c
;	COMDAT PMC_Add_X_I
_TEXT	SEGMENT
nx$ = 8
result$ = 36
nz$ = 72
x_bit_count$5 = 104
y_bit_count$6 = 136
z_bit_count$7 = 168
nz_check_code$8 = 200
x$ = 448
y$ = 456
o$ = 464
PMC_Add_X_I PROC					; COMDAT

; 312  : {

$LN19:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 456				; 000001c8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 114				; 00000072H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+488]
	lea	rcx, OFFSET FLAT:__A78DCA81_pmc_add@c
	call	__CheckForDebuggerJustMyCode

; 313  :     if (__UNIT_TYPE_BIT_COUNT < sizeof(y) * 8)

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_Add_X_

; 314  :     {
; 315  :         // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
; 316  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_Add_X_
$LN2@PMC_Add_X_:

; 317  :     }
; 318  :     if (x == NULL)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN3@PMC_Add_X_

; 319  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Add_X_
$LN3@PMC_Add_X_:

; 320  :     if (o == NULL)

	cmp	QWORD PTR o$[rbp], 0
	jne	SHORT $LN4@PMC_Add_X_

; 321  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Add_X_
$LN4@PMC_Add_X_:

; 322  :     NUMBER_HEADER* nx = (NUMBER_HEADER*)x;

	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR nx$[rbp], rax

; 323  :     PMC_STATUS_CODE result;
; 324  :     if ((result = CheckNumber(nx)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nx$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Add_X_

; 325  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN5@PMC_Add_X_:

; 326  :     NUMBER_HEADER* nz;
; 327  :     if (nx->IS_ZERO)

	mov	rax, QWORD PTR nx$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@PMC_Add_X_

; 328  :     {
; 329  :         // x が 0 である場合
; 330  : 
; 331  :         if (y == 0)

	cmp	DWORD PTR y$[rbp], 0
	jne	SHORT $LN8@PMC_Add_X_

; 332  :         {
; 333  :             // y が 0 である場合
; 334  : 
; 335  :             // x と y がともに 0 であるので、加算結果の 0 を呼び出し元に返す。
; 336  :             *o = &number_zero;

	mov	rax, QWORD PTR o$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 337  :         }

	jmp	SHORT $LN9@PMC_Add_X_
$LN8@PMC_Add_X_:

; 338  :         else
; 339  :         {
; 340  :             // y が 0 ではない場合
; 341  : 
; 342  :             // 加算結果となる y の値を持つ NUMBER_HEADER 構造体を獲得し、呼び出し元へ返す。
; 343  :             if ((result = From_I_Imp(y, &nz)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nz$[rbp]
	mov	ecx, DWORD PTR y$[rbp]
	call	From_I_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN10@PMC_Add_X_

; 344  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN10@PMC_Add_X_:

; 345  :             *o = nz;

	mov	rax, QWORD PTR o$[rbp]
	mov	rcx, QWORD PTR nz$[rbp]
	mov	QWORD PTR [rax], rcx
$LN9@PMC_Add_X_:

; 346  :         }
; 347  :     }

	jmp	$LN7@PMC_Add_X_
$LN6@PMC_Add_X_:

; 348  :     else
; 349  :     {
; 350  :         // x が 0 ではない場合
; 351  : 
; 352  :         if (y == 0)

	cmp	DWORD PTR y$[rbp], 0
	jne	SHORT $LN11@PMC_Add_X_

; 353  :         {
; 354  :             // y が 0 である場合
; 355  : 
; 356  :             // 加算結果となる x の値を持つ NUMBER_HEADER 構造体を獲得し、呼び出し元へ返す。
; 357  :             if ((result = DuplicateNumber(nx, &nz)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nz$[rbp]
	mov	rcx, QWORD PTR nx$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN13@PMC_Add_X_

; 358  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN13@PMC_Add_X_:

; 359  :         }

	jmp	$LN12@PMC_Add_X_
$LN11@PMC_Add_X_:

; 360  :         else
; 361  :         {
; 362  :             // x と y がともに 0 ではない場合
; 363  : 
; 364  :             // x と y の和を計算する
; 365  :             __UNIT_TYPE x_bit_count = nx->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nx$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR x_bit_count$5[rbp], rax

; 366  :             __UNIT_TYPE y_bit_count = sizeof(y) * 8 - _LZCNT_ALT_32(y);

	mov	ecx, DWORD PTR y$[rbp]
	call	_LZCNT_ALT_32
	mov	eax, eax
	mov	ecx, 32					; 00000020H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR y_bit_count$6[rbp], rax

; 367  :             __UNIT_TYPE z_bit_count = _MAXIMUM_UNIT(x_bit_count, y_bit_count) + 1;

	mov	rdx, QWORD PTR y_bit_count$6[rbp]
	mov	rcx, QWORD PTR x_bit_count$5[rbp]
	call	_MAXIMUM_UNIT
	inc	rax
	mov	QWORD PTR z_bit_count$7[rbp], rax

; 368  :             __UNIT_TYPE nz_check_code;
; 369  :             if ((result = AllocateNumber(&nz, z_bit_count, &nz_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nz_check_code$8[rbp]
	mov	rdx, QWORD PTR z_bit_count$7[rbp]
	lea	rcx, QWORD PTR nz$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN14@PMC_Add_X_

; 370  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Add_X_
$LN14@PMC_Add_X_:

; 371  :             if ((result = Add_X_1W(nx, y, nz)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR y$[rbp]
	mov	r8, QWORD PTR nz$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR nx$[rbp]
	call	Add_X_1W
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN15@PMC_Add_X_

; 372  :             {
; 373  :                 DeallocateNumber(nz);

	mov	rcx, QWORD PTR nz$[rbp]
	call	DeallocateNumber

; 374  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Add_X_
$LN15@PMC_Add_X_:

; 375  :             }
; 376  :             if ((result = CheckBlockLight(nz->BLOCK, nz_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nz_check_code$8[rbp]
	mov	rax, QWORD PTR nz$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN16@PMC_Add_X_

; 377  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Add_X_
$LN16@PMC_Add_X_:

; 378  :             CommitNumber(nz);

	mov	rcx, QWORD PTR nz$[rbp]
	call	CommitNumber
$LN12@PMC_Add_X_:

; 379  :         }
; 380  :         *o = nz;

	mov	rax, QWORD PTR o$[rbp]
	mov	rcx, QWORD PTR nz$[rbp]
	mov	QWORD PTR [rax], rcx
$LN7@PMC_Add_X_:

; 381  :     }
; 382  : #ifdef _DEBUG
; 383  :     if ((result = CheckNumber(*o)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR o$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN17@PMC_Add_X_

; 384  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Add_X_
$LN17@PMC_Add_X_:

; 385  : #endif
; 386  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Add_X_:

; 387  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:PMC_Add_X_I$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+424]
	pop	rdi
	pop	rbp
	ret	0
PMC_Add_X_I ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_add.c
;	COMDAT Initialize_Add
_TEXT	SEGMENT
tv68 = 192
feature$ = 240
Initialize_Add PROC					; COMDAT

; 574  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__A78DCA81_pmc_add@c
	call	__CheckForDebuggerJustMyCode

; 575  :     fp_Add_X_X_using_ADC = feature->PROCESSOR_FEATURE_ADX ? Add_X_X_using_ADCX : Add_X_X_using_ADC;

	mov	rax, QWORD PTR feature$[rbp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@Initialize
	lea	rax, OFFSET FLAT:Add_X_X_using_ADCX
	mov	QWORD PTR tv68[rbp], rax
	jmp	SHORT $LN4@Initialize
$LN3@Initialize:
	lea	rax, OFFSET FLAT:Add_X_X_using_ADC
	mov	QWORD PTR tv68[rbp], rax
$LN4@Initialize:
	mov	rax, QWORD PTR tv68[rbp]
	mov	QWORD PTR fp_Add_X_X_using_ADC, rax

; 576  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 577  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
Initialize_Add ENDP
_TEXT	ENDS
END
