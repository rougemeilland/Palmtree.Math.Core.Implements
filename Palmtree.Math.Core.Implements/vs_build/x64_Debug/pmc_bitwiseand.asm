; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__4522B509_pmc_internal@h DB 01H
__B93DAC51_pmc_bitwiseand@c DB 01H
msvcjmc	ENDS
PUBLIC	Initialize_BitwiseAnd
PUBLIC	PMC_BitwiseAnd_I_X
PUBLIC	PMC_BitwiseAnd_L_X
PUBLIC	PMC_BitwiseAnd_X_I
PUBLIC	PMC_BitwiseAnd_X_L
PUBLIC	PMC_BitwiseAnd_X_X
PUBLIC	__JustMyCode_Default
EXTRN	CheckBlockLight:PROC
EXTRN	AllocateNumber:PROC
EXTRN	DeallocateNumber:PROC
EXTRN	CommitNumber:PROC
EXTRN	CheckNumber:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	number_zero:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$Initialize_BitwiseAnd DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$Initialize_BitwiseAnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_BitwiseAnd_I_X DD imagerel $LN11
	DD	imagerel $LN11+258
	DD	imagerel $unwind$PMC_BitwiseAnd_I_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_BitwiseAnd_L_X DD imagerel $LN15
	DD	imagerel $LN15+456
	DD	imagerel $unwind$PMC_BitwiseAnd_L_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_BitwiseAnd_X_I DD imagerel $LN11
	DD	imagerel $LN11+259
	DD	imagerel $unwind$PMC_BitwiseAnd_X_I
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_BitwiseAnd_X_L DD imagerel $LN15
	DD	imagerel $LN15+456
	DD	imagerel $unwind$PMC_BitwiseAnd_X_L
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_BitwiseAnd_X_X DD imagerel $LN16
	DD	imagerel $LN16+586
	DD	imagerel $unwind$PMC_BitwiseAnd_X_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FROMWORDTODWORD DD imagerel _FROMWORDTODWORD
	DD	imagerel _FROMWORDTODWORD+85
	DD	imagerel $unwind$_FROMWORDTODWORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FROMDWORDTOWORD DD imagerel _FROMDWORDTOWORD
	DD	imagerel _FROMDWORDTOWORD+95
	DD	imagerel $unwind$_FROMDWORDTOWORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_DIVIDE_CEILING_UNIT DD imagerel _DIVIDE_CEILING_UNIT
	DD	imagerel _DIVIDE_CEILING_UNIT+97
	DD	imagerel $unwind$_DIVIDE_CEILING_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MINIMUM_UNIT DD imagerel _MINIMUM_UNIT
	DD	imagerel _MINIMUM_UNIT+122
	DD	imagerel $unwind$_MINIMUM_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$BitwiseAnd_X_X DD imagerel BitwiseAnd_X_X
	DD	imagerel BitwiseAnd_X_X+4522
	DD	imagerel $unwind$BitwiseAnd_X_X
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BitwiseAnd_X_X DD 025053901H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MINIMUM_UNIT DD 025052f01H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_DIVIDE_CEILING_UNIT DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FROMDWORDTOWORD DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FROMWORDTODWORD DD 025052c01H
	DD	01112316H
	DD	0700a001dH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_BitwiseAnd_X_X DD 025053401H
	DD	0118231dH
	DD	070110041H
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_BitwiseAnd_X_X$rtcName$0 DB 06eH
	DB	077H
	DB	00H
	ORG $+5
PMC_BitwiseAnd_X_X$rtcName$1 DB 06eH
	DB	077H
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_BitwiseAnd_X_X$rtcVarDesc DD 0108H
	DD	08H
	DQ	FLAT:PMC_BitwiseAnd_X_X$rtcName$1
	DD	088H
	DD	08H
	DQ	FLAT:PMC_BitwiseAnd_X_X$rtcName$0
	ORG $+96
PMC_BitwiseAnd_X_X$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:PMC_BitwiseAnd_X_X$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_BitwiseAnd_X_L DD 025053401H
	DD	0118231dH
	DD	070110035H
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_BitwiseAnd_X_L$rtcName$0 DB 076H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+11
PMC_BitwiseAnd_X_L$rtcVarDesc DD 064H
	DD	04H
	DQ	FLAT:PMC_BitwiseAnd_X_L$rtcName$0
	ORG $+48
PMC_BitwiseAnd_X_L$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:PMC_BitwiseAnd_X_L$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_BitwiseAnd_X_I DD 025053301H
	DD	0117231cH
	DD	070100025H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_BitwiseAnd_L_X DD 025053401H
	DD	0118231dH
	DD	070110035H
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_BitwiseAnd_L_X$rtcName$0 DB 075H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+11
PMC_BitwiseAnd_L_X$rtcVarDesc DD 064H
	DD	04H
	DQ	FLAT:PMC_BitwiseAnd_L_X$rtcName$0
	ORG $+48
PMC_BitwiseAnd_L_X$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:PMC_BitwiseAnd_L_X$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_BitwiseAnd_I_X DD 025053201H
	DD	0117231cH
	DD	070100025H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Initialize_BitwiseAnd DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_bitwiseand.c
;	COMDAT BitwiseAnd_X_X
_TEXT	SEGMENT
count$ = 8
u$ = 256
v$ = 264
w$ = 272
w_count$ = 280
BitwiseAnd_X_X PROC					; COMDAT

; 38   : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__B93DAC51_pmc_bitwiseand@c
	call	__CheckForDebuggerJustMyCode

; 39   :     __UNIT_TYPE count = w_count >> 5;

	mov	rax, QWORD PTR w_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@BitwiseAnd:

; 40   :     while (count != 0)

	cmp	QWORD PTR count$[rbp], 0
	je	$LN3@BitwiseAnd

; 41   :     {
; 42   :         w[0] = u[0] & v[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 43   :         w[1] = u[1] & v[1];

	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 44   :         w[2] = u[2] & v[2];

	mov	eax, 8
	imul	rax, rax, 2
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 45   :         w[3] = u[3] & v[3];

	mov	eax, 8
	imul	rax, rax, 3
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 46   :         w[4] = u[4] & v[4];

	mov	eax, 8
	imul	rax, rax, 4
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 47   :         w[5] = u[5] & v[5];

	mov	eax, 8
	imul	rax, rax, 5
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 48   :         w[6] = u[6] & v[6];

	mov	eax, 8
	imul	rax, rax, 6
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 49   :         w[7] = u[7] & v[7];

	mov	eax, 8
	imul	rax, rax, 7
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 50   :         w[8] = u[8] & v[8];

	mov	eax, 8
	imul	rax, rax, 8
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 51   :         w[9] = u[9] & v[9];

	mov	eax, 8
	imul	rax, rax, 9
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 52   :         w[10] = u[10] & v[10];

	mov	eax, 8
	imul	rax, rax, 10
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 53   :         w[11] = u[11] & v[11];

	mov	eax, 8
	imul	rax, rax, 11
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 54   :         w[12] = u[12] & v[12];

	mov	eax, 8
	imul	rax, rax, 12
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 55   :         w[13] = u[13] & v[13];

	mov	eax, 8
	imul	rax, rax, 13
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 56   :         w[14] = u[14] & v[14];

	mov	eax, 8
	imul	rax, rax, 14
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 57   :         w[15] = u[15] & v[15];

	mov	eax, 8
	imul	rax, rax, 15
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 58   :         w[16] = u[16] & v[16];

	mov	eax, 8
	imul	rax, rax, 16
	mov	ecx, 8
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 59   :         w[17] = u[17] & v[17];

	mov	eax, 8
	imul	rax, rax, 17
	mov	ecx, 8
	imul	rcx, rcx, 17
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 17
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 60   :         w[18] = u[18] & v[18];

	mov	eax, 8
	imul	rax, rax, 18
	mov	ecx, 8
	imul	rcx, rcx, 18
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 18
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 61   :         w[19] = u[19] & v[19];

	mov	eax, 8
	imul	rax, rax, 19
	mov	ecx, 8
	imul	rcx, rcx, 19
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 19
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 62   :         w[20] = u[20] & v[20];

	mov	eax, 8
	imul	rax, rax, 20
	mov	ecx, 8
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 63   :         w[21] = u[21] & v[21];

	mov	eax, 8
	imul	rax, rax, 21
	mov	ecx, 8
	imul	rcx, rcx, 21
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 21
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 64   :         w[22] = u[22] & v[22];

	mov	eax, 8
	imul	rax, rax, 22
	mov	ecx, 8
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 65   :         w[23] = u[23] & v[23];

	mov	eax, 8
	imul	rax, rax, 23
	mov	ecx, 8
	imul	rcx, rcx, 23
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 23
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 66   :         w[24] = u[24] & v[24];

	mov	eax, 8
	imul	rax, rax, 24
	mov	ecx, 8
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 67   :         w[25] = u[25] & v[25];

	mov	eax, 8
	imul	rax, rax, 25
	mov	ecx, 8
	imul	rcx, rcx, 25
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 25
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 68   :         w[26] = u[26] & v[26];

	mov	eax, 8
	imul	rax, rax, 26
	mov	ecx, 8
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 69   :         w[27] = u[27] & v[27];

	mov	eax, 8
	imul	rax, rax, 27
	mov	ecx, 8
	imul	rcx, rcx, 27
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 27
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 70   :         w[28] = u[28] & v[28];

	mov	eax, 8
	imul	rax, rax, 28
	mov	ecx, 8
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 71   :         w[29] = u[29] & v[29];

	mov	eax, 8
	imul	rax, rax, 29
	mov	ecx, 8
	imul	rcx, rcx, 29
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 29
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 72   :         w[30] = u[30] & v[30];

	mov	eax, 8
	imul	rax, rax, 30
	mov	ecx, 8
	imul	rcx, rcx, 30
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 30
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 73   :         w[31] = u[31] & v[31];

	mov	eax, 8
	imul	rax, rax, 31
	mov	ecx, 8
	imul	rcx, rcx, 31
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 31
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 74   :         u += 32;

	mov	rax, QWORD PTR u$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR u$[rbp], rax

; 75   :         v += 32;

	mov	rax, QWORD PTR v$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR v$[rbp], rax

; 76   :         w += 32;

	mov	rax, QWORD PTR w$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR w$[rbp], rax

; 77   :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 78   :     }

	jmp	$LN2@BitwiseAnd
$LN3@BitwiseAnd:

; 79   : 
; 80   :     if (w_count & 0x10)

	mov	rax, QWORD PTR w_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	$LN4@BitwiseAnd

; 81   :     {
; 82   :         w[0] = u[0] & v[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 83   :         w[1] = u[1] & v[1];

	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 84   :         w[2] = u[2] & v[2];

	mov	eax, 8
	imul	rax, rax, 2
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 85   :         w[3] = u[3] & v[3];

	mov	eax, 8
	imul	rax, rax, 3
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 86   :         w[4] = u[4] & v[4];

	mov	eax, 8
	imul	rax, rax, 4
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 87   :         w[5] = u[5] & v[5];

	mov	eax, 8
	imul	rax, rax, 5
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 88   :         w[6] = u[6] & v[6];

	mov	eax, 8
	imul	rax, rax, 6
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 89   :         w[7] = u[7] & v[7];

	mov	eax, 8
	imul	rax, rax, 7
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 90   :         w[8] = u[8] & v[8];

	mov	eax, 8
	imul	rax, rax, 8
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 91   :         w[9] = u[9] & v[9];

	mov	eax, 8
	imul	rax, rax, 9
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 92   :         w[10] = u[10] & v[10];

	mov	eax, 8
	imul	rax, rax, 10
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 93   :         w[11] = u[11] & v[11];

	mov	eax, 8
	imul	rax, rax, 11
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 94   :         w[12] = u[12] & v[12];

	mov	eax, 8
	imul	rax, rax, 12
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 95   :         w[13] = u[13] & v[13];

	mov	eax, 8
	imul	rax, rax, 13
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 96   :         w[14] = u[14] & v[14];

	mov	eax, 8
	imul	rax, rax, 14
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 97   :         w[15] = u[15] & v[15];

	mov	eax, 8
	imul	rax, rax, 15
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 98   :         u += 16;

	mov	rax, QWORD PTR u$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR u$[rbp], rax

; 99   :         v += 16;

	mov	rax, QWORD PTR v$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR v$[rbp], rax

; 100  :         w += 16;

	mov	rax, QWORD PTR w$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR w$[rbp], rax
$LN4@BitwiseAnd:

; 101  :     }
; 102  : 
; 103  :     if (w_count & 0x8)

	mov	rax, QWORD PTR w_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	$LN5@BitwiseAnd

; 104  :     {
; 105  :         w[0] = u[0] & v[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 106  :         w[1] = u[1] & v[1];

	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 107  :         w[2] = u[2] & v[2];

	mov	eax, 8
	imul	rax, rax, 2
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 108  :         w[3] = u[3] & v[3];

	mov	eax, 8
	imul	rax, rax, 3
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 109  :         w[4] = u[4] & v[4];

	mov	eax, 8
	imul	rax, rax, 4
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 110  :         w[5] = u[5] & v[5];

	mov	eax, 8
	imul	rax, rax, 5
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 111  :         w[6] = u[6] & v[6];

	mov	eax, 8
	imul	rax, rax, 6
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 112  :         w[7] = u[7] & v[7];

	mov	eax, 8
	imul	rax, rax, 7
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 113  :         u += 8;

	mov	rax, QWORD PTR u$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR u$[rbp], rax

; 114  :         v += 8;

	mov	rax, QWORD PTR v$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR v$[rbp], rax

; 115  :         w += 8;

	mov	rax, QWORD PTR w$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR w$[rbp], rax
$LN5@BitwiseAnd:

; 116  :     }
; 117  : 
; 118  :     if (w_count & 0x4)

	mov	rax, QWORD PTR w_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	$LN6@BitwiseAnd

; 119  :     {
; 120  :         w[0] = u[0] & v[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 121  :         w[1] = u[1] & v[1];

	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 122  :         w[2] = u[2] & v[2];

	mov	eax, 8
	imul	rax, rax, 2
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 123  :         w[3] = u[3] & v[3];

	mov	eax, 8
	imul	rax, rax, 3
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 124  :         u += 4;

	mov	rax, QWORD PTR u$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR u$[rbp], rax

; 125  :         v += 4;

	mov	rax, QWORD PTR v$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR v$[rbp], rax

; 126  :         w += 4;

	mov	rax, QWORD PTR w$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR w$[rbp], rax
$LN6@BitwiseAnd:

; 127  :     }
; 128  : 
; 129  :     if (w_count & 0x2)

	mov	rax, QWORD PTR w_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	$LN7@BitwiseAnd

; 130  :     {
; 131  :         w[0] = u[0] & v[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 132  :         w[1] = u[1] & v[1];

	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 133  :         u += 2;

	mov	rax, QWORD PTR u$[rbp]
	add	rax, 16
	mov	QWORD PTR u$[rbp], rax

; 134  :         v += 2;

	mov	rax, QWORD PTR v$[rbp]
	add	rax, 16
	mov	QWORD PTR v$[rbp], rax

; 135  :         w += 2;

	mov	rax, QWORD PTR w$[rbp]
	add	rax, 16
	mov	QWORD PTR w$[rbp], rax
$LN7@BitwiseAnd:

; 136  :     }
; 137  : 
; 138  :     if (w_count & 0x1)

	mov	rax, QWORD PTR w_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN8@BitwiseAnd

; 139  :     {
; 140  :         w[0] = u[0] & v[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [r8+rcx]
	mov	rax, QWORD PTR [rdx+rax]
	and	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 141  :         u += 1;

	mov	rax, QWORD PTR u$[rbp]
	add	rax, 8
	mov	QWORD PTR u$[rbp], rax

; 142  :         v += 1;

	mov	rax, QWORD PTR v$[rbp]
	add	rax, 8
	mov	QWORD PTR v$[rbp], rax

; 143  :         w += 1;

	mov	rax, QWORD PTR w$[rbp]
	add	rax, 8
	mov	QWORD PTR w$[rbp], rax
$LN8@BitwiseAnd:

; 144  :     }
; 145  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
BitwiseAnd_X_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _MINIMUM_UNIT
_TEXT	SEGMENT
tv65 = 192
x$ = 240
y$ = 248
_MINIMUM_UNIT PROC					; COMDAT

; 467  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 468  :     return (x <= y ? x : y);

	mov	rax, QWORD PTR y$[rbp]
	cmp	QWORD PTR x$[rbp], rax
	ja	SHORT $LN3@MINIMUM_UN
	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR tv65[rbp], rax
	jmp	SHORT $LN4@MINIMUM_UN
$LN3@MINIMUM_UN:
	mov	rax, QWORD PTR y$[rbp]
	mov	QWORD PTR tv65[rbp], rax
$LN4@MINIMUM_UN:
	mov	rax, QWORD PTR tv65[rbp]

; 469  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
_MINIMUM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _DIVIDE_CEILING_UNIT
_TEXT	SEGMENT
u$ = 224
v$ = 232
_DIVIDE_CEILING_UNIT PROC				; COMDAT

; 452  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 453  :     return ((u + v - 1) / v);

	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	lea	rax, QWORD PTR [rax+rcx-1]
	xor	edx, edx
	div	QWORD PTR v$[rbp]

; 454  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _FROMDWORDTOWORD
_TEXT	SEGMENT
value$ = 224
result_high$ = 232
_FROMDWORDTOWORD PROC					; COMDAT

; 441  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 442  :     *result_high = (_UINT32_T)(value >> 32);

	mov	rax, QWORD PTR value$[rbp]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR result_high$[rbp]
	mov	DWORD PTR [rcx], eax

; 443  :     return ((_UINT32_T)value);

	mov	eax, DWORD PTR value$[rbp]

; 444  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FROMDWORDTOWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _FROMWORDTODWORD
_TEXT	SEGMENT
value_high$ = 224
value_low$ = 232
_FROMWORDTODWORD PROC					; COMDAT

; 436  : {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 437  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	eax, DWORD PTR value_high$[rbp]
	shl	rax, 32					; 00000020H
	mov	ecx, DWORD PTR value_low$[rbp]
	or	rax, rcx

; 438  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FROMWORDTODWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_bitwiseand.c
;	COMDAT PMC_BitwiseAnd_X_X
_TEXT	SEGMENT
nu$ = 8
nv$ = 40
result$ = 68
nw$ = 104
u_bit_count$5 = 136
v_bit_count$6 = 168
w_bit_count$7 = 200
nw_light_check_code$8 = 232
w_word_count$9 = 264
u$ = 512
v$ = 520
w$ = 528
PMC_BitwiseAnd_X_X PROC					; COMDAT

; 316  : {

$LN16:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 520				; 00000208H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 130				; 00000082H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+552]
	lea	rcx, OFFSET FLAT:__B93DAC51_pmc_bitwiseand@c
	call	__CheckForDebuggerJustMyCode

; 317  :     if (u == NULL)

	cmp	QWORD PTR u$[rbp], 0
	jne	SHORT $LN2@PMC_Bitwis

; 318  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Bitwis
$LN2@PMC_Bitwis:

; 319  :     if (v == NULL)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN3@PMC_Bitwis

; 320  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Bitwis
$LN3@PMC_Bitwis:

; 321  :     if (w == NULL)

	cmp	QWORD PTR w$[rbp], 0
	jne	SHORT $LN4@PMC_Bitwis

; 322  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Bitwis
$LN4@PMC_Bitwis:

; 323  :     NUMBER_HEADER* nu = (NUMBER_HEADER*)u;

	mov	rax, QWORD PTR u$[rbp]
	mov	QWORD PTR nu$[rbp], rax

; 324  :     NUMBER_HEADER* nv = (NUMBER_HEADER*)v;

	mov	rax, QWORD PTR v$[rbp]
	mov	QWORD PTR nv$[rbp], rax

; 325  :     PMC_STATUS_CODE result;
; 326  :     if ((result = CheckNumber(nu)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nu$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Bitwis

; 327  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Bitwis
$LN5@PMC_Bitwis:

; 328  :     if ((result = CheckNumber(nv)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nv$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_Bitwis

; 329  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Bitwis
$LN6@PMC_Bitwis:

; 330  :     NUMBER_HEADER* nw;
; 331  :     if (nu->IS_ZERO)

	mov	rax, QWORD PTR nu$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@PMC_Bitwis

; 332  :         *w = &number_zero;

	mov	rax, QWORD PTR w$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx
	jmp	$LN8@PMC_Bitwis
$LN7@PMC_Bitwis:

; 333  :     else if (nv->IS_ZERO)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@PMC_Bitwis

; 334  :         *w = &number_zero;

	mov	rax, QWORD PTR w$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx
	jmp	$LN10@PMC_Bitwis
$LN9@PMC_Bitwis:

; 335  :     else
; 336  :     {
; 337  :         __UNIT_TYPE u_bit_count = nu->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nu$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR u_bit_count$5[rbp], rax

; 338  :         __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nv$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR v_bit_count$6[rbp], rax

; 339  :         __UNIT_TYPE w_bit_count = _MINIMUM_UNIT(u_bit_count, v_bit_count);

	mov	rdx, QWORD PTR v_bit_count$6[rbp]
	mov	rcx, QWORD PTR u_bit_count$5[rbp]
	call	_MINIMUM_UNIT
	mov	QWORD PTR w_bit_count$7[rbp], rax

; 340  :         __UNIT_TYPE nw_light_check_code;
; 341  :         if ((result = AllocateNumber(&nw, w_bit_count, &nw_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nw_light_check_code$8[rbp]
	mov	rdx, QWORD PTR w_bit_count$7[rbp]
	lea	rcx, QWORD PTR nw$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN11@PMC_Bitwis

; 342  :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Bitwis
$LN11@PMC_Bitwis:

; 343  :         __UNIT_TYPE w_word_count = _DIVIDE_CEILING_UNIT(w_bit_count, __UNIT_TYPE_BIT_COUNT);

	mov	edx, 64					; 00000040H
	mov	rcx, QWORD PTR w_bit_count$7[rbp]
	call	_DIVIDE_CEILING_UNIT
	mov	QWORD PTR w_word_count$9[rbp], rax

; 344  :         BitwiseAnd_X_X(nu->BLOCK, nv->BLOCK, nw->BLOCK, w_word_count);

	mov	r9, QWORD PTR w_word_count$9[rbp]
	mov	rax, QWORD PTR nw$[rbp]
	mov	r8, QWORD PTR [rax+48]
	mov	rax, QWORD PTR nv$[rbp]
	mov	rdx, QWORD PTR [rax+48]
	mov	rax, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	BitwiseAnd_X_X

; 345  :         if ((result = CheckBlockLight(nw->BLOCK, nw_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nw_light_check_code$8[rbp]
	mov	rax, QWORD PTR nw$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN12@PMC_Bitwis

; 346  :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Bitwis
$LN12@PMC_Bitwis:

; 347  :         CommitNumber(nw);

	mov	rcx, QWORD PTR nw$[rbp]
	call	CommitNumber

; 348  :         if (nw->IS_ZERO)

	mov	rax, QWORD PTR nw$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN13@PMC_Bitwis

; 349  :         {
; 350  :             DeallocateNumber(nw);

	mov	rcx, QWORD PTR nw$[rbp]
	call	DeallocateNumber

; 351  :             nw = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nw$[rbp], rax
$LN13@PMC_Bitwis:

; 352  :         }
; 353  :         *w = nw;

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR nw$[rbp]
	mov	QWORD PTR [rax], rcx
$LN10@PMC_Bitwis:
$LN8@PMC_Bitwis:

; 354  :     }
; 355  : #ifdef _DEBUG
; 356  :     if ((result = CheckNumber(*w)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN14@PMC_Bitwis

; 357  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Bitwis
$LN14@PMC_Bitwis:

; 358  : #endif
; 359  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Bitwis:

; 360  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:PMC_BitwiseAnd_X_X$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+488]
	pop	rdi
	pop	rbp
	ret	0
PMC_BitwiseAnd_X_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_bitwiseand.c
;	COMDAT PMC_BitwiseAnd_X_L
_TEXT	SEGMENT
nu$ = 8
result$ = 36
v_hi$4 = 68
v_lo$5 = 100
w_hi$6 = 132
w_lo$7 = 164
tv86 = 376
u$ = 416
v$ = 424
w$ = 432
PMC_BitwiseAnd_X_L PROC					; COMDAT

; 267  : {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 424				; 000001a8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+456]
	lea	rcx, OFFSET FLAT:__B93DAC51_pmc_bitwiseand@c
	call	__CheckForDebuggerJustMyCode

; 268  :     if (__UNIT_TYPE_BIT_COUNT * 2 < sizeof(v) * 8)

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_Bitwis

; 269  :     {
; 270  :         // _UINT64_T が 2 ワードで表現しきれない処理系には対応しない
; 271  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_Bitwis
$LN2@PMC_Bitwis:

; 272  :     }
; 273  :     if (u == NULL)

	cmp	QWORD PTR u$[rbp], 0
	jne	SHORT $LN3@PMC_Bitwis

; 274  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Bitwis
$LN3@PMC_Bitwis:

; 275  :     if (w == NULL)

	cmp	QWORD PTR w$[rbp], 0
	jne	SHORT $LN4@PMC_Bitwis

; 276  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Bitwis
$LN4@PMC_Bitwis:

; 277  :     NUMBER_HEADER* nu = (NUMBER_HEADER*)u;

	mov	rax, QWORD PTR u$[rbp]
	mov	QWORD PTR nu$[rbp], rax

; 278  :     PMC_STATUS_CODE result;
; 279  :     if ((result = CheckNumber(nu)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nu$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Bitwis

; 280  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Bitwis
$LN5@PMC_Bitwis:

; 281  :     if (nu->IS_ZERO)

	mov	rax, QWORD PTR nu$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@PMC_Bitwis

; 282  :     {
; 283  :         // u が 0 である場合
; 284  :         *w = 0;

	mov	rax, QWORD PTR w$[rbp]
	mov	QWORD PTR [rax], 0

; 285  :     }

	jmp	$LN7@PMC_Bitwis
$LN6@PMC_Bitwis:

; 286  :     else if (v == 0)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN8@PMC_Bitwis

; 287  :     {
; 288  :         // v が 0 である場合
; 289  :         *w = 0;

	mov	rax, QWORD PTR w$[rbp]
	mov	QWORD PTR [rax], 0

; 290  :     }

	jmp	$LN9@PMC_Bitwis
$LN8@PMC_Bitwis:

; 291  :     else
; 292  :     {
; 293  :         // u と v がともに 0 ではない場合
; 294  : 
; 295  :         // x と y の和を計算する
; 296  :         if (__UNIT_TYPE_BIT_COUNT < sizeof(v) * 8)

	xor	eax, eax
	test	eax, eax
	je	$LN10@PMC_Bitwis

; 297  :         {
; 298  :             // _UINT64_T が 1 ワードで表現しきれない場合
; 299  : 
; 300  :             _UINT32_T v_hi;
; 301  :             _UINT32_T v_lo = _FROMDWORDTOWORD(v, &v_hi);

	lea	rdx, QWORD PTR v_hi$4[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	call	_FROMDWORDTOWORD
	mov	DWORD PTR v_lo$5[rbp], eax

; 302  :             _UINT32_T w_hi = nu->UNIT_WORD_COUNT > 1 ? nu->BLOCK[1] & v_hi : 0;

	mov	rax, QWORD PTR nu$[rbp]
	cmp	QWORD PTR [rax], 1
	jbe	SHORT $LN13@PMC_Bitwis
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	edx, DWORD PTR v_hi$4[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	and	rax, rdx
	mov	QWORD PTR tv86[rbp], rax
	jmp	SHORT $LN14@PMC_Bitwis
$LN13@PMC_Bitwis:
	mov	QWORD PTR tv86[rbp], 0
$LN14@PMC_Bitwis:
	mov	eax, DWORD PTR tv86[rbp]
	mov	DWORD PTR w_hi$6[rbp], eax

; 303  :             _UINT32_T w_lo = nu->BLOCK[0] & v_lo;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	edx, DWORD PTR v_lo$5[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	and	rax, rdx
	mov	DWORD PTR w_lo$7[rbp], eax

; 304  :             *w = _FROMWORDTODWORD(w_hi, w_lo);

	mov	edx, DWORD PTR w_lo$7[rbp]
	mov	ecx, DWORD PTR w_hi$6[rbp]
	call	_FROMWORDTODWORD
	mov	rcx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rcx], rax

; 305  :         }

	jmp	SHORT $LN11@PMC_Bitwis
$LN10@PMC_Bitwis:

; 306  :         else
; 307  :         {
; 308  :             // _UINT64_T が 1 ワードで表現できる場合
; 309  :             *w = nu->BLOCK[0] & v;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rdx, QWORD PTR v$[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	and	rax, rdx
	mov	rcx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rcx], rax
$LN11@PMC_Bitwis:
$LN9@PMC_Bitwis:
$LN7@PMC_Bitwis:

; 310  :         }
; 311  :     }
; 312  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Bitwis:

; 313  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:PMC_BitwiseAnd_X_L$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+392]
	pop	rdi
	pop	rbp
	ret	0
PMC_BitwiseAnd_X_L ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_bitwiseand.c
;	COMDAT PMC_BitwiseAnd_X_I
_TEXT	SEGMENT
nu$ = 8
result$ = 36
u$ = 288
v$ = 296
w$ = 304
PMC_BitwiseAnd_X_I PROC					; COMDAT

; 183  : {

$LN11:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__B93DAC51_pmc_bitwiseand@c
	call	__CheckForDebuggerJustMyCode

; 184  :     if (__UNIT_TYPE_BIT_COUNT < sizeof(v) * 8)

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_Bitwis

; 185  :     {
; 186  :         // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
; 187  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_Bitwis
$LN2@PMC_Bitwis:

; 188  :     }
; 189  :     if (u == NULL)

	cmp	QWORD PTR u$[rbp], 0
	jne	SHORT $LN3@PMC_Bitwis

; 190  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Bitwis
$LN3@PMC_Bitwis:

; 191  :     if (w == NULL)

	cmp	QWORD PTR w$[rbp], 0
	jne	SHORT $LN4@PMC_Bitwis

; 192  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Bitwis
$LN4@PMC_Bitwis:

; 193  :     NUMBER_HEADER* nu = (NUMBER_HEADER*)u;

	mov	rax, QWORD PTR u$[rbp]
	mov	QWORD PTR nu$[rbp], rax

; 194  :     PMC_STATUS_CODE result;
; 195  :     if ((result = CheckNumber(nu)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nu$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Bitwis

; 196  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Bitwis
$LN5@PMC_Bitwis:

; 197  :     if (nu->IS_ZERO)

	mov	rax, QWORD PTR nu$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@PMC_Bitwis

; 198  :     {
; 199  :         // u が 0 である場合
; 200  :         *w = 0;

	mov	rax, QWORD PTR w$[rbp]
	mov	DWORD PTR [rax], 0

; 201  :     }

	jmp	SHORT $LN7@PMC_Bitwis
$LN6@PMC_Bitwis:

; 202  :     else  if (v == 0)

	cmp	DWORD PTR v$[rbp], 0
	jne	SHORT $LN8@PMC_Bitwis

; 203  :     {
; 204  :         // v が 0 である場合
; 205  :         *w = 0;

	mov	rax, QWORD PTR w$[rbp]
	mov	DWORD PTR [rax], 0

; 206  :     }

	jmp	SHORT $LN9@PMC_Bitwis
$LN8@PMC_Bitwis:

; 207  :     else
; 208  :     {
; 209  :         // u と v がともに 0 ではない場合
; 210  : 
; 211  :         // u と v の bit AND を計算する
; 212  :         *w = nu->BLOCK[0] & v;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	edx, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	and	rax, rdx
	mov	rcx, QWORD PTR w$[rbp]
	mov	DWORD PTR [rcx], eax
$LN9@PMC_Bitwis:
$LN7@PMC_Bitwis:

; 213  :     }
; 214  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Bitwis:

; 215  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
PMC_BitwiseAnd_X_I ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_bitwiseand.c
;	COMDAT PMC_BitwiseAnd_L_X
_TEXT	SEGMENT
nv$ = 8
result$ = 36
u_hi$4 = 68
u_lo$5 = 100
w_hi$6 = 132
w_lo$7 = 164
tv86 = 376
u$ = 416
v$ = 424
w$ = 432
PMC_BitwiseAnd_L_X PROC					; COMDAT

; 218  : {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 424				; 000001a8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+456]
	lea	rcx, OFFSET FLAT:__B93DAC51_pmc_bitwiseand@c
	call	__CheckForDebuggerJustMyCode

; 219  :     if (__UNIT_TYPE_BIT_COUNT * 2 < sizeof(u) * 8)

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_Bitwis

; 220  :     {
; 221  :         // _UINT64_T が 2 ワードで表現しきれない処理系には対応しない
; 222  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_Bitwis
$LN2@PMC_Bitwis:

; 223  :     }
; 224  :     if (v == NULL)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN3@PMC_Bitwis

; 225  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Bitwis
$LN3@PMC_Bitwis:

; 226  :     if (w == NULL)

	cmp	QWORD PTR w$[rbp], 0
	jne	SHORT $LN4@PMC_Bitwis

; 227  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Bitwis
$LN4@PMC_Bitwis:

; 228  :     NUMBER_HEADER* nv = (NUMBER_HEADER*)v;

	mov	rax, QWORD PTR v$[rbp]
	mov	QWORD PTR nv$[rbp], rax

; 229  :     PMC_STATUS_CODE result;
; 230  :     if ((result = CheckNumber(nv)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nv$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Bitwis

; 231  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Bitwis
$LN5@PMC_Bitwis:

; 232  :     if (nv->IS_ZERO)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@PMC_Bitwis

; 233  :     {
; 234  :         // v が 0 である場合
; 235  :         *w = 0;

	mov	rax, QWORD PTR w$[rbp]
	mov	QWORD PTR [rax], 0

; 236  :     }

	jmp	$LN7@PMC_Bitwis
$LN6@PMC_Bitwis:

; 237  :     else if (u == 0)

	cmp	QWORD PTR u$[rbp], 0
	jne	SHORT $LN8@PMC_Bitwis

; 238  :     {
; 239  :         // u が 0 である場合
; 240  :         *w = 0;

	mov	rax, QWORD PTR w$[rbp]
	mov	QWORD PTR [rax], 0

; 241  :     }

	jmp	$LN9@PMC_Bitwis
$LN8@PMC_Bitwis:

; 242  :     else
; 243  :     {
; 244  :         // u と v がともに 0 ではない場合
; 245  : 
; 246  :         // x と y の和を計算する
; 247  :         if (__UNIT_TYPE_BIT_COUNT < sizeof(u) * 8)

	xor	eax, eax
	test	eax, eax
	je	$LN10@PMC_Bitwis

; 248  :         {
; 249  :             // _UINT64_T が 1 ワードで表現しきれない場合
; 250  : 
; 251  :             _UINT32_T u_hi;
; 252  :             _UINT32_T u_lo = _FROMDWORDTOWORD(u, &u_hi);

	lea	rdx, QWORD PTR u_hi$4[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	call	_FROMDWORDTOWORD
	mov	DWORD PTR u_lo$5[rbp], eax

; 253  :             _UINT32_T w_hi = nv->UNIT_WORD_COUNT > 1 ? nv->BLOCK[1] & u_hi : 0;

	mov	rax, QWORD PTR nv$[rbp]
	cmp	QWORD PTR [rax], 1
	jbe	SHORT $LN13@PMC_Bitwis
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR nv$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	edx, DWORD PTR u_hi$4[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	and	rax, rdx
	mov	QWORD PTR tv86[rbp], rax
	jmp	SHORT $LN14@PMC_Bitwis
$LN13@PMC_Bitwis:
	mov	QWORD PTR tv86[rbp], 0
$LN14@PMC_Bitwis:
	mov	eax, DWORD PTR tv86[rbp]
	mov	DWORD PTR w_hi$6[rbp], eax

; 254  :             _UINT32_T w_lo = nv->BLOCK[0] & u_lo;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nv$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	edx, DWORD PTR u_lo$5[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	and	rax, rdx
	mov	DWORD PTR w_lo$7[rbp], eax

; 255  :             *w = _FROMWORDTODWORD(w_hi, w_lo);

	mov	edx, DWORD PTR w_lo$7[rbp]
	mov	ecx, DWORD PTR w_hi$6[rbp]
	call	_FROMWORDTODWORD
	mov	rcx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rcx], rax

; 256  :         }

	jmp	SHORT $LN11@PMC_Bitwis
$LN10@PMC_Bitwis:

; 257  :         else
; 258  :         {
; 259  :             // _UINT64_T が 1 ワードで表現できる場合
; 260  :             *w = nv->BLOCK[0] & u;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nv$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rdx, QWORD PTR u$[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	and	rax, rdx
	mov	rcx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rcx], rax
$LN11@PMC_Bitwis:
$LN9@PMC_Bitwis:
$LN7@PMC_Bitwis:

; 261  :         }
; 262  :     }
; 263  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Bitwis:

; 264  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:PMC_BitwiseAnd_L_X$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+392]
	pop	rdi
	pop	rbp
	ret	0
PMC_BitwiseAnd_L_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_bitwiseand.c
;	COMDAT PMC_BitwiseAnd_I_X
_TEXT	SEGMENT
nv$ = 8
result$ = 36
u$ = 288
v$ = 296
w$ = 304
PMC_BitwiseAnd_I_X PROC					; COMDAT

; 148  : {

$LN11:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__B93DAC51_pmc_bitwiseand@c
	call	__CheckForDebuggerJustMyCode

; 149  :     if (__UNIT_TYPE_BIT_COUNT < sizeof(u) * 8)

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_Bitwis

; 150  :     {
; 151  :         // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
; 152  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_Bitwis
$LN2@PMC_Bitwis:

; 153  :     }
; 154  :     if (v == NULL)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN3@PMC_Bitwis

; 155  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Bitwis
$LN3@PMC_Bitwis:

; 156  :     if (w == NULL)

	cmp	QWORD PTR w$[rbp], 0
	jne	SHORT $LN4@PMC_Bitwis

; 157  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Bitwis
$LN4@PMC_Bitwis:

; 158  :     NUMBER_HEADER* nv = (NUMBER_HEADER*)v;

	mov	rax, QWORD PTR v$[rbp]
	mov	QWORD PTR nv$[rbp], rax

; 159  :     PMC_STATUS_CODE result;
; 160  :     if ((result = CheckNumber(nv)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nv$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Bitwis

; 161  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Bitwis
$LN5@PMC_Bitwis:

; 162  :     if (nv->IS_ZERO)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@PMC_Bitwis

; 163  :     {
; 164  :         // v が 0 である場合
; 165  :         *w = 0;

	mov	rax, QWORD PTR w$[rbp]
	mov	DWORD PTR [rax], 0

; 166  :     }

	jmp	SHORT $LN7@PMC_Bitwis
$LN6@PMC_Bitwis:

; 167  :     else  if (u == 0)

	cmp	DWORD PTR u$[rbp], 0
	jne	SHORT $LN8@PMC_Bitwis

; 168  :     {
; 169  :         // u が 0 である場合
; 170  :         *w = 0;

	mov	rax, QWORD PTR w$[rbp]
	mov	DWORD PTR [rax], 0

; 171  :     }

	jmp	SHORT $LN9@PMC_Bitwis
$LN8@PMC_Bitwis:

; 172  :     else
; 173  :     {
; 174  :         // u と v がともに 0 ではない場合
; 175  : 
; 176  :         // u と v の bit AND を計算する
; 177  :         *w = nv->BLOCK[0] & u;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nv$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	edx, DWORD PTR u$[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	and	rax, rdx
	mov	rcx, QWORD PTR w$[rbp]
	mov	DWORD PTR [rcx], eax
$LN9@PMC_Bitwis:
$LN7@PMC_Bitwis:

; 178  :     }
; 179  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Bitwis:

; 180  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
PMC_BitwiseAnd_I_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_bitwiseand.c
;	COMDAT Initialize_BitwiseAnd
_TEXT	SEGMENT
feature$ = 224
Initialize_BitwiseAnd PROC				; COMDAT

; 364  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__B93DAC51_pmc_bitwiseand@c
	call	__CheckForDebuggerJustMyCode

; 365  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 366  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Initialize_BitwiseAnd ENDP
_TEXT	ENDS
END
