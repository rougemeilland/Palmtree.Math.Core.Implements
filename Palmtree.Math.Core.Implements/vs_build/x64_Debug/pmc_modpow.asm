; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__4522B509_pmc_internal@h DB 01H
__54B479F5_pmc_modpow@c DB 01H
msvcjmc	ENDS
PUBLIC	Initialize_ModPow
PUBLIC	PMC_ModPow_X_X_X
PUBLIC	__JustMyCode_Default
EXTRN	AllocateBlock:PROC
EXTRN	DeallocateBlock:PROC
EXTRN	CheckBlockLight:PROC
EXTRN	AllocateNumber:PROC
EXTRN	DeallocateNumber:PROC
EXTRN	CommitNumber:PROC
EXTRN	CheckNumber:PROC
EXTRN	DuplicateNumber:PROC
EXTRN	Multiply_X_X_Imp:PROC
EXTRN	DivRem_X_X:PROC
EXTRN	Compare_Imp:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	number_zero:BYTE
EXTRN	number_one:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$Initialize_ModPow DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$Initialize_ModPow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_ModPow_X_X_X DD imagerel $LN12
	DD	imagerel $LN12+318
	DD	imagerel $unwind$PMC_ModPow_X_X_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_COPY_MEMORY_UNIT DD imagerel _COPY_MEMORY_UNIT
	DD	imagerel _COPY_MEMORY_UNIT+100
	DD	imagerel $unwind$_COPY_MEMORY_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ZERO_MEMORY_UNIT DD imagerel _ZERO_MEMORY_UNIT
	DD	imagerel _ZERO_MEMORY_UNIT+88
	DD	imagerel $unwind$_ZERO_MEMORY_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MAXIMUM_UNIT DD imagerel _MAXIMUM_UNIT
	DD	imagerel _MAXIMUM_UNIT+122
	DD	imagerel $unwind$_MAXIMUM_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_LZCNT_ALT_UNIT DD imagerel _LZCNT_ALT_UNIT
	DD	imagerel _LZCNT_ALT_UNIT+131
	DD	imagerel $unwind$_LZCNT_ALT_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Compare_Easy DD imagerel Compare_Easy
	DD	imagerel Compare_Easy+155
	DD	imagerel $unwind$Compare_Easy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SwapPointer DD imagerel SwapPointer
	DD	imagerel SwapPointer+117
	DD	imagerel $unwind$SwapPointer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Remainder DD imagerel Remainder
	DD	imagerel Remainder+712
	DD	imagerel $unwind$Remainder
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ModulePower DD imagerel ModulePower
	DD	imagerel ModulePower+3505
	DD	imagerel $unwind$ModulePower
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_ModPow_X_X_X_Imp DD imagerel PMC_ModPow_X_X_X_Imp
	DD	imagerel PMC_ModPow_X_X_X_Imp+487
	DD	imagerel $unwind$PMC_ModPow_X_X_X_Imp
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_ModPow_X_X_X_Imp DD 025053901H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ModulePower DD 045053901H
	DD	011d4322H
	DD	0701600d5H
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
ModulePower$rtcName$0 DB 076H
	DB	05fH
	DB	032H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+3
ModulePower$rtcName$1 DB 076H
	DB	05fH
	DB	032H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+2
ModulePower$rtcName$2 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	031H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
ModulePower$rtcName$3 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	031H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+3
ModulePower$rtcName$11 DB 075H
	DB	05fH
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+6
ModulePower$rtcName$4 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	032H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
ModulePower$rtcName$5 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	032H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+3
ModulePower$rtcName$12 DB 077H
	DB	05fH
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+6
ModulePower$rtcName$6 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	076H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
ModulePower$rtcName$7 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	076H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+7
ModulePower$rtcName$8 DB 071H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+5
ModulePower$rtcName$9 DB 071H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+4
ModulePower$rtcName$10 DB 072H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+11
ModulePower$rtcVarDesc DD 0428H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$12
	DD	03e8H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$11
	DD	0348H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$10
	DD	02e8H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$9
	DD	02c8H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$8
	DD	0268H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$7
	DD	0248H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$6
	DD	01e8H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$5
	DD	01c8H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$4
	DD	0168H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$3
	DD	0148H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$2
	DD	0e8H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$1
	DD	0c8H
	DD	08H
	DQ	FLAT:ModulePower$rtcName$0
	ORG $+624
ModulePower$rtcFrameData DD 0dH
	DD	00H
	DQ	FLAT:ModulePower$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Remainder DD 045053401H
	DD	0118431dH
	DD	070110041H
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
Remainder$rtcName$0 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	076H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
Remainder$rtcName$1 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	076H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+7
Remainder$rtcName$2 DB 071H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+5
Remainder$rtcName$3 DB 071H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+4
Remainder$rtcName$4 DB 072H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+11
Remainder$rtcVarDesc DD 0128H
	DD	08H
	DQ	FLAT:Remainder$rtcName$4
	DD	0e8H
	DD	08H
	DQ	FLAT:Remainder$rtcName$3
	DD	0c8H
	DD	08H
	DQ	FLAT:Remainder$rtcName$2
	DD	088H
	DD	08H
	DQ	FLAT:Remainder$rtcName$1
	DD	068H
	DD	08H
	DQ	FLAT:Remainder$rtcName$0
	ORG $+240
Remainder$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:Remainder$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SwapPointer DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Compare_Easy DD 025053901H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_LZCNT_ALT_UNIT DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_LZCNT_ALT_UNIT$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+12
_LZCNT_ALT_UNIT$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:_LZCNT_ALT_UNIT$rtcName$0
	ORG $+48
_LZCNT_ALT_UNIT$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_LZCNT_ALT_UNIT$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MAXIMUM_UNIT DD 025052f01H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ZERO_MEMORY_UNIT DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_COPY_MEMORY_UNIT DD 025063501H
	DD	0119231eH
	DD	07012001cH
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_ModPow_X_X_X DD 025053901H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Initialize_ModPow DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_modpow.c
;	COMDAT PMC_ModPow_X_X_X_Imp
_TEXT	SEGMENT
result$ = 4
v$ = 256
e$ = 264
m$ = 272
r$ = 280
PMC_ModPow_X_X_X_Imp PROC				; COMDAT

; 506  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__54B479F5_pmc_modpow@c
	call	__CheckForDebuggerJustMyCode

; 507  :     PMC_STATUS_CODE result;
; 508  : 
; 509  :     if (m->IS_ZERO)

	mov	rax, QWORD PTR m$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@PMC_ModPow

; 510  :     {
; 511  :         // m が 0 の場合
; 512  : 
; 513  :         // 0 による除算は許されないのでエラーを通知する
; 514  :         return (PMC_STATUS_DIVISION_BY_ZERO);

	mov	eax, -3
	jmp	$LN1@PMC_ModPow

; 515  :     }

	jmp	$LN3@PMC_ModPow
$LN2@PMC_ModPow:

; 516  :     else if (m->IS_ONE)

	mov	rax, QWORD PTR m$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@PMC_ModPow

; 517  :     {
; 518  :         // m が 1 の場合
; 519  :         if (v->IS_ZERO)

	mov	rax, QWORD PTR v$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@PMC_ModPow

; 520  :         {
; 521  :             // v が 0 の場合
; 522  :             if (e->IS_ZERO)

	mov	rax, QWORD PTR e$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@PMC_ModPow

; 523  :             {
; 524  :                 // e が 0 の場合
; 525  : 
; 526  :                 // 0 の 0 乗となるので、エラーを返す
; 527  :                 return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_ModPow

; 528  :             }

	jmp	SHORT $LN9@PMC_ModPow
$LN8@PMC_ModPow:

; 529  :             else
; 530  :             {
; 531  :                 // e が 0 ではない場合
; 532  : 
; 533  :                 // v の e 乗がどんな値であっても 1 では必ず割り切れるので剰余は 0 となる。
; 534  :                 *r = &number_zero;

	mov	rax, QWORD PTR r$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx
$LN9@PMC_ModPow:

; 535  :             }
; 536  :         }

	jmp	SHORT $LN7@PMC_ModPow
$LN6@PMC_ModPow:

; 537  :         else
; 538  :         {
; 539  :             // v が 0 ではない場合
; 540  : 
; 541  :             // v の e 乗がどんな値であっても 1 では必ず割り切れるので剰余は 0 となる。
; 542  :             *r = &number_zero;

	mov	rax, QWORD PTR r$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx
$LN7@PMC_ModPow:

; 543  :         }
; 544  :     }

	jmp	$LN5@PMC_ModPow
$LN4@PMC_ModPow:

; 545  :     else
; 546  :     {
; 547  :         // m が 2 以上の場合
; 548  :         if (v->IS_ZERO)

	mov	rax, QWORD PTR v$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@PMC_ModPow

; 549  :         {
; 550  :             // v が 0 の場合
; 551  :             if (e->IS_ZERO)

	mov	rax, QWORD PTR e$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@PMC_ModPow

; 552  :             {
; 553  :                 // e が 0 の場合
; 554  : 
; 555  :                 // 0 の 0 乗となるので、エラーを返す
; 556  :                 return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_ModPow

; 557  :             }

	jmp	SHORT $LN13@PMC_ModPow
$LN12@PMC_ModPow:

; 558  :             else
; 559  :             {
; 560  :                 // e が 0 ではない場合
; 561  : 
; 562  :                 *r = &number_zero;

	mov	rax, QWORD PTR r$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx
$LN13@PMC_ModPow:

; 563  :             }
; 564  :         }

	jmp	$LN11@PMC_ModPow
$LN10@PMC_ModPow:

; 565  :         else if (v->IS_ONE)

	mov	rax, QWORD PTR v$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN14@PMC_ModPow

; 566  :         {
; 567  :             // v が 1 の場合
; 568  : 
; 569  :             // 1 を何乗しても 1 であり、1 を 2 以上の数で割ればその剰余は必ず 1 となる
; 570  :             *r = &number_one;

	mov	rax, QWORD PTR r$[rbp]
	lea	rcx, OFFSET FLAT:number_one
	mov	QWORD PTR [rax], rcx

; 571  :         }

	jmp	$LN15@PMC_ModPow
$LN14@PMC_ModPow:

; 572  :         else
; 573  :         {
; 574  :             // v が 2 以上の場合
; 575  :             if (e->IS_ZERO)

	mov	rax, QWORD PTR e$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN16@PMC_ModPow

; 576  :             {
; 577  :                 // e が 0 の場合
; 578  :                 *r = &number_one;

	mov	rax, QWORD PTR r$[rbp]
	lea	rcx, OFFSET FLAT:number_one
	mov	QWORD PTR [rax], rcx

; 579  :             }

	jmp	SHORT $LN17@PMC_ModPow
$LN16@PMC_ModPow:

; 580  :             else if (e->IS_ONE)

	mov	rax, QWORD PTR e$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN18@PMC_ModPow

; 581  :             {
; 582  :                 // e が 1 の場合
; 583  : 
; 584  :                 // v % m を計算して返す
; 585  :                 if ((result = Remainder(v, m, r)) != PMC_STATUS_OK)

	mov	r8, QWORD PTR r$[rbp]
	mov	rdx, QWORD PTR m$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	call	Remainder
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN20@PMC_ModPow

; 586  :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_ModPow
$LN20@PMC_ModPow:

; 587  :             }

	jmp	SHORT $LN19@PMC_ModPow
$LN18@PMC_ModPow:

; 588  :             else
; 589  :             {
; 590  :                 // v、e、m がすべて 2 以上である場合
; 591  :                 // v の e 乗 の m による剰余を計算して返す
; 592  :                 if ((result = ModulePower(v, e, m, r)) != PMC_STATUS_OK)

	mov	r9, QWORD PTR r$[rbp]
	mov	r8, QWORD PTR m$[rbp]
	mov	rdx, QWORD PTR e$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	call	ModulePower
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN21@PMC_ModPow

; 593  :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_ModPow
$LN21@PMC_ModPow:
$LN19@PMC_ModPow:
$LN17@PMC_ModPow:
$LN15@PMC_ModPow:
$LN11@PMC_ModPow:
$LN5@PMC_ModPow:
$LN3@PMC_ModPow:

; 594  :             }
; 595  :         }
; 596  :     }
; 597  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_ModPow:

; 598  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
PMC_ModPow_X_X_X_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_modpow.c
;	COMDAT ModulePower
_TEXT	SEGMENT
result$ = 4
m_buf$ = 40
m_count$ = 72
v_2_bit_count$ = 104
v_2_buf_code$ = 136
v_2_buf_words$ = 168
v_2_buf$ = 200
work_1_bit_count$ = 232
work_1_buf_code$ = 264
work_1_buf_words$ = 296
work_1_buf$ = 328
work_2_bit_count$ = 360
work_2_buf_code$ = 392
work_2_buf_words$ = 424
work_2_buf$ = 456
work_v_bit_count$ = 488
work_v_buf_code$ = 520
work_v_buf_words$ = 552
work_v_buf$ = 584
q_buf_bit_count$ = 616
q_buf_code$ = 648
q_buf_words$ = 680
q_buf$ = 712
r_bit_count$ = 744
r_check_code$ = 776
v_count$ = 808
cmp$ = 836
e_count$ = 872
e_mask$ = 904
u_ptr$ = 936
v_ptr$ = 968
w_ptr$ = 1000
u_count$ = 1032
v$ = 1664
e$ = 1672
m$ = 1680
r$ = 1688
ModulePower PROC					; COMDAT

; 161  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 1704				; 000006a8H
	lea	rbp, QWORD PTR [rsp+64]
	mov	rdi, rsp
	mov	ecx, 426				; 000001aaH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+1736]
	lea	rcx, OFFSET FLAT:__54B479F5_pmc_modpow@c
	call	__CheckForDebuggerJustMyCode

; 162  : #ifdef DO_TRACE
; 163  :     ReportIN(v, e, m);
; 164  : #endif
; 165  :     PMC_STATUS_CODE result;
; 166  :     __UNIT_TYPE* m_buf = m->BLOCK;

	mov	rax, QWORD PTR m$[rbp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR m_buf$[rbp], rax

; 167  :     __UNIT_TYPE m_count = m->UNIT_WORD_COUNT;

	mov	rax, QWORD PTR m$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR m_count$[rbp], rax

; 168  : 
; 169  :     // 作業域を獲得する
; 170  : 
; 171  :     __UNIT_TYPE v_2_bit_count = v->UNIT_WORD_COUNT * __UNIT_TYPE_BIT_COUNT + __UNIT_TYPE_BIT_COUNT;

	mov	rax, QWORD PTR v$[rbp]
	imul	rax, QWORD PTR [rax], 64		; 00000040H
	add	rax, 64					; 00000040H
	mov	QWORD PTR v_2_bit_count$[rbp], rax

; 172  :     __UNIT_TYPE v_2_buf_code;
; 173  :     __UNIT_TYPE v_2_buf_words;
; 174  :     __UNIT_TYPE* v_2_buf = AllocateBlock(v_2_bit_count, &v_2_buf_words, &v_2_buf_code);

	lea	r8, QWORD PTR v_2_buf_code$[rbp]
	lea	rdx, QWORD PTR v_2_buf_words$[rbp]
	mov	rcx, QWORD PTR v_2_bit_count$[rbp]
	call	AllocateBlock
	mov	QWORD PTR v_2_buf$[rbp], rax

; 175  :     if (v_2_buf == NULL)

	cmp	QWORD PTR v_2_buf$[rbp], 0
	jne	SHORT $LN10@ModulePowe

; 176  :     {
; 177  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ModulePowe
$LN10@ModulePowe:

; 178  :     }
; 179  : 
; 180  :     __UNIT_TYPE work_1_bit_count = m_count * 2 * __UNIT_TYPE_BIT_COUNT + __UNIT_TYPE_BIT_COUNT;

	mov	rax, QWORD PTR m_count$[rbp]
	shl	rax, 1
	imul	rax, rax, 64				; 00000040H
	add	rax, 64					; 00000040H
	mov	QWORD PTR work_1_bit_count$[rbp], rax

; 181  :     __UNIT_TYPE work_1_buf_code;
; 182  :     __UNIT_TYPE work_1_buf_words;
; 183  :     __UNIT_TYPE* work_1_buf = AllocateBlock(work_1_bit_count, &work_1_buf_words, &work_1_buf_code);

	lea	r8, QWORD PTR work_1_buf_code$[rbp]
	lea	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR work_1_bit_count$[rbp]
	call	AllocateBlock
	mov	QWORD PTR work_1_buf$[rbp], rax

; 184  :     if (work_1_buf == NULL)

	cmp	QWORD PTR work_1_buf$[rbp], 0
	jne	SHORT $LN11@ModulePowe

; 185  :     {
; 186  :         DeallocateBlock(v_2_buf, v_2_buf_words);

	mov	rdx, QWORD PTR v_2_buf_words$[rbp]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	DeallocateBlock

; 187  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ModulePowe
$LN11@ModulePowe:

; 188  :     }
; 189  : 
; 190  :     __UNIT_TYPE work_2_bit_count = m_count * 2 * __UNIT_TYPE_BIT_COUNT + __UNIT_TYPE_BIT_COUNT;

	mov	rax, QWORD PTR m_count$[rbp]
	shl	rax, 1
	imul	rax, rax, 64				; 00000040H
	add	rax, 64					; 00000040H
	mov	QWORD PTR work_2_bit_count$[rbp], rax

; 191  :     __UNIT_TYPE work_2_buf_code;
; 192  :     __UNIT_TYPE work_2_buf_words;
; 193  :     __UNIT_TYPE* work_2_buf = AllocateBlock(work_2_bit_count, &work_2_buf_words, &work_2_buf_code);

	lea	r8, QWORD PTR work_2_buf_code$[rbp]
	lea	rdx, QWORD PTR work_2_buf_words$[rbp]
	mov	rcx, QWORD PTR work_2_bit_count$[rbp]
	call	AllocateBlock
	mov	QWORD PTR work_2_buf$[rbp], rax

; 194  :     if (work_2_buf == NULL)

	cmp	QWORD PTR work_2_buf$[rbp], 0
	jne	SHORT $LN12@ModulePowe

; 195  :     {
; 196  :         DeallocateBlock(work_1_buf, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	DeallocateBlock

; 197  :         DeallocateBlock(v_2_buf, v_2_buf_words);

	mov	rdx, QWORD PTR v_2_buf_words$[rbp]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	DeallocateBlock

; 198  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ModulePowe
$LN12@ModulePowe:

; 199  :     }
; 200  : 
; 201  :     __UNIT_TYPE work_v_bit_count = m_count * __UNIT_TYPE_BIT_COUNT;

	imul	rax, QWORD PTR m_count$[rbp], 64	; 00000040H
	mov	QWORD PTR work_v_bit_count$[rbp], rax

; 202  :     __UNIT_TYPE work_v_buf_code;
; 203  :     __UNIT_TYPE work_v_buf_words;
; 204  :     __UNIT_TYPE* work_v_buf = AllocateBlock(work_v_bit_count, &work_v_buf_words, &work_v_buf_code);

	lea	r8, QWORD PTR work_v_buf_code$[rbp]
	lea	rdx, QWORD PTR work_v_buf_words$[rbp]
	mov	rcx, QWORD PTR work_v_bit_count$[rbp]
	call	AllocateBlock
	mov	QWORD PTR work_v_buf$[rbp], rax

; 205  :     if (work_v_buf == NULL)

	cmp	QWORD PTR work_v_buf$[rbp], 0
	jne	SHORT $LN13@ModulePowe

; 206  :     {
; 207  :         DeallocateBlock(work_2_buf, work_2_buf_words);

	mov	rdx, QWORD PTR work_2_buf_words$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	DeallocateBlock

; 208  :         DeallocateBlock(work_1_buf, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	DeallocateBlock

; 209  :         DeallocateBlock(v_2_buf, v_2_buf_words);

	mov	rdx, QWORD PTR v_2_buf_words$[rbp]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	DeallocateBlock

; 210  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ModulePowe
$LN13@ModulePowe:

; 211  :     }
; 212  : 
; 213  :     __UNIT_TYPE q_buf_bit_count = _MAXIMUM_UNIT(v->UNIT_BIT_COUNT, m->UNIT_BIT_COUNT * 2) - m->UNIT_BIT_COUNT + 1 + __UNIT_TYPE_BIT_COUNT;

	mov	rax, QWORD PTR m$[rbp]
	mov	rax, QWORD PTR [rax+8]
	shl	rax, 1
	mov	rdx, rax
	mov	rax, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	_MAXIMUM_UNIT
	mov	rcx, QWORD PTR m$[rbp]
	sub	rax, QWORD PTR [rcx+8]
	add	rax, 65					; 00000041H
	mov	QWORD PTR q_buf_bit_count$[rbp], rax

; 214  :     __UNIT_TYPE q_buf_code;
; 215  :     __UNIT_TYPE q_buf_words;
; 216  :     __UNIT_TYPE* q_buf = AllocateBlock(q_buf_bit_count, &q_buf_words, &q_buf_code);

	lea	r8, QWORD PTR q_buf_code$[rbp]
	lea	rdx, QWORD PTR q_buf_words$[rbp]
	mov	rcx, QWORD PTR q_buf_bit_count$[rbp]
	call	AllocateBlock
	mov	QWORD PTR q_buf$[rbp], rax

; 217  :     if (q_buf == NULL)

	cmp	QWORD PTR q_buf$[rbp], 0
	jne	SHORT $LN14@ModulePowe

; 218  :     {
; 219  :         DeallocateBlock(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	DeallocateBlock

; 220  :         DeallocateBlock(work_2_buf, work_2_buf_words);

	mov	rdx, QWORD PTR work_2_buf_words$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	DeallocateBlock

; 221  :         DeallocateBlock(work_1_buf, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	DeallocateBlock

; 222  :         DeallocateBlock(v_2_buf, v_2_buf_words);

	mov	rdx, QWORD PTR v_2_buf_words$[rbp]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	DeallocateBlock

; 223  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ModulePowe
$LN14@ModulePowe:

; 224  :     }
; 225  : 
; 226  :     __UNIT_TYPE r_bit_count = m->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR m$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR r_bit_count$[rbp], rax

; 227  :     __UNIT_TYPE r_check_code;
; 228  :     if ((result = AllocateNumber(r, r_bit_count, &r_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR r_check_code$[rbp]
	mov	rdx, QWORD PTR r_bit_count$[rbp]
	mov	rcx, QWORD PTR r$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN15@ModulePowe

; 229  :     {
; 230  :         DeallocateBlock(q_buf, q_buf_words);

	mov	rdx, QWORD PTR q_buf_words$[rbp]
	mov	rcx, QWORD PTR q_buf$[rbp]
	call	DeallocateBlock

; 231  :         DeallocateBlock(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	DeallocateBlock

; 232  :         DeallocateBlock(work_2_buf, work_2_buf_words);

	mov	rdx, QWORD PTR work_2_buf_words$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	DeallocateBlock

; 233  :         DeallocateBlock(work_1_buf, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	DeallocateBlock

; 234  :         DeallocateBlock(v_2_buf, v_2_buf_words);

	mov	rdx, QWORD PTR v_2_buf_words$[rbp]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	DeallocateBlock

; 235  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ModulePowe
$LN15@ModulePowe:

; 236  :     }
; 237  : 
; 238  :     __UNIT_TYPE v_count;
; 239  :     int cmp = Compare_Easy(v->BLOCK, v->UNIT_WORD_COUNT, m_buf, m_count);

	mov	r9, QWORD PTR m_count$[rbp]
	mov	r8, QWORD PTR m_buf$[rbp]
	mov	rax, QWORD PTR v$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	Compare_Easy
	mov	DWORD PTR cmp$[rbp], eax

; 240  :     if (cmp == 0)

	cmp	DWORD PTR cmp$[rbp], 0
	jne	$LN16@ModulePowe

; 241  :     {
; 242  :         // v == m である場合
; 243  : 
; 244  :         // v を何乗してもその剰余は 0 であるため、0 を返す。
; 245  : 
; 246  :         DeallocateNumber(*r);

	mov	rax, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	DeallocateNumber

; 247  :         DeallocateBlock(q_buf, q_buf_words);

	mov	rdx, QWORD PTR q_buf_words$[rbp]
	mov	rcx, QWORD PTR q_buf$[rbp]
	call	DeallocateBlock

; 248  :         DeallocateBlock(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	DeallocateBlock

; 249  :         DeallocateBlock(work_2_buf, work_2_buf_words);

	mov	rdx, QWORD PTR work_2_buf_words$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	DeallocateBlock

; 250  :         DeallocateBlock(work_1_buf, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	DeallocateBlock

; 251  :         DeallocateBlock(v_2_buf, v_2_buf_words);

	mov	rdx, QWORD PTR v_2_buf_words$[rbp]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	DeallocateBlock

; 252  :         *r = &number_zero;

	mov	rax, QWORD PTR r$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 253  : #ifdef DO_TRACE
; 254  :         ReportOUT(*r);
; 255  : #endif
; 256  :         return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	$LN1@ModulePowe

; 257  :     }

	jmp	$LN17@ModulePowe
$LN16@ModulePowe:

; 258  :     else if (cmp > 0)

	cmp	DWORD PTR cmp$[rbp], 0
	jle	$LN18@ModulePowe

; 259  :     {
; 260  :         // v > m である場合
; 261  : 
; 262  :         // v2 を v % m に設定する。
; 263  : 
; 264  :         DivRem_X_X(v->BLOCK, v->UNIT_WORD_COUNT, m_buf, m_count, work_v_buf, q_buf, v_2_buf);

	mov	rax, QWORD PTR v_2_buf$[rbp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR q_buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR work_v_buf$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR m_count$[rbp]
	mov	r8, QWORD PTR m_buf$[rbp]
	mov	rax, QWORD PTR v$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	DivRem_X_X

; 265  :         if ((result = CheckBlockLight(work_v_buf, work_v_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_v_buf_code$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN20@ModulePowe

; 266  :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN20@ModulePowe:

; 267  :         if ((result = CheckBlockLight(q_buf, q_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR q_buf_code$[rbp]
	mov	rcx, QWORD PTR q_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN21@ModulePowe

; 268  :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN21@ModulePowe:

; 269  :         if ((result = CheckBlockLight(v_2_buf, v_2_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR v_2_buf_code$[rbp]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN22@ModulePowe

; 270  :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN22@ModulePowe:

; 271  :         v_count = m_count;

	mov	rax, QWORD PTR m_count$[rbp]
	mov	QWORD PTR v_count$[rbp], rax
$LN2@ModulePowe:

; 272  :         while (v_count > 0 && v_2_buf[v_count - 1] == 0)

	cmp	QWORD PTR v_count$[rbp], 0
	jbe	SHORT $LN3@ModulePowe
	mov	rax, QWORD PTR v_2_buf$[rbp]
	mov	rcx, QWORD PTR v_count$[rbp]
	cmp	QWORD PTR [rax+rcx*8-8], 0
	jne	SHORT $LN3@ModulePowe

; 273  :             --v_count;

	mov	rax, QWORD PTR v_count$[rbp]
	dec	rax
	mov	QWORD PTR v_count$[rbp], rax
	jmp	SHORT $LN2@ModulePowe
$LN3@ModulePowe:

; 274  : 
; 275  :         if (v_count <= 0)

	cmp	QWORD PTR v_count$[rbp], 0
	ja	$LN23@ModulePowe

; 276  :         {
; 277  :             // v2 が 0 になってしまった場合はべき乗を繰り返しても 0 になることが確定なので 0 を返す
; 278  :             DeallocateNumber(*r);

	mov	rax, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	DeallocateNumber

; 279  :             DeallocateBlock(q_buf, q_buf_words);

	mov	rdx, QWORD PTR q_buf_words$[rbp]
	mov	rcx, QWORD PTR q_buf$[rbp]
	call	DeallocateBlock

; 280  :             DeallocateBlock(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	DeallocateBlock

; 281  :             DeallocateBlock(work_2_buf, work_2_buf_words);

	mov	rdx, QWORD PTR work_2_buf_words$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	DeallocateBlock

; 282  :             DeallocateBlock(work_1_buf, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	DeallocateBlock

; 283  :             DeallocateBlock(v_2_buf, v_2_buf_words);

	mov	rdx, QWORD PTR v_2_buf_words$[rbp]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	DeallocateBlock

; 284  :             *r = &number_zero;

	mov	rax, QWORD PTR r$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 285  : #ifdef DO_TRACE
; 286  :             ReportOUT(*r);
; 287  : #endif
; 288  :             return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	$LN1@ModulePowe
$LN23@ModulePowe:

; 289  :         }
; 290  :     }

	jmp	SHORT $LN19@ModulePowe
$LN18@ModulePowe:

; 291  :     else
; 292  :     {
; 293  :         // v2 を v に設定する。
; 294  : 
; 295  :         _COPY_MEMORY_UNIT(v_2_buf, v->BLOCK, v->UNIT_WORD_COUNT);

	mov	rax, QWORD PTR v$[rbp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR v$[rbp]
	mov	rdx, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	_COPY_MEMORY_UNIT

; 296  :         v_count = v->UNIT_WORD_COUNT;

	mov	rax, QWORD PTR v$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR v_count$[rbp], rax
$LN19@ModulePowe:
$LN17@ModulePowe:

; 297  :     }
; 298  : 
; 299  : #ifdef DO_TRACE
; 300  :     ReportLabel("vの初期化");
; 301  :     ReportDump("v", v_2_buf, v_count);
; 302  : #endif
; 303  :     __UNIT_TYPE e_count = e->UNIT_WORD_COUNT;

	mov	rax, QWORD PTR e$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR e_count$[rbp], rax

; 304  :     __UNIT_TYPE e_mask = ~((__UNIT_TYPE)-1 >> 1);

	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	QWORD PTR e_mask$[rbp], rax

; 305  :     e_mask = e_mask >> _LZCNT_ALT_UNIT(e->BLOCK[e_count - 1]);

	mov	rax, QWORD PTR e$[rbp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR e_count$[rbp]
	mov	rcx, QWORD PTR [rax+rcx*8-8]
	call	_LZCNT_ALT_UNIT
	movzx	ecx, al
	mov	rax, QWORD PTR e_mask$[rbp]
	shr	rax, cl
	mov	QWORD PTR e_mask$[rbp], rax

; 306  :     // e_mask は e の最上位 bit を示しているはず
; 307  :     // かつ、e は 2以上であるので、同時に最下位 bit であることはあり得ない
; 308  :     _COPY_MEMORY_UNIT(work_1_buf, v_2_buf, m_count);

	mov	r8, QWORD PTR m_count$[rbp]
	mov	rdx, QWORD PTR v_2_buf$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	_COPY_MEMORY_UNIT

; 309  : 
; 310  : #ifdef _DEBUG
; 311  :     if ((e_mask & e->BLOCK[e_count - 1]) == 0)

	mov	rax, QWORD PTR e$[rbp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR e_count$[rbp]
	mov	rax, QWORD PTR [rax+rcx*8-8]
	mov	rcx, QWORD PTR e_mask$[rbp]
	and	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jne	SHORT $LN24@ModulePowe

; 312  :         *((int*)0) = 0;

	mov	DWORD PTR ds:0, 0
$LN24@ModulePowe:

; 313  : #endif
; 314  : 
; 315  :     __UNIT_TYPE* u_ptr = work_1_buf;

	mov	rax, QWORD PTR work_1_buf$[rbp]
	mov	QWORD PTR u_ptr$[rbp], rax

; 316  :     __UNIT_TYPE* v_ptr = v_2_buf;

	mov	rax, QWORD PTR v_2_buf$[rbp]
	mov	QWORD PTR v_ptr$[rbp], rax

; 317  :     __UNIT_TYPE* w_ptr = work_2_buf;

	mov	rax, QWORD PTR work_2_buf$[rbp]
	mov	QWORD PTR w_ptr$[rbp], rax

; 318  :     __UNIT_TYPE u_count = v_count;

	mov	rax, QWORD PTR v_count$[rbp]
	mov	QWORD PTR u_count$[rbp], rax
$LN4@ModulePowe:

; 319  : 
; 320  :     while (e_count > 0)

	cmp	QWORD PTR e_count$[rbp], 0
	jbe	$LN5@ModulePowe

; 321  :     {
; 322  : #ifdef DO_TRACE
; 323  :         ReportLabel("ループ開始");
; 324  :         ReportVar("e_count", e_count);
; 325  :         ReportVar("e_mask", e_mask);
; 326  : #endif
; 327  : 
; 328  :         // 次の桁の準備をする
; 329  :         e_mask >>= 1;

	mov	rax, QWORD PTR e_mask$[rbp]
	shr	rax, 1
	mov	QWORD PTR e_mask$[rbp], rax

; 330  :         if (e_mask == 0)

	cmp	QWORD PTR e_mask$[rbp], 0
	jne	SHORT $LN25@ModulePowe

; 331  :         {
; 332  :             e_mask = ~((__UNIT_TYPE)-1 >> 1);

	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	QWORD PTR e_mask$[rbp], rax

; 333  :             --e_count;

	mov	rax, QWORD PTR e_count$[rbp]
	dec	rax
	mov	QWORD PTR e_count$[rbp], rax
$LN25@ModulePowe:

; 334  :         }
; 335  : 
; 336  :         if (e_count <= 0)

	cmp	QWORD PTR e_count$[rbp], 0
	ja	SHORT $LN26@ModulePowe

; 337  :             break;

	jmp	$LN5@ModulePowe
$LN26@ModulePowe:

; 338  : 
; 339  : #ifdef DO_TRACE
; 340  :         ReportLabel("e の更新");
; 341  :         ReportVar("e_count", e_count);
; 342  :         ReportVar("e_mask", e_mask);
; 343  : #endif
; 344  : 
; 345  :         // w := u * u を計算する
; 346  : #ifdef DO_TRACE
; 347  :         ReportLabel("w := u * u");
; 348  :         ReportDump("u", u_ptr, u_count);
; 349  : #endif
; 350  :         _ZERO_MEMORY_UNIT(w_ptr, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR w_ptr$[rbp]
	call	_ZERO_MEMORY_UNIT

; 351  :         Multiply_X_X_Imp(u_ptr, u_count, u_ptr, u_count, w_ptr);

	mov	rax, QWORD PTR w_ptr$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR u_count$[rbp]
	mov	r8, QWORD PTR u_ptr$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u_ptr$[rbp]
	call	Multiply_X_X_Imp

; 352  :         if ((result = CheckBlockLight(work_1_buf, work_1_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_1_buf_code$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN27@ModulePowe

; 353  :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN27@ModulePowe:

; 354  :         if ((result = CheckBlockLight(work_2_buf, work_2_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_2_buf_code$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN28@ModulePowe

; 355  :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN28@ModulePowe:

; 356  :         SwapPointer(&u_ptr, &w_ptr);

	lea	rdx, QWORD PTR w_ptr$[rbp]
	lea	rcx, QWORD PTR u_ptr$[rbp]
	call	SwapPointer

; 357  :         u_count *= 2;

	mov	rax, QWORD PTR u_count$[rbp]
	add	rax, rax
	mov	QWORD PTR u_count$[rbp], rax

; 358  :         if (u_ptr[u_count - 1] == 0)

	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	rcx, QWORD PTR u_count$[rbp]
	cmp	QWORD PTR [rax+rcx*8-8], 0
	jne	SHORT $LN29@ModulePowe

; 359  :             --u_count;

	mov	rax, QWORD PTR u_count$[rbp]
	dec	rax
	mov	QWORD PTR u_count$[rbp], rax
$LN29@ModulePowe:

; 360  : #ifdef DO_TRACE
; 361  :         ReportDump("w", u_ptr, u_count);
; 362  : #endif
; 363  : 
; 364  :         // w := u % m を計算する
; 365  : #ifdef DO_TRACE
; 366  :         ReportLabel("w := u % m");
; 367  :         ReportDump("u", u_ptr, u_count);
; 368  :         ReportDump("m", m_buf, m_count);
; 369  : #endif
; 370  :         if (u_count >= m_count)

	mov	rax, QWORD PTR m_count$[rbp]
	cmp	QWORD PTR u_count$[rbp], rax
	jb	$LN30@ModulePowe

; 371  :         {
; 372  :             _ZERO_MEMORY_UNIT(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	_ZERO_MEMORY_UNIT

; 373  :             _ZERO_MEMORY_UNIT(q_buf, q_buf_words);

	mov	rdx, QWORD PTR q_buf_words$[rbp]
	mov	rcx, QWORD PTR q_buf$[rbp]
	call	_ZERO_MEMORY_UNIT

; 374  :             _ZERO_MEMORY_UNIT(w_ptr, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR w_ptr$[rbp]
	call	_ZERO_MEMORY_UNIT

; 375  :             DivRem_X_X(u_ptr, u_count, m_buf, m_count, work_v_buf, q_buf, w_ptr);

	mov	rax, QWORD PTR w_ptr$[rbp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR q_buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR work_v_buf$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR m_count$[rbp]
	mov	r8, QWORD PTR m_buf$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u_ptr$[rbp]
	call	DivRem_X_X

; 376  :             if ((result = CheckBlockLight(work_v_buf, work_v_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_v_buf_code$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN31@ModulePowe

; 377  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN31@ModulePowe:

; 378  :             if ((result = CheckBlockLight(q_buf, q_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR q_buf_code$[rbp]
	mov	rcx, QWORD PTR q_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN32@ModulePowe

; 379  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN32@ModulePowe:

; 380  :             if ((result = CheckBlockLight(work_1_buf, work_1_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_1_buf_code$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN33@ModulePowe

; 381  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN33@ModulePowe:

; 382  :             if ((result = CheckBlockLight(work_2_buf, work_2_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_2_buf_code$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN34@ModulePowe

; 383  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN34@ModulePowe:

; 384  :             SwapPointer(&u_ptr, &w_ptr);

	lea	rdx, QWORD PTR w_ptr$[rbp]
	lea	rcx, QWORD PTR u_ptr$[rbp]
	call	SwapPointer

; 385  :             u_count = m_count;

	mov	rax, QWORD PTR m_count$[rbp]
	mov	QWORD PTR u_count$[rbp], rax
$LN6@ModulePowe:

; 386  :             while (u_count > 0 && u_ptr[u_count - 1] == 0)

	cmp	QWORD PTR u_count$[rbp], 0
	jbe	SHORT $LN7@ModulePowe
	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	rcx, QWORD PTR u_count$[rbp]
	cmp	QWORD PTR [rax+rcx*8-8], 0
	jne	SHORT $LN7@ModulePowe

; 387  :                 --u_count;

	mov	rax, QWORD PTR u_count$[rbp]
	dec	rax
	mov	QWORD PTR u_count$[rbp], rax
	jmp	SHORT $LN6@ModulePowe
$LN7@ModulePowe:

; 388  : 
; 389  :             if (u_count <= 0)

	cmp	QWORD PTR u_count$[rbp], 0
	ja	$LN35@ModulePowe

; 390  :             {
; 391  :                 // 剰余が 0 になった場合はこれ以上続行しても解が 0 以外にはならないので、処理を中断して 0 を返す
; 392  :                 DeallocateNumber(*r);

	mov	rax, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	DeallocateNumber

; 393  :                 DeallocateBlock(q_buf, q_buf_words);

	mov	rdx, QWORD PTR q_buf_words$[rbp]
	mov	rcx, QWORD PTR q_buf$[rbp]
	call	DeallocateBlock

; 394  :                 DeallocateBlock(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	DeallocateBlock

; 395  :                 DeallocateBlock(work_2_buf, work_2_buf_words);

	mov	rdx, QWORD PTR work_2_buf_words$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	DeallocateBlock

; 396  :                 DeallocateBlock(work_1_buf, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	DeallocateBlock

; 397  :                 DeallocateBlock(v_2_buf, v_2_buf_words);

	mov	rdx, QWORD PTR v_2_buf_words$[rbp]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	DeallocateBlock

; 398  :                 *r = &number_zero;

	mov	rax, QWORD PTR r$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 399  : #ifdef DO_TRACE
; 400  :                 ReportOUT(*r);
; 401  : #endif
; 402  :                 return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	$LN1@ModulePowe
$LN35@ModulePowe:
$LN30@ModulePowe:

; 403  :             }
; 404  :         }
; 405  : #ifdef DO_TRACE
; 406  :         ReportDump("w", u_ptr, u_count);
; 407  : #endif
; 408  : 
; 409  : #ifdef DO_TRACE
; 410  :         ReportLabel("e のビット検査");
; 411  :         ReportDump("e", e->BLOCK, e->UNIT_WORD_COUNT);
; 412  :         ReportVar("e_count", e_count);
; 413  :         ReportVar("e_mask", e_mask);
; 414  :         ReportVar("e_mask & e->BLOCK[e_count - 1]", e_mask & e->BLOCK[e_count - 1]);
; 415  : #endif
; 416  :         if (e_mask & e->BLOCK[e_count - 1])

	mov	rax, QWORD PTR e$[rbp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR e_count$[rbp]
	mov	rax, QWORD PTR [rax+rcx*8-8]
	mov	rcx, QWORD PTR e_mask$[rbp]
	and	rcx, rax
	mov	rax, rcx
	test	rax, rax
	je	$LN36@ModulePowe

; 417  :         {
; 418  :             // e の当該桁のビットが立っている場合
; 419  : 
; 420  : #ifdef DO_TRACE
; 421  :             ReportLabel("w := u * v");
; 422  :             ReportDump("u", u_ptr, u_count);
; 423  :             ReportDump("v", v_ptr, v_count);
; 424  : #endif
; 425  : 
; 426  :             // w := u * v を計算する
; 427  :             _ZERO_MEMORY_UNIT(w_ptr, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR w_ptr$[rbp]
	call	_ZERO_MEMORY_UNIT

; 428  :             Multiply_X_X_Imp(u_ptr, u_count, v_ptr, v_count, w_ptr);

	mov	rax, QWORD PTR w_ptr$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v_count$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u_ptr$[rbp]
	call	Multiply_X_X_Imp

; 429  :             if ((result = CheckBlockLight(work_1_buf, work_1_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_1_buf_code$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN37@ModulePowe

; 430  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN37@ModulePowe:

; 431  :             if ((result = CheckBlockLight(work_2_buf, work_2_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_2_buf_code$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN38@ModulePowe

; 432  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN38@ModulePowe:

; 433  :             SwapPointer(&u_ptr, &w_ptr);

	lea	rdx, QWORD PTR w_ptr$[rbp]
	lea	rcx, QWORD PTR u_ptr$[rbp]
	call	SwapPointer

; 434  :             u_count += v_count;

	mov	rax, QWORD PTR v_count$[rbp]
	mov	rcx, QWORD PTR u_count$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR u_count$[rbp], rax

; 435  :             if (u_ptr[u_count - 1] == 0)

	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	rcx, QWORD PTR u_count$[rbp]
	cmp	QWORD PTR [rax+rcx*8-8], 0
	jne	SHORT $LN39@ModulePowe

; 436  :                 --u_count;

	mov	rax, QWORD PTR u_count$[rbp]
	dec	rax
	mov	QWORD PTR u_count$[rbp], rax
$LN39@ModulePowe:

; 437  : #ifdef DO_TRACE
; 438  :             ReportDump("w", u_ptr, u_count);
; 439  : #endif
; 440  : 
; 441  :             // w := u % m を計算する
; 442  : 
; 443  : #ifdef DO_TRACE
; 444  :             ReportLabel("w := u % m");
; 445  :             ReportDump("u", u_ptr, u_count);
; 446  :             ReportDump("m", m_buf, m_count);
; 447  : #endif
; 448  :             if (u_count >= m_count)

	mov	rax, QWORD PTR m_count$[rbp]
	cmp	QWORD PTR u_count$[rbp], rax
	jb	$LN40@ModulePowe

; 449  :             {
; 450  :                 _ZERO_MEMORY_UNIT(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	_ZERO_MEMORY_UNIT

; 451  :                 _ZERO_MEMORY_UNIT(q_buf, q_buf_words);

	mov	rdx, QWORD PTR q_buf_words$[rbp]
	mov	rcx, QWORD PTR q_buf$[rbp]
	call	_ZERO_MEMORY_UNIT

; 452  :                 _ZERO_MEMORY_UNIT(w_ptr, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR w_ptr$[rbp]
	call	_ZERO_MEMORY_UNIT

; 453  :                 DivRem_X_X(u_ptr, u_count, m_buf, m_count, work_v_buf, q_buf, w_ptr);

	mov	rax, QWORD PTR w_ptr$[rbp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR q_buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR work_v_buf$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR m_count$[rbp]
	mov	r8, QWORD PTR m_buf$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u_ptr$[rbp]
	call	DivRem_X_X

; 454  :                 if ((result = CheckBlockLight(work_v_buf, work_v_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_v_buf_code$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN41@ModulePowe

; 455  :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN41@ModulePowe:

; 456  :                 if ((result = CheckBlockLight(q_buf, q_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR q_buf_code$[rbp]
	mov	rcx, QWORD PTR q_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN42@ModulePowe

; 457  :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN42@ModulePowe:

; 458  :                 if ((result = CheckBlockLight(work_1_buf, work_1_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_1_buf_code$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN43@ModulePowe

; 459  :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN43@ModulePowe:

; 460  :                 if ((result = CheckBlockLight(work_2_buf, work_2_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_2_buf_code$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN44@ModulePowe

; 461  :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ModulePowe
$LN44@ModulePowe:

; 462  :                 SwapPointer(&u_ptr, &w_ptr);

	lea	rdx, QWORD PTR w_ptr$[rbp]
	lea	rcx, QWORD PTR u_ptr$[rbp]
	call	SwapPointer

; 463  :                 u_count = m_count;

	mov	rax, QWORD PTR m_count$[rbp]
	mov	QWORD PTR u_count$[rbp], rax
$LN8@ModulePowe:

; 464  :                 while (u_count > 0 && u_ptr[u_count - 1] == 0)

	cmp	QWORD PTR u_count$[rbp], 0
	jbe	SHORT $LN9@ModulePowe
	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	rcx, QWORD PTR u_count$[rbp]
	cmp	QWORD PTR [rax+rcx*8-8], 0
	jne	SHORT $LN9@ModulePowe

; 465  :                     --u_count;

	mov	rax, QWORD PTR u_count$[rbp]
	dec	rax
	mov	QWORD PTR u_count$[rbp], rax
	jmp	SHORT $LN8@ModulePowe
$LN9@ModulePowe:

; 466  : 
; 467  :                 if (u_count <= 0)

	cmp	QWORD PTR u_count$[rbp], 0
	ja	$LN45@ModulePowe

; 468  :                 {
; 469  :                     // 剰余が 0 になった場合はこれ以上続行しても解が 0 以外にはならないので、処理を中断して 0 を返す
; 470  :                     DeallocateNumber(*r);

	mov	rax, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	DeallocateNumber

; 471  :                     DeallocateBlock(q_buf, q_buf_words);

	mov	rdx, QWORD PTR q_buf_words$[rbp]
	mov	rcx, QWORD PTR q_buf$[rbp]
	call	DeallocateBlock

; 472  :                     DeallocateBlock(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	DeallocateBlock

; 473  :                     DeallocateBlock(work_2_buf, work_2_buf_words);

	mov	rdx, QWORD PTR work_2_buf_words$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	DeallocateBlock

; 474  :                     DeallocateBlock(work_1_buf, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	DeallocateBlock

; 475  :                     DeallocateBlock(v_2_buf, v_2_buf_words);

	mov	rdx, QWORD PTR v_2_buf_words$[rbp]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	DeallocateBlock

; 476  :                     *r = &number_zero;

	mov	rax, QWORD PTR r$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 477  : #ifdef DO_TRACE
; 478  :                     ReportOUT(*r);
; 479  : #endif
; 480  :                     return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	$LN1@ModulePowe
$LN45@ModulePowe:
$LN40@ModulePowe:
$LN36@ModulePowe:

; 481  :                 }
; 482  :             }
; 483  : #ifdef DO_TRACE
; 484  :             ReportDump("w", u_ptr, u_count);
; 485  : #endif
; 486  :         }
; 487  :     }

	jmp	$LN4@ModulePowe
$LN5@ModulePowe:

; 488  : 
; 489  :     // 最下位桁まで達したので u_ptr と u_count を解として帰る
; 490  :     _COPY_MEMORY_UNIT((*r)->BLOCK, u_ptr, u_count);

	mov	rax, QWORD PTR r$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	r8, QWORD PTR u_count$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	_COPY_MEMORY_UNIT

; 491  :     if ((result = CheckBlockLight((*r)->BLOCK, r_check_code)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR r$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR r_check_code$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN46@ModulePowe

; 492  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@ModulePowe
$LN46@ModulePowe:

; 493  :     CommitNumber(*r);

	mov	rax, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CommitNumber

; 494  :     DeallocateBlock(q_buf, q_buf_words);

	mov	rdx, QWORD PTR q_buf_words$[rbp]
	mov	rcx, QWORD PTR q_buf$[rbp]
	call	DeallocateBlock

; 495  :     DeallocateBlock(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	DeallocateBlock

; 496  :     DeallocateBlock(work_2_buf, work_2_buf_words);

	mov	rdx, QWORD PTR work_2_buf_words$[rbp]
	mov	rcx, QWORD PTR work_2_buf$[rbp]
	call	DeallocateBlock

; 497  :     DeallocateBlock(work_1_buf, work_1_buf_words);

	mov	rdx, QWORD PTR work_1_buf_words$[rbp]
	mov	rcx, QWORD PTR work_1_buf$[rbp]
	call	DeallocateBlock

; 498  :     DeallocateBlock(v_2_buf, v_2_buf_words);

	mov	rdx, QWORD PTR v_2_buf_words$[rbp]
	mov	rcx, QWORD PTR v_2_buf$[rbp]
	call	DeallocateBlock

; 499  : #ifdef DO_TRACE
; 500  :     ReportOUT(*r);
; 501  : #endif
; 502  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ModulePowe:

; 503  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:ModulePower$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+1640]
	pop	rdi
	pop	rbp
	ret	0
ModulePower ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_modpow.c
;	COMDAT Remainder
_TEXT	SEGMENT
result$ = 4
work_v_buf_code$8 = 40
work_v_buf_words$9 = 72
work_v_buf$10 = 104
q_buf_code$11 = 136
q_buf_words$12 = 168
q_buf$13 = 200
r_check_code$14 = 232
u$ = 480
v$ = 488
r$ = 496
Remainder PROC						; COMDAT

; 104  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 520				; 00000208H
	lea	rbp, QWORD PTR [rsp+64]
	mov	rdi, rsp
	mov	ecx, 130				; 00000082H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+552]
	lea	rcx, OFFSET FLAT:__54B479F5_pmc_modpow@c
	call	__CheckForDebuggerJustMyCode

; 105  :     PMC_STATUS_CODE result;
; 106  : 
; 107  :     if (u->UNIT_BIT_COUNT < v->UNIT_BIT_COUNT)

	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax+8], rcx
	jae	SHORT $LN2@Remainder

; 108  :     {
; 109  :         if ((result = DuplicateNumber(u, r)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN4@Remainder

; 110  :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@Remainder
$LN4@Remainder:

; 111  :     }

	jmp	$LN3@Remainder
$LN2@Remainder:

; 112  :     else
; 113  :     {
; 114  :         __UNIT_TYPE work_v_buf_code;
; 115  :         __UNIT_TYPE work_v_buf_words;
; 116  :         __UNIT_TYPE* work_v_buf = AllocateBlock(v->UNIT_BIT_COUNT, &work_v_buf_words, &work_v_buf_code);

	lea	r8, QWORD PTR work_v_buf_code$8[rbp]
	lea	rdx, QWORD PTR work_v_buf_words$9[rbp]
	mov	rax, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AllocateBlock
	mov	QWORD PTR work_v_buf$10[rbp], rax

; 117  :         if (work_v_buf == NULL)

	cmp	QWORD PTR work_v_buf$10[rbp], 0
	jne	SHORT $LN5@Remainder

; 118  :         {
; 119  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@Remainder
$LN5@Remainder:

; 120  :         }
; 121  :         __UNIT_TYPE q_buf_code;
; 122  :         __UNIT_TYPE q_buf_words;
; 123  :         __UNIT_TYPE* q_buf = AllocateBlock(u->UNIT_BIT_COUNT - v->UNIT_BIT_COUNT + 1 + __UNIT_TYPE_BIT_COUNT, &q_buf_words, &q_buf_code);

	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	add	rax, 65					; 00000041H
	lea	r8, QWORD PTR q_buf_code$11[rbp]
	lea	rdx, QWORD PTR q_buf_words$12[rbp]
	mov	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR q_buf$13[rbp], rax

; 124  :         if (q_buf == NULL)

	cmp	QWORD PTR q_buf$13[rbp], 0
	jne	SHORT $LN6@Remainder

; 125  :         {
; 126  :             DeallocateBlock(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$9[rbp]
	mov	rcx, QWORD PTR work_v_buf$10[rbp]
	call	DeallocateBlock

; 127  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@Remainder
$LN6@Remainder:

; 128  :         }
; 129  :         __UNIT_TYPE r_check_code;
; 130  :         if ((result = AllocateNumber(r, u->UNIT_BIT_COUNT + __UNIT_TYPE_BIT_COUNT, &r_check_code)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR u$[rbp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 64					; 00000040H
	lea	r8, QWORD PTR r_check_code$14[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR r$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN7@Remainder

; 131  :         {
; 132  :             DeallocateBlock(q_buf, q_buf_words);

	mov	rdx, QWORD PTR q_buf_words$12[rbp]
	mov	rcx, QWORD PTR q_buf$13[rbp]
	call	DeallocateBlock

; 133  :             DeallocateBlock(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$9[rbp]
	mov	rcx, QWORD PTR work_v_buf$10[rbp]
	call	DeallocateBlock

; 134  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@Remainder
$LN7@Remainder:

; 135  :         }
; 136  : 
; 137  :         if (u->UNIT_WORD_COUNT < v->UNIT_WORD_COUNT)

	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN8@Remainder

; 138  :         {
; 139  :             q_buf[0] = 0;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR q_buf$13[rbp]
	mov	QWORD PTR [rcx+rax], 0

; 140  :             _COPY_MEMORY_UNIT((*r)->BLOCK, u->BLOCK, u->UNIT_WORD_COUNT);

	mov	rax, QWORD PTR r$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR u$[rbp]
	mov	r8, QWORD PTR [rcx]
	mov	rcx, QWORD PTR u$[rbp]
	mov	rdx, QWORD PTR [rcx+48]
	mov	rcx, QWORD PTR [rax+48]
	call	_COPY_MEMORY_UNIT

; 141  :         }

	jmp	$LN9@Remainder
$LN8@Remainder:

; 142  :         else
; 143  :         {
; 144  :             DivRem_X_X(u->BLOCK, u->UNIT_WORD_COUNT, v->BLOCK, v->UNIT_WORD_COUNT, work_v_buf, q_buf, (*r)->BLOCK);

	mov	rax, QWORD PTR r$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR q_buf$13[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR work_v_buf$10[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR v$[rbp]
	mov	r9, QWORD PTR [rax]
	mov	rax, QWORD PTR v$[rbp]
	mov	r8, QWORD PTR [rax+48]
	mov	rax, QWORD PTR u$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	DivRem_X_X

; 145  :             if ((result = CheckBlockLight(work_v_buf, work_v_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_v_buf_code$8[rbp]
	mov	rcx, QWORD PTR work_v_buf$10[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN10@Remainder

; 146  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@Remainder
$LN10@Remainder:

; 147  :             if ((result = CheckBlockLight(q_buf, q_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR q_buf_code$11[rbp]
	mov	rcx, QWORD PTR q_buf$13[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN11@Remainder

; 148  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@Remainder
$LN11@Remainder:

; 149  :             if ((result = CheckBlockLight((*r)->BLOCK, r_check_code)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR r$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR r_check_code$14[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN12@Remainder

; 150  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@Remainder
$LN12@Remainder:
$LN9@Remainder:

; 151  :         }
; 152  : 
; 153  :         DeallocateBlock(q_buf, q_buf_words);

	mov	rdx, QWORD PTR q_buf_words$12[rbp]
	mov	rcx, QWORD PTR q_buf$13[rbp]
	call	DeallocateBlock

; 154  :         DeallocateBlock(work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$9[rbp]
	mov	rcx, QWORD PTR work_v_buf$10[rbp]
	call	DeallocateBlock

; 155  :         CommitNumber(*r);

	mov	rax, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CommitNumber
$LN3@Remainder:

; 156  :     }
; 157  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@Remainder:

; 158  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:Remainder$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+456]
	pop	rdi
	pop	rbp
	ret	0
Remainder ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_modpow.c
;	COMDAT SwapPointer
_TEXT	SEGMENT
t$ = 8
u$ = 256
v$ = 264
SwapPointer PROC					; COMDAT

; 97   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__54B479F5_pmc_modpow@c
	call	__CheckForDebuggerJustMyCode

; 98   :     __UNIT_TYPE* t = *u;

	mov	rax, QWORD PTR u$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR t$[rbp], rax

; 99   :     *u = *v;

	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 100  :     *v = t;

	mov	rax, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax], rcx

; 101  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
SwapPointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_modpow.c
;	COMDAT Compare_Easy
_TEXT	SEGMENT
u$ = 224
u_count$ = 232
v$ = 240
v_count$ = 248
Compare_Easy PROC					; COMDAT

; 87   : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__54B479F5_pmc_modpow@c
	call	__CheckForDebuggerJustMyCode

; 88   :     if (u_count > v_count)

	mov	rax, QWORD PTR v_count$[rbp]
	cmp	QWORD PTR u_count$[rbp], rax
	jbe	SHORT $LN2@Compare_Ea

; 89   :         return (1);

	mov	eax, 1
	jmp	SHORT $LN1@Compare_Ea
	jmp	SHORT $LN3@Compare_Ea
$LN2@Compare_Ea:

; 90   :     else if (u_count < v_count)

	mov	rax, QWORD PTR v_count$[rbp]
	cmp	QWORD PTR u_count$[rbp], rax
	jae	SHORT $LN4@Compare_Ea

; 91   :         return (-1);

	mov	eax, -1
	jmp	SHORT $LN1@Compare_Ea
	jmp	SHORT $LN5@Compare_Ea
$LN4@Compare_Ea:

; 92   :     else
; 93   :         return (Compare_Imp(u, v, u_count));

	mov	r8, QWORD PTR u_count$[rbp]
	mov	rdx, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	call	Compare_Imp
$LN5@Compare_Ea:
$LN3@Compare_Ea:
$LN1@Compare_Ea:

; 94   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Compare_Easy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _LZCNT_ALT_UNIT
_TEXT	SEGMENT
pos$ = 4
x$ = 256
_LZCNT_ALT_UNIT PROC					; COMDAT

; 910  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 911  :     if (x == 0)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN2@LZCNT_ALT_

; 912  :         return (sizeof(x) * 8);

	mov	eax, 64					; 00000040H
	jmp	SHORT $LN1@LZCNT_ALT_
$LN2@LZCNT_ALT_:

; 913  : #ifdef _M_IX86
; 914  :     _UINT32_T pos;
; 915  : #ifdef _MSC_VER
; 916  :     _BitScanReverse(&pos, x);
; 917  : #elif defined(__GNUC__)
; 918  :     __asm__("bsrl %1, %0" : "=r"(pos) : "rm"(x));
; 919  : #else
; 920  : #error unknown compiler
; 921  : #endif
; 922  : #elif defined(_M_X64)
; 923  : #ifdef _MSC_VER
; 924  :     _UINT32_T pos;
; 925  :     _BitScanReverse64(&pos, x);

	mov	rax, QWORD PTR x$[rbp]
	bsr	rax, rax
	mov	DWORD PTR pos$[rbp], eax

; 926  : #elif defined(__GNUC__)
; 927  :     _UINT64_T pos;
; 928  :     __asm__("bsrq %1, %0" : "=r"(pos) : "rm"(x));
; 929  : #else
; 930  : #error unknown compiler
; 931  : #endif
; 932  : #else
; 933  : #error unknown platform
; 934  : #endif
; 935  :     return (sizeof(x) * 8 - 1 - pos);

	mov	eax, DWORD PTR pos$[rbp]
	mov	ecx, 63					; 0000003fH
	sub	rcx, rax
	mov	rax, rcx
$LN1@LZCNT_ALT_:

; 936  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_LZCNT_ALT_UNIT$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_LZCNT_ALT_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _MAXIMUM_UNIT
_TEXT	SEGMENT
tv65 = 192
x$ = 240
y$ = 248
_MAXIMUM_UNIT PROC					; COMDAT

; 484  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 485  :     return (x >= y ? x : y);

	mov	rax, QWORD PTR y$[rbp]
	cmp	QWORD PTR x$[rbp], rax
	jb	SHORT $LN3@MAXIMUM_UN
	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR tv65[rbp], rax
	jmp	SHORT $LN4@MAXIMUM_UN
$LN3@MAXIMUM_UN:
	mov	rax, QWORD PTR y$[rbp]
	mov	QWORD PTR tv65[rbp], rax
$LN4@MAXIMUM_UN:
	mov	rax, QWORD PTR tv65[rbp]

; 486  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
_MAXIMUM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _ZERO_MEMORY_UNIT
_TEXT	SEGMENT
d$ = 224
count$ = 232
_ZERO_MEMORY_UNIT PROC					; COMDAT

; 397  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 398  : #ifdef _M_IX86
; 399  :     __stosd((unsigned long*)d, 0, (unsigned long)count);
; 400  : #elif defined(_M_X64)
; 401  :     __stosq(d, 0, count);

	mov	rdi, QWORD PTR d$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR count$[rbp]
	rep stosq

; 402  : #else
; 403  : #error unknown platform
; 404  : #endif
; 405  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ZERO_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _COPY_MEMORY_UNIT
_TEXT	SEGMENT
d$ = 224
s$ = 232
count$ = 240
_COPY_MEMORY_UNIT PROC					; COMDAT

; 347  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 348  : #ifdef _M_IX86
; 349  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 350  : #elif defined(_M_X64)
; 351  :     __movsq(d, s, count);

	mov	rdi, QWORD PTR d$[rbp]
	mov	rsi, QWORD PTR s$[rbp]
	mov	rcx, QWORD PTR count$[rbp]
	rep movsq

; 352  : #else
; 353  : #error unknown platform
; 354  : #endif
; 355  : }

	lea	rsp, QWORD PTR [rbp+192]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
_COPY_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_modpow.c
;	COMDAT PMC_ModPow_X_X_X
_TEXT	SEGMENT
result$ = 4
v$ = 256
e$ = 264
m$ = 272
r$ = 280
PMC_ModPow_X_X_X PROC					; COMDAT

; 601  : {

$LN12:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__54B479F5_pmc_modpow@c
	call	__CheckForDebuggerJustMyCode

; 602  :     if (v == NULL)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN2@PMC_ModPow

; 603  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_ModPow
$LN2@PMC_ModPow:

; 604  :     if (e == NULL)

	cmp	QWORD PTR e$[rbp], 0
	jne	SHORT $LN3@PMC_ModPow

; 605  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_ModPow
$LN3@PMC_ModPow:

; 606  :     if (m == NULL)

	cmp	QWORD PTR m$[rbp], 0
	jne	SHORT $LN4@PMC_ModPow

; 607  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_ModPow
$LN4@PMC_ModPow:

; 608  :     if (r == NULL)

	cmp	QWORD PTR r$[rbp], 0
	jne	SHORT $LN5@PMC_ModPow

; 609  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_ModPow
$LN5@PMC_ModPow:

; 610  :     PMC_STATUS_CODE result;
; 611  :     if ((result = CheckNumber((NUMBER_HEADER*)v)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR v$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_ModPow

; 612  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_ModPow
$LN6@PMC_ModPow:

; 613  :     if ((result = CheckNumber((NUMBER_HEADER*)e)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR e$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN7@PMC_ModPow

; 614  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_ModPow
$LN7@PMC_ModPow:

; 615  :     if ((result = CheckNumber((NUMBER_HEADER*)m)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR m$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN8@PMC_ModPow

; 616  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_ModPow
$LN8@PMC_ModPow:

; 617  :     if ((result = PMC_ModPow_X_X_X_Imp((NUMBER_HEADER*)v, (NUMBER_HEADER*)e, (NUMBER_HEADER*)m, (NUMBER_HEADER**)r)) != PMC_STATUS_OK)

	mov	r9, QWORD PTR r$[rbp]
	mov	r8, QWORD PTR m$[rbp]
	mov	rdx, QWORD PTR e$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	call	PMC_ModPow_X_X_X_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN9@PMC_ModPow

; 618  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_ModPow
$LN9@PMC_ModPow:

; 619  : #ifdef _DEBUG
; 620  :     if ((result = CheckNumber(*r)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN10@PMC_ModPow

; 621  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_ModPow
$LN10@PMC_ModPow:

; 622  : #endif
; 623  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_ModPow:

; 624  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
PMC_ModPow_X_X_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_modpow.c
;	COMDAT Initialize_ModPow
_TEXT	SEGMENT
feature$ = 224
Initialize_ModPow PROC					; COMDAT

; 627  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__54B479F5_pmc_modpow@c
	call	__CheckForDebuggerJustMyCode

; 628  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 629  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Initialize_ModPow ENDP
_TEXT	ENDS
END
