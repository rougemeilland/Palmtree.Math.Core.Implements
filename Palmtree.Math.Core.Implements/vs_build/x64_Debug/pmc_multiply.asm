; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__4522B509_pmc_internal@h DB 01H
__C53FCF4E_pmc_multiply@c DB 01H
msvcjmc	ENDS
PUBLIC	Multiply_X_X_Imp
PUBLIC	Initialize_Multiply
PUBLIC	PMC_Multiply_I_X
PUBLIC	PMC_Multiply_L_X
PUBLIC	PMC_Multiply_X_I
PUBLIC	PMC_Multiply_X_L
PUBLIC	PMC_Multiply_X_X
PUBLIC	__JustMyCode_Default
EXTRN	CheckBlockLight:PROC
EXTRN	AllocateNumber:PROC
EXTRN	CommitNumber:PROC
EXTRN	CheckNumber:PROC
EXTRN	DuplicateNumber:PROC
EXTRN	From_I_Imp:PROC
EXTRN	From_L_Imp:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	number_zero:BYTE
EXTRN	statistics_info:BYTE
_BSS	SEGMENT
fp_Multiply_X_1W DQ 01H DUP (?)
fp_Multiply_X_2W DQ 01H DUP (?)
fp_Multiply_X_X DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Multiply_X_X_Imp DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$Multiply_X_X_Imp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Initialize_Multiply DD imagerel $LN5
	DD	imagerel $LN5+189
	DD	imagerel $unwind$Initialize_Multiply
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Multiply_I_X DD imagerel $LN9
	DD	imagerel $LN9+218
	DD	imagerel $unwind$PMC_Multiply_I_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Multiply_L_X DD imagerel $LN9
	DD	imagerel $LN9+221
	DD	imagerel $unwind$PMC_Multiply_L_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Multiply_X_I DD imagerel $LN9
	DD	imagerel $LN9+219
	DD	imagerel $unwind$PMC_Multiply_X_I
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Multiply_X_L DD imagerel $LN9
	DD	imagerel $LN9+221
	DD	imagerel $unwind$PMC_Multiply_X_L
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Multiply_X_X DD imagerel $LN23
	DD	imagerel $LN23+689
	DD	imagerel $unwind$PMC_Multiply_X_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FROMDWORDTOWORD DD imagerel _FROMDWORDTOWORD
	DD	imagerel _FROMDWORDTOWORD+95
	DD	imagerel $unwind$_FROMDWORDTOWORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_UNIT DD imagerel _ADD_UNIT
	DD	imagerel _ADD_UNIT+118
	DD	imagerel $unwind$_ADD_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADDX_UNIT DD imagerel _ADDX_UNIT
	DD	imagerel _ADDX_UNIT+121
	DD	imagerel $unwind$_ADDX_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MULTIPLY_UNIT DD imagerel _MULTIPLY_UNIT
	DD	imagerel _MULTIPLY_UNIT+118
	DD	imagerel $unwind$_MULTIPLY_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MULTIPLYX_UNIT DD imagerel _MULTIPLYX_UNIT
	DD	imagerel _MULTIPLYX_UNIT+103
	DD	imagerel $unwind$_MULTIPLYX_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_LZCNT_ALT_32 DD imagerel _LZCNT_ALT_32
	DD	imagerel _LZCNT_ALT_32+126
	DD	imagerel $unwind$_LZCNT_ALT_32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_LZCNT_ALT_UNIT DD imagerel _LZCNT_ALT_UNIT
	DD	imagerel _LZCNT_ALT_UNIT+131
	DD	imagerel $unwind$_LZCNT_ALT_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncrementMULTI32Counter DD imagerel IncrementMULTI32Counter
	DD	imagerel IncrementMULTI32Counter+62
	DD	imagerel $unwind$IncrementMULTI32Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncrementMULTI64Counter DD imagerel IncrementMULTI64Counter
	DD	imagerel IncrementMULTI64Counter+62
	DD	imagerel $unwind$IncrementMULTI64Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddToMULTI32Counter DD imagerel AddToMULTI32Counter
	DD	imagerel AddToMULTI32Counter+78
	DD	imagerel $unwind$AddToMULTI32Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddToMULTI64Counter DD imagerel AddToMULTI64Counter
	DD	imagerel AddToMULTI64Counter+78
	DD	imagerel $unwind$AddToMULTI64Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MULTIPLY_DIGIT_UNIT DD imagerel _MULTIPLY_DIGIT_UNIT
	DD	imagerel _MULTIPLY_DIGIT_UNIT+248
	DD	imagerel $unwind$_MULTIPLY_DIGIT_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MULTIPLYX_DIGIT_UNIT DD imagerel _MULTIPLYX_DIGIT_UNIT
	DD	imagerel _MULTIPLYX_DIGIT_UNIT+248
	DD	imagerel $unwind$_MULTIPLYX_DIGIT_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Multiply_WORD_using_MUL_ADC DD imagerel Multiply_WORD_using_MUL_ADC
	DD	imagerel Multiply_WORD_using_MUL_ADC+5040
	DD	imagerel $unwind$Multiply_WORD_using_MUL_ADC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Multiply_WORD_using_MULX_ADCX DD imagerel Multiply_WORD_using_MULX_ADCX
	DD	imagerel Multiply_WORD_using_MULX_ADCX+5040
	DD	imagerel $unwind$Multiply_WORD_using_MULX_ADCX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Multiply_X_1W_using_MUL_ADC DD imagerel Multiply_X_1W_using_MUL_ADC
	DD	imagerel Multiply_X_1W_using_MUL_ADC+112
	DD	imagerel $unwind$Multiply_X_1W_using_MUL_ADC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Multiply_X_1W_using_MULX_ADCX DD imagerel Multiply_X_1W_using_MULX_ADCX
	DD	imagerel Multiply_X_1W_using_MULX_ADCX+112
	DD	imagerel $unwind$Multiply_X_1W_using_MULX_ADCX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Multiply_X_2W_using_MUL_ADC DD imagerel Multiply_X_2W_using_MUL_ADC
	DD	imagerel Multiply_X_2W_using_MUL_ADC+181
	DD	imagerel $unwind$Multiply_X_2W_using_MUL_ADC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Multiply_X_2W_using_MULX_ADCX DD imagerel Multiply_X_2W_using_MULX_ADCX
	DD	imagerel Multiply_X_2W_using_MULX_ADCX+181
	DD	imagerel $unwind$Multiply_X_2W_using_MULX_ADCX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Multiply_X_X_using_MUL_ADC DD imagerel Multiply_X_X_using_MUL_ADC
	DD	imagerel Multiply_X_X_using_MUL_ADC+290
	DD	imagerel $unwind$Multiply_X_X_using_MUL_ADC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Multiply_X_X_using_MULX_ADCX DD imagerel Multiply_X_X_using_MULX_ADCX
	DD	imagerel Multiply_X_X_using_MULX_ADCX+290
	DD	imagerel $unwind$Multiply_X_X_using_MULX_ADCX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Multiply_X_I_Imp DD imagerel PMC_Multiply_X_I_Imp
	DD	imagerel PMC_Multiply_X_I_Imp+511
	DD	imagerel $unwind$PMC_Multiply_X_I_Imp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Multiply_X_L_Imp DD imagerel PMC_Multiply_X_L_Imp
	DD	imagerel PMC_Multiply_X_L_Imp+995
	DD	imagerel $unwind$PMC_Multiply_X_L_Imp
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Multiply_X_L_Imp DD 035053401H
	DD	0118331dH
	DD	070110057H
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_Multiply_X_L_Imp$rtcName$0 DB 079H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+3
PMC_Multiply_X_L_Imp$rtcName$1 DB 06eH
	DB	07aH
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_Multiply_X_L_Imp$rtcName$2 DB 06eH
	DB	07aH
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_Multiply_X_L_Imp$rtcName$3 DB 06eH
	DB	07aH
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_Multiply_X_L_Imp$rtcVarDesc DD 01d8H
	DD	08H
	DQ	FLAT:PMC_Multiply_X_L_Imp$rtcName$3
	DD	0158H
	DD	08H
	DQ	FLAT:PMC_Multiply_X_L_Imp$rtcName$2
	DD	0f8H
	DD	08H
	DQ	FLAT:PMC_Multiply_X_L_Imp$rtcName$1
	DD	074H
	DD	04H
	DQ	FLAT:PMC_Multiply_X_L_Imp$rtcName$0
	ORG $+192
PMC_Multiply_X_L_Imp$rtcFrameData DD 04H
	DD	00H
	DQ	FLAT:PMC_Multiply_X_L_Imp$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Multiply_X_I_Imp DD 025053301H
	DD	0117231cH
	DD	070100031H
	DD	0500fH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_Multiply_X_I_Imp$rtcName$0 DB 077H
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+13
PMC_Multiply_X_I_Imp$rtcVarDesc DD 0a8H
	DD	08H
	DQ	FLAT:PMC_Multiply_X_I_Imp$rtcName$0
	ORG $+48
PMC_Multiply_X_I_Imp$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:PMC_Multiply_X_I_Imp$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Multiply_X_X_using_MULX_ADCX DD 025053901H
	DD	011d2322H
	DD	070160031H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Multiply_X_X_using_MUL_ADC DD 025053901H
	DD	011d2322H
	DD	070160031H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Multiply_X_2W_using_MULX_ADCX DD 025053901H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Multiply_X_2W_using_MUL_ADC DD 025053901H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Multiply_X_1W_using_MULX_ADCX DD 025053901H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Multiply_X_1W_using_MUL_ADC DD 025053901H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Multiply_WORD_using_MULX_ADCX DD 025053901H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Multiply_WORD_using_MUL_ADC DD 025053901H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MULTIPLYX_DIGIT_UNIT DD 025053901H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_MULTIPLYX_DIGIT_UNIT$rtcName$0 DB 074H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+3
_MULTIPLYX_DIGIT_UNIT$rtcName$1 DB 074H
	DB	05fH
	DB	06cH
	DB	06fH
	DB	00H
	ORG $+3
_MULTIPLYX_DIGIT_UNIT$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:_MULTIPLYX_DIGIT_UNIT$rtcName$1
	DD	028H
	DD	08H
	DQ	FLAT:_MULTIPLYX_DIGIT_UNIT$rtcName$0
	ORG $+96
_MULTIPLYX_DIGIT_UNIT$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:_MULTIPLYX_DIGIT_UNIT$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MULTIPLY_DIGIT_UNIT DD 025053901H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_MULTIPLY_DIGIT_UNIT$rtcName$0 DB 074H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+3
_MULTIPLY_DIGIT_UNIT$rtcName$1 DB 074H
	DB	05fH
	DB	06cH
	DB	06fH
	DB	00H
	ORG $+3
_MULTIPLY_DIGIT_UNIT$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:_MULTIPLY_DIGIT_UNIT$rtcName$1
	DD	028H
	DD	08H
	DQ	FLAT:_MULTIPLY_DIGIT_UNIT$rtcName$0
	ORG $+96
_MULTIPLY_DIGIT_UNIT$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:_MULTIPLY_DIGIT_UNIT$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddToMULTI64Counter DD 025052801H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddToMULTI32Counter DD 025052801H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncrementMULTI64Counter DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncrementMULTI32Counter DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_LZCNT_ALT_UNIT DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_LZCNT_ALT_UNIT$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+12
_LZCNT_ALT_UNIT$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:_LZCNT_ALT_UNIT$rtcName$0
	ORG $+48
_LZCNT_ALT_UNIT$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_LZCNT_ALT_UNIT$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_LZCNT_ALT_32 DD 025052801H
	DD	010d2312H
	DD	070060021H
	DD	05005H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_LZCNT_ALT_32$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+12
_LZCNT_ALT_32$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:_LZCNT_ALT_32$rtcName$0
	ORG $+48
_LZCNT_ALT_32$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_LZCNT_ALT_32$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MULTIPLYX_UNIT DD 025053401H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MULTIPLY_UNIT DD 025053401H
	DD	0118231dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADDX_UNIT DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_UNIT DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FROMDWORDTOWORD DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Multiply_X_X DD 035053401H
	DD	0118331dH
	DD	07011003fH
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_Multiply_X_X$rtcName$0 DB 06eH
	DB	077H
	DB	00H
	ORG $+5
PMC_Multiply_X_X$rtcName$1 DB 077H
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+5
PMC_Multiply_X_X$rtcVarDesc DD 0118H
	DD	08H
	DQ	FLAT:PMC_Multiply_X_X$rtcName$1
	DD	098H
	DD	08H
	DQ	FLAT:PMC_Multiply_X_X$rtcName$0
	ORG $+96
PMC_Multiply_X_X$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:PMC_Multiply_X_X$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Multiply_X_L DD 025053401H
	DD	0118231dH
	DD	070110021H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Multiply_X_I DD 025053301H
	DD	0117231cH
	DD	070100021H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Multiply_L_X DD 025053401H
	DD	0118231dH
	DD	070110021H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Multiply_I_X DD 025053201H
	DD	0117231cH
	DD	070100021H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Initialize_Multiply DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Multiply_X_X_Imp DD 035053901H
	DD	011d3322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT PMC_Multiply_X_L_Imp
_TEXT	SEGMENT
result$ = 4
x_bit_count$7 = 40
y_hi$8 = 68
y_lo$9 = 100
y_bit_count$10 = 136
z_bit_count$11 = 168
nz_light_check_code$12 = 200
y_bit_count$13 = 232
z_bit_count$14 = 264
nz_light_check_code$15 = 296
x_bit_count$16 = 328
y_bit_count$17 = 360
z_bit_count$18 = 392
nz_light_check_code$19 = 424
u$ = 672
v$ = 680
w$ = 688
PMC_Multiply_X_L_Imp PROC				; COMDAT

; 552  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 696				; 000002b8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 174				; 000000aeH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+728]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 553  :     PMC_STATUS_CODE result;
; 554  :     if (u->IS_ZERO)

	mov	rax, QWORD PTR u$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@PMC_Multip

; 555  :     {
; 556  :         // x が 0 である場合
; 557  : 
; 558  :         // y の値にかかわらず 0 を返す。
; 559  :         *w = &number_zero;

	mov	rax, QWORD PTR w$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 560  :     }

	jmp	$LN3@PMC_Multip
$LN2@PMC_Multip:

; 561  :     else if (u->IS_ONE)

	mov	rax, QWORD PTR u$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@PMC_Multip

; 562  :     {
; 563  :         // x が 1 である場合
; 564  :         if (v == 0)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN6@PMC_Multip

; 565  :         {
; 566  :             // y が 0 である場合
; 567  : 
; 568  :             //  0  を返す。
; 569  :             *w = &number_zero;

	mov	rax, QWORD PTR w$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 570  :         }

	jmp	SHORT $LN7@PMC_Multip
$LN6@PMC_Multip:

; 571  :         else
; 572  :         {
; 573  :             // y が 0 ではない場合
; 574  : 
; 575  :             // 乗算結果は y に等しいため、y の値を持つ NUMBER_HEADER 構造体を獲得し、呼び出し元へ返す。
; 576  :             if ((result = From_L_Imp(v, w)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	call	From_L_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN8@PMC_Multip

; 577  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN8@PMC_Multip:
$LN7@PMC_Multip:

; 578  :         }
; 579  :     }

	jmp	$LN5@PMC_Multip
$LN4@PMC_Multip:

; 580  :     else
; 581  :     {
; 582  :         // x が 0 と 1 のどちらでもない場合
; 583  : 
; 584  :         if (v == 0)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN9@PMC_Multip

; 585  :         {
; 586  :             // y が 0 である場合
; 587  : 
; 588  :             //  0  を返す。
; 589  :             *w = &number_zero;

	mov	rax, QWORD PTR w$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 590  :         }

	jmp	$LN10@PMC_Multip
$LN9@PMC_Multip:

; 591  :         else if (v == 1)

	cmp	QWORD PTR v$[rbp], 1
	jne	SHORT $LN11@PMC_Multip

; 592  :         {
; 593  :             // y が 1 である場合
; 594  : 
; 595  :             // 乗算結果は x に等しいため、x の値を持つ NUMBER_HEADER 構造体を獲得し、呼び出し元へ返す。
; 596  :             if ((result = DuplicateNumber(u, w)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN13@PMC_Multip

; 597  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN13@PMC_Multip:

; 598  :         }

	jmp	$LN12@PMC_Multip
$LN11@PMC_Multip:

; 599  :         else
; 600  :         {
; 601  :             // x と y がともに 0 、1 のどちらでもない場合
; 602  : 
; 603  :             // x と y の積を計算する
; 604  :             if (__UNIT_TYPE_BIT_COUNT < sizeof(v) * 8)

	xor	eax, eax
	test	eax, eax
	je	$LN14@PMC_Multip

; 605  :             {
; 606  :                 // _UINT64_T が 1 ワードで表現しきれない場合
; 607  : 
; 608  :                 __UNIT_TYPE x_bit_count = u->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR u$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x_bit_count$7[rbp], rax

; 609  :                 _UINT32_T y_hi;
; 610  :                 _UINT32_T y_lo = _FROMDWORDTOWORD(v, &y_hi);

	lea	rdx, QWORD PTR y_hi$8[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	call	_FROMDWORDTOWORD
	mov	DWORD PTR y_lo$9[rbp], eax

; 611  :                 if (y_hi == 0)

	cmp	DWORD PTR y_hi$8[rbp], 0
	jne	$LN16@PMC_Multip

; 612  :                 {
; 613  :                     // y の値が 32bit で表現可能な場合
; 614  :                     __UNIT_TYPE y_bit_count = sizeof(y_lo) * 8 - _LZCNT_ALT_32(y_lo);

	mov	ecx, DWORD PTR y_lo$9[rbp]
	call	_LZCNT_ALT_32
	cdqe
	mov	ecx, 32					; 00000020H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR y_bit_count$10[rbp], rax

; 615  :                     __UNIT_TYPE z_bit_count = x_bit_count + y_bit_count;

	mov	rax, QWORD PTR y_bit_count$10[rbp]
	mov	rcx, QWORD PTR x_bit_count$7[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR z_bit_count$11[rbp], rax

; 616  :                     __UNIT_TYPE nz_light_check_code;
; 617  :                     if ((result = AllocateNumber(w, z_bit_count, &nz_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nz_light_check_code$12[rbp]
	mov	rdx, QWORD PTR z_bit_count$11[rbp]
	mov	rcx, QWORD PTR w$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN18@PMC_Multip

; 618  :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN18@PMC_Multip:

; 619  :                     (*fp_Multiply_X_1W)(u->BLOCK, u->UNIT_WORD_COUNT, y_lo, (*w)->BLOCK);

	mov	rax, QWORD PTR w$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR y_lo$9[rbp]
	mov	r9, QWORD PTR [rax+56]
	mov	r8d, ecx
	mov	rax, QWORD PTR u$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	QWORD PTR fp_Multiply_X_1W

; 620  :                     if ((result = CheckBlockLight((*w)->BLOCK, nz_light_check_code)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR w$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR nz_light_check_code$12[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN19@PMC_Multip

; 621  :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN19@PMC_Multip:

; 622  :                 }

	jmp	$LN17@PMC_Multip
$LN16@PMC_Multip:

; 623  :                 else
; 624  :                 {
; 625  :                     // y の値が 32bit では表現できない場合
; 626  :                     __UNIT_TYPE y_bit_count = sizeof(v) * 8 - _LZCNT_ALT_32(y_hi);

	mov	ecx, DWORD PTR y_hi$8[rbp]
	call	_LZCNT_ALT_32
	cdqe
	mov	ecx, 64					; 00000040H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR y_bit_count$13[rbp], rax

; 627  :                     __UNIT_TYPE z_bit_count = x_bit_count + y_bit_count;

	mov	rax, QWORD PTR y_bit_count$13[rbp]
	mov	rcx, QWORD PTR x_bit_count$7[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR z_bit_count$14[rbp], rax

; 628  :                     __UNIT_TYPE nz_light_check_code;
; 629  :                     if ((result = AllocateNumber(w, z_bit_count, &nz_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nz_light_check_code$15[rbp]
	mov	rdx, QWORD PTR z_bit_count$14[rbp]
	mov	rcx, QWORD PTR w$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN20@PMC_Multip

; 630  :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN20@PMC_Multip:

; 631  :                     (*fp_Multiply_X_2W)(u->BLOCK, u->UNIT_WORD_COUNT, y_hi, y_lo, (*w)->BLOCK);

	mov	rax, QWORD PTR w$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR y_lo$9[rbp]
	mov	edx, DWORD PTR y_hi$8[rbp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, ecx
	mov	r8d, edx
	mov	rax, QWORD PTR u$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	QWORD PTR fp_Multiply_X_2W

; 632  :                     if ((result = CheckBlockLight((*w)->BLOCK, nz_light_check_code)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR w$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR nz_light_check_code$15[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN21@PMC_Multip

; 633  :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN21@PMC_Multip:
$LN17@PMC_Multip:

; 634  :                 }
; 635  :                 CommitNumber(*w);

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CommitNumber

; 636  :             }

	jmp	$LN15@PMC_Multip
$LN14@PMC_Multip:

; 637  :             else
; 638  :             {
; 639  :                 // _UINT64_T が 1 ワードで表現できる場合
; 640  : 
; 641  :                 __UNIT_TYPE x_bit_count = u->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR u$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x_bit_count$16[rbp], rax

; 642  :                 __UNIT_TYPE y_bit_count = sizeof(v) * 8 - _LZCNT_ALT_UNIT((__UNIT_TYPE)v);

	mov	rcx, QWORD PTR v$[rbp]
	call	_LZCNT_ALT_UNIT
	cdqe
	mov	ecx, 64					; 00000040H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR y_bit_count$17[rbp], rax

; 643  :                 __UNIT_TYPE z_bit_count = x_bit_count + y_bit_count;

	mov	rax, QWORD PTR y_bit_count$17[rbp]
	mov	rcx, QWORD PTR x_bit_count$16[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR z_bit_count$18[rbp], rax

; 644  :                 __UNIT_TYPE nz_light_check_code;
; 645  :                 if ((result = AllocateNumber(w, z_bit_count, &nz_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nz_light_check_code$19[rbp]
	mov	rdx, QWORD PTR z_bit_count$18[rbp]
	mov	rcx, QWORD PTR w$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN22@PMC_Multip

; 646  :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN22@PMC_Multip:

; 647  :                 (*fp_Multiply_X_1W)(u->BLOCK, u->UNIT_WORD_COUNT, (__UNIT_TYPE)v, (*w)->BLOCK);

	mov	rax, QWORD PTR w$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	r9, QWORD PTR [rax+56]
	mov	r8, QWORD PTR v$[rbp]
	mov	rax, QWORD PTR u$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	QWORD PTR fp_Multiply_X_1W

; 648  :                 if ((result = CheckBlockLight((*w)->BLOCK, nz_light_check_code)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR w$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR nz_light_check_code$19[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN23@PMC_Multip

; 649  :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN23@PMC_Multip:

; 650  :                 CommitNumber(*w);

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CommitNumber
$LN15@PMC_Multip:
$LN12@PMC_Multip:
$LN10@PMC_Multip:
$LN5@PMC_Multip:
$LN3@PMC_Multip:

; 651  :             }
; 652  :         }
; 653  :     }
; 654  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Multip:

; 655  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:PMC_Multiply_X_L_Imp$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+648]
	pop	rdi
	pop	rbp
	ret	0
PMC_Multiply_X_L_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT PMC_Multiply_X_I_Imp
_TEXT	SEGMENT
result$ = 4
u_bit_count$4 = 40
v_bit_count$5 = 72
w_bit_count$6 = 104
w_light_check_code$7 = 136
u$ = 384
v$ = 392
w$ = 400
PMC_Multiply_X_I_Imp PROC				; COMDAT

; 438  : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 98					; 00000062H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+424]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 439  :     PMC_STATUS_CODE result;
; 440  :     if (u->IS_ZERO)

	mov	rax, QWORD PTR u$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@PMC_Multip

; 441  :     {
; 442  :         // u が 0 である場合
; 443  : 
; 444  :         // v の値にかかわらず 0 を返す。
; 445  :         *w = &number_zero;

	mov	rax, QWORD PTR w$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 446  :     }

	jmp	$LN3@PMC_Multip
$LN2@PMC_Multip:

; 447  :     else if (u->IS_ONE)

	mov	rax, QWORD PTR u$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@PMC_Multip

; 448  :     {
; 449  :         // u が 1 である場合
; 450  :         if (v == 0)

	cmp	DWORD PTR v$[rbp], 0
	jne	SHORT $LN6@PMC_Multip

; 451  :         {
; 452  :             // v が 0 である場合
; 453  : 
; 454  :             //  0  を返す。
; 455  :             *w = &number_zero;

	mov	rax, QWORD PTR w$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 456  :         }

	jmp	SHORT $LN7@PMC_Multip
$LN6@PMC_Multip:

; 457  :         else
; 458  :         {
; 459  :             // y が 0 ではない場合
; 460  : 
; 461  :             // 乗算結果は v に等しいため、v の値を持つ NUMBER_HEADER 構造体を獲得し、呼び出し元へ返す。
; 462  :             if ((result = From_I_Imp(v, w)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR w$[rbp]
	mov	ecx, DWORD PTR v$[rbp]
	call	From_I_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN8@PMC_Multip

; 463  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN8@PMC_Multip:
$LN7@PMC_Multip:

; 464  :         }
; 465  :     }

	jmp	$LN5@PMC_Multip
$LN4@PMC_Multip:

; 466  :     else
; 467  :     {
; 468  :         // u が 0 と 1 のどちらでもない場合
; 469  : 
; 470  :         if (v == 0)

	cmp	DWORD PTR v$[rbp], 0
	jne	SHORT $LN9@PMC_Multip

; 471  :         {
; 472  :             // v が 0 である場合
; 473  : 
; 474  :             //  0  を返す。
; 475  :             *w = &number_zero;

	mov	rax, QWORD PTR w$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 476  :         }

	jmp	$LN10@PMC_Multip
$LN9@PMC_Multip:

; 477  :         else if (v == 1)

	cmp	DWORD PTR v$[rbp], 1
	jne	SHORT $LN11@PMC_Multip

; 478  :         {
; 479  :             // v が 1 である場合
; 480  : 
; 481  :             // 乗算結果は u に等しいため、u の値を持つ NUMBER_HEADER 構造体を獲得し、呼び出し元へ返す。
; 482  :             if ((result = DuplicateNumber(u, w)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN13@PMC_Multip

; 483  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN13@PMC_Multip:

; 484  :         }

	jmp	$LN12@PMC_Multip
$LN11@PMC_Multip:

; 485  :         else
; 486  :         {
; 487  :             // u と v がともに 0 、1 のどちらでもない場合
; 488  : 
; 489  :             // u と v の積を計算する
; 490  :             __UNIT_TYPE u_bit_count = u->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR u$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR u_bit_count$4[rbp], rax

; 491  :             __UNIT_TYPE v_bit_count = sizeof(v) * 8 - _LZCNT_ALT_32(v);

	mov	ecx, DWORD PTR v$[rbp]
	call	_LZCNT_ALT_32
	cdqe
	mov	ecx, 32					; 00000020H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_bit_count$5[rbp], rax

; 492  :             __UNIT_TYPE w_bit_count = u_bit_count + v_bit_count;

	mov	rax, QWORD PTR v_bit_count$5[rbp]
	mov	rcx, QWORD PTR u_bit_count$4[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR w_bit_count$6[rbp], rax

; 493  :             __UNIT_TYPE w_light_check_code;
; 494  :             if ((result = AllocateNumber(w, w_bit_count, &w_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR w_light_check_code$7[rbp]
	mov	rdx, QWORD PTR w_bit_count$6[rbp]
	mov	rcx, QWORD PTR w$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN14@PMC_Multip

; 495  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN14@PMC_Multip:

; 496  :             (*fp_Multiply_X_1W)(u->BLOCK, u->UNIT_WORD_COUNT, v, (*w)->BLOCK);

	mov	rax, QWORD PTR w$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR v$[rbp]
	mov	r9, QWORD PTR [rax+56]
	mov	r8d, ecx
	mov	rax, QWORD PTR u$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	QWORD PTR fp_Multiply_X_1W

; 497  :             if ((result = CheckBlockLight((*w)->BLOCK, w_light_check_code)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR w$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR w_light_check_code$7[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN15@PMC_Multip

; 498  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN15@PMC_Multip:

; 499  :             CommitNumber(*w);

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CommitNumber
$LN12@PMC_Multip:
$LN10@PMC_Multip:
$LN5@PMC_Multip:
$LN3@PMC_Multip:

; 500  :         }
; 501  :     }
; 502  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Multip:

; 503  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:PMC_Multiply_X_I_Imp$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
PMC_Multiply_X_I_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT Multiply_X_X_using_MULX_ADCX
_TEXT	SEGMENT
t_buf$1 = 8
t_count$2 = 40
up$ = 72
vp$ = 104
wp$ = 136
u_buf$ = 384
u_count$ = 392
v_buf$ = 400
v_count$ = 408
w_buf$ = 416
Multiply_X_X_using_MULX_ADCX PROC			; COMDAT

; 413  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 98					; 00000062H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+424]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 414  :     // x のワード長が y のワード長以上であるようにする
; 415  :     if (u_count < v_count)

	mov	rax, QWORD PTR v_count$[rbp]
	cmp	QWORD PTR u_count$[rbp], rax
	jae	SHORT $LN5@Multiply_X

; 416  :     {
; 417  :         __UNIT_TYPE* t_buf = u_buf;

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	QWORD PTR t_buf$1[rbp], rax

; 418  :         u_buf = v_buf;

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	QWORD PTR u_buf$[rbp], rax

; 419  :         v_buf = t_buf;

	mov	rax, QWORD PTR t_buf$1[rbp]
	mov	QWORD PTR v_buf$[rbp], rax

; 420  :         __UNIT_TYPE t_count = u_count;

	mov	rax, QWORD PTR u_count$[rbp]
	mov	QWORD PTR t_count$2[rbp], rax

; 421  :         u_count = v_count;

	mov	rax, QWORD PTR v_count$[rbp]
	mov	QWORD PTR u_count$[rbp], rax

; 422  :         v_count = t_count;

	mov	rax, QWORD PTR t_count$2[rbp]
	mov	QWORD PTR v_count$[rbp], rax
$LN5@Multiply_X:

; 423  :     }
; 424  :     __UNIT_TYPE* up = u_buf;

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	QWORD PTR up$[rbp], rax

; 425  :     __UNIT_TYPE* vp = v_buf;

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	QWORD PTR vp$[rbp], rax

; 426  :     __UNIT_TYPE* wp = w_buf;

	mov	rax, QWORD PTR w_buf$[rbp]
	mov	QWORD PTR wp$[rbp], rax
$LN4@Multiply_X:

; 427  : 
; 428  :     do
; 429  :     {
; 430  :         Multiply_WORD_using_MULX_ADCX(up, u_count, *vp, wp);

	mov	r9, QWORD PTR wp$[rbp]
	mov	rax, QWORD PTR vp$[rbp]
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR up$[rbp]
	call	Multiply_WORD_using_MULX_ADCX

; 431  :         ++vp;

	mov	rax, QWORD PTR vp$[rbp]
	add	rax, 8
	mov	QWORD PTR vp$[rbp], rax

; 432  :         ++wp;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 8
	mov	QWORD PTR wp$[rbp], rax

; 433  :         --v_count;

	mov	rax, QWORD PTR v_count$[rbp]
	dec	rax
	mov	QWORD PTR v_count$[rbp], rax

; 434  :     } while (v_count != 0);

	cmp	QWORD PTR v_count$[rbp], 0
	jne	SHORT $LN4@Multiply_X

; 435  : }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
Multiply_X_X_using_MULX_ADCX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT Multiply_X_X_using_MUL_ADC
_TEXT	SEGMENT
t_buf$1 = 8
t_count$2 = 40
up$ = 72
vp$ = 104
wp$ = 136
u_buf$ = 384
u_count$ = 392
v_buf$ = 400
v_count$ = 408
w_buf$ = 416
Multiply_X_X_using_MUL_ADC PROC				; COMDAT

; 388  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 98					; 00000062H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+424]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 389  :     // x のワード長が y のワード長以上であるようにする
; 390  :     if (u_count < v_count)

	mov	rax, QWORD PTR v_count$[rbp]
	cmp	QWORD PTR u_count$[rbp], rax
	jae	SHORT $LN5@Multiply_X

; 391  :     {
; 392  :         __UNIT_TYPE* t_buf = u_buf;

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	QWORD PTR t_buf$1[rbp], rax

; 393  :         u_buf = v_buf;

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	QWORD PTR u_buf$[rbp], rax

; 394  :         v_buf = t_buf;

	mov	rax, QWORD PTR t_buf$1[rbp]
	mov	QWORD PTR v_buf$[rbp], rax

; 395  :         __UNIT_TYPE t_count = u_count;

	mov	rax, QWORD PTR u_count$[rbp]
	mov	QWORD PTR t_count$2[rbp], rax

; 396  :         u_count = v_count;

	mov	rax, QWORD PTR v_count$[rbp]
	mov	QWORD PTR u_count$[rbp], rax

; 397  :         v_count = t_count;

	mov	rax, QWORD PTR t_count$2[rbp]
	mov	QWORD PTR v_count$[rbp], rax
$LN5@Multiply_X:

; 398  :     }
; 399  :     __UNIT_TYPE* up = u_buf;

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	QWORD PTR up$[rbp], rax

; 400  :     __UNIT_TYPE* vp = v_buf;

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	QWORD PTR vp$[rbp], rax

; 401  :     __UNIT_TYPE* wp = w_buf;

	mov	rax, QWORD PTR w_buf$[rbp]
	mov	QWORD PTR wp$[rbp], rax
$LN4@Multiply_X:

; 402  : 
; 403  :     do
; 404  :     {
; 405  :         Multiply_WORD_using_MUL_ADC(up, u_count, *vp, wp);

	mov	r9, QWORD PTR wp$[rbp]
	mov	rax, QWORD PTR vp$[rbp]
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR up$[rbp]
	call	Multiply_WORD_using_MUL_ADC

; 406  :         ++vp;

	mov	rax, QWORD PTR vp$[rbp]
	add	rax, 8
	mov	QWORD PTR vp$[rbp], rax

; 407  :         ++wp;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 8
	mov	QWORD PTR wp$[rbp], rax

; 408  :         --v_count;

	mov	rax, QWORD PTR v_count$[rbp]
	dec	rax
	mov	QWORD PTR v_count$[rbp], rax

; 409  :     } while (v_count != 0);

	cmp	QWORD PTR v_count$[rbp], 0
	jne	SHORT $LN4@Multiply_X

; 410  : }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
Multiply_X_X_using_MUL_ADC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT Multiply_X_2W_using_MULX_ADCX
_TEXT	SEGMENT
u_buf$ = 224
u_count$ = 232
v_hi$ = 240
v_lo$ = 248
w_buf$ = 256
Multiply_X_2W_using_MULX_ADCX PROC			; COMDAT

; 382  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 383  :     Multiply_WORD_using_MULX_ADCX(u_buf, u_count, v_lo, &w_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR w_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, rax
	mov	r8, QWORD PTR v_lo$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u_buf$[rbp]
	call	Multiply_WORD_using_MULX_ADCX

; 384  :     Multiply_WORD_using_MULX_ADCX(u_buf, u_count, v_hi, &w_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR w_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, rax
	mov	r8, QWORD PTR v_hi$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u_buf$[rbp]
	call	Multiply_WORD_using_MULX_ADCX

; 385  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Multiply_X_2W_using_MULX_ADCX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT Multiply_X_2W_using_MUL_ADC
_TEXT	SEGMENT
u_buf$ = 224
u_count$ = 232
v_hi$ = 240
v_lo$ = 248
w_buf$ = 256
Multiply_X_2W_using_MUL_ADC PROC			; COMDAT

; 376  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 377  :     Multiply_WORD_using_MUL_ADC(u_buf, u_count, v_lo, &w_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR w_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, rax
	mov	r8, QWORD PTR v_lo$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u_buf$[rbp]
	call	Multiply_WORD_using_MUL_ADC

; 378  :     Multiply_WORD_using_MUL_ADC(u_buf, u_count, v_hi, &w_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR w_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, rax
	mov	r8, QWORD PTR v_hi$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u_buf$[rbp]
	call	Multiply_WORD_using_MUL_ADC

; 379  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Multiply_X_2W_using_MUL_ADC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT Multiply_X_1W_using_MULX_ADCX
_TEXT	SEGMENT
u_buf$ = 224
u_count$ = 232
v$ = 240
w_buf$ = 248
Multiply_X_1W_using_MULX_ADCX PROC			; COMDAT

; 371  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 372  :     Multiply_WORD_using_MULX_ADCX(u_buf, u_count, v, w_buf);

	mov	r9, QWORD PTR w_buf$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u_buf$[rbp]
	call	Multiply_WORD_using_MULX_ADCX

; 373  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Multiply_X_1W_using_MULX_ADCX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT Multiply_X_1W_using_MUL_ADC
_TEXT	SEGMENT
u_buf$ = 224
u_count$ = 232
v$ = 240
w_buf$ = 248
Multiply_X_1W_using_MUL_ADC PROC			; COMDAT

; 366  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 367  :     Multiply_WORD_using_MUL_ADC(u_buf, u_count, v, w_buf);

	mov	r9, QWORD PTR w_buf$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u_buf$[rbp]
	call	Multiply_WORD_using_MUL_ADC

; 368  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Multiply_X_1W_using_MUL_ADC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT Multiply_WORD_using_MULX_ADCX
_TEXT	SEGMENT
k$ = 8
count$ = 40
up$ = 288
u_count$ = 296
v$ = 304
wp$ = 312
Multiply_WORD_using_MULX_ADCX PROC			; COMDAT

; 218  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 219  :     __UNIT_TYPE k = 0;

	mov	QWORD PTR k$[rbp], 0

; 220  :     __UNIT_TYPE count = u_count >> 5;

	mov	rax, QWORD PTR u_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@Multiply_W:

; 221  : 
; 222  :     while (count != 0)

	cmp	QWORD PTR count$[rbp], 0
	je	$LN3@Multiply_W

; 223  :     {
; 224  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 225  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[1], v, &wp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 226  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[2], v, &wp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 227  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[3], v, &wp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 228  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[4], v, &wp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 229  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[5], v, &wp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 230  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[6], v, &wp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 231  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[7], v, &wp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 232  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[8], v, &wp[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 233  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[9], v, &wp[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 234  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[10], v, &wp[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 235  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[11], v, &wp[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 236  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[12], v, &wp[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 237  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[13], v, &wp[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 238  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[14], v, &wp[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 239  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[15], v, &wp[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 240  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[16], v, &wp[16]);

	mov	eax, 8
	imul	rax, rax, 16
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 241  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[17], v, &wp[17]);

	mov	eax, 8
	imul	rax, rax, 17
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 17
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 242  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[18], v, &wp[18]);

	mov	eax, 8
	imul	rax, rax, 18
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 18
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 243  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[19], v, &wp[19]);

	mov	eax, 8
	imul	rax, rax, 19
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 19
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 244  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[20], v, &wp[20]);

	mov	eax, 8
	imul	rax, rax, 20
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 245  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[21], v, &wp[21]);

	mov	eax, 8
	imul	rax, rax, 21
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 21
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 246  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[22], v, &wp[22]);

	mov	eax, 8
	imul	rax, rax, 22
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 247  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[23], v, &wp[23]);

	mov	eax, 8
	imul	rax, rax, 23
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 23
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 248  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[24], v, &wp[24]);

	mov	eax, 8
	imul	rax, rax, 24
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 249  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[25], v, &wp[25]);

	mov	eax, 8
	imul	rax, rax, 25
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 25
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 250  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[26], v, &wp[26]);

	mov	eax, 8
	imul	rax, rax, 26
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 251  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[27], v, &wp[27]);

	mov	eax, 8
	imul	rax, rax, 27
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 27
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 252  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[28], v, &wp[28]);

	mov	eax, 8
	imul	rax, rax, 28
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 253  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[29], v, &wp[29]);

	mov	eax, 8
	imul	rax, rax, 29
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 29
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 254  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[30], v, &wp[30]);

	mov	eax, 8
	imul	rax, rax, 30
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 30
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 255  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[31], v, &wp[31]);

	mov	eax, 8
	imul	rax, rax, 31
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 31
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 256  :         up += 32;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR up$[rbp], rax

; 257  :         wp += 32;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR wp$[rbp], rax

; 258  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 259  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 260  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@Multiply_W

; 261  :             AddToMULTI32Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI32Counter
	jmp	SHORT $LN5@Multiply_W
$LN4@Multiply_W:

; 262  :         else
; 263  :             AddToMULTI64Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI64Counter
$LN5@Multiply_W:

; 264  : #endif
; 265  :     }

	jmp	$LN2@Multiply_W
$LN3@Multiply_W:

; 266  : 
; 267  :     if (u_count & 0x10)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	$LN6@Multiply_W

; 268  :     {
; 269  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 270  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[1], v, &wp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 271  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[2], v, &wp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 272  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[3], v, &wp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 273  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[4], v, &wp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 274  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[5], v, &wp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 275  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[6], v, &wp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 276  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[7], v, &wp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 277  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[8], v, &wp[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 278  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[9], v, &wp[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 279  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[10], v, &wp[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 280  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[11], v, &wp[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 281  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[12], v, &wp[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 282  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[13], v, &wp[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 283  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[14], v, &wp[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 284  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[15], v, &wp[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 285  :         up += 16;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR up$[rbp], rax

; 286  :         wp += 16;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR wp$[rbp], rax

; 287  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 288  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN7@Multiply_W

; 289  :             AddToMULTI32Counter(16);

	mov	ecx, 16
	call	AddToMULTI32Counter
	jmp	SHORT $LN8@Multiply_W
$LN7@Multiply_W:

; 290  :         else
; 291  :             AddToMULTI64Counter(16);

	mov	ecx, 16
	call	AddToMULTI64Counter
$LN8@Multiply_W:
$LN6@Multiply_W:

; 292  : #endif
; 293  :     }
; 294  : 
; 295  :     if (u_count & 0x8)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	$LN9@Multiply_W

; 296  :     {
; 297  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 298  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[1], v, &wp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 299  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[2], v, &wp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 300  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[3], v, &wp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 301  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[4], v, &wp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 302  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[5], v, &wp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 303  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[6], v, &wp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 304  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[7], v, &wp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 305  :         up += 8;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR up$[rbp], rax

; 306  :         wp += 8;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR wp$[rbp], rax

; 307  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 308  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN10@Multiply_W

; 309  :             AddToMULTI32Counter(8);

	mov	ecx, 8
	call	AddToMULTI32Counter
	jmp	SHORT $LN11@Multiply_W
$LN10@Multiply_W:

; 310  :         else
; 311  :             AddToMULTI64Counter(8);

	mov	ecx, 8
	call	AddToMULTI64Counter
$LN11@Multiply_W:
$LN9@Multiply_W:

; 312  : #endif
; 313  :     }
; 314  : 
; 315  :     if (u_count & 0x4)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	$LN12@Multiply_W

; 316  :     {
; 317  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 318  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[1], v, &wp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 319  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[2], v, &wp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 320  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[3], v, &wp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 321  :         up += 4;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR up$[rbp], rax

; 322  :         wp += 4;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR wp$[rbp], rax

; 323  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 324  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN13@Multiply_W

; 325  :             AddToMULTI32Counter(4);

	mov	ecx, 4
	call	AddToMULTI32Counter
	jmp	SHORT $LN14@Multiply_W
$LN13@Multiply_W:

; 326  :         else
; 327  :             AddToMULTI64Counter(4);

	mov	ecx, 4
	call	AddToMULTI64Counter
$LN14@Multiply_W:
$LN12@Multiply_W:

; 328  : #endif
; 329  :     }
; 330  : 
; 331  :     if (u_count & 0x2)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	$LN15@Multiply_W

; 332  :     {
; 333  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 334  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[1], v, &wp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 335  :         up += 2;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 16
	mov	QWORD PTR up$[rbp], rax

; 336  :         wp += 2;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 16
	mov	QWORD PTR wp$[rbp], rax

; 337  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 338  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN16@Multiply_W

; 339  :             AddToMULTI32Counter(2);

	mov	ecx, 2
	call	AddToMULTI32Counter
	jmp	SHORT $LN17@Multiply_W
$LN16@Multiply_W:

; 340  :         else
; 341  :             AddToMULTI64Counter(2);

	mov	ecx, 2
	call	AddToMULTI64Counter
$LN17@Multiply_W:
$LN15@Multiply_W:

; 342  : #endif
; 343  :     }
; 344  : 
; 345  :     if (u_count & 0x1)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN18@Multiply_W

; 346  :     {
; 347  :         k = _MULTIPLYX_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 348  :         up += 1;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 8
	mov	QWORD PTR up$[rbp], rax

; 349  :         wp += 1;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 8
	mov	QWORD PTR wp$[rbp], rax

; 350  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 351  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN19@Multiply_W

; 352  :             IncrementMULTI32Counter();

	call	IncrementMULTI32Counter
	jmp	SHORT $LN20@Multiply_W
$LN19@Multiply_W:

; 353  :         else
; 354  :             IncrementMULTI64Counter();

	call	IncrementMULTI64Counter
$LN20@Multiply_W:
$LN18@Multiply_W:

; 355  : #endif
; 356  :     }
; 357  : 
; 358  :     if (k != 0)

	cmp	QWORD PTR k$[rbp], 0
	je	SHORT $LN21@Multiply_W

; 359  :         *wp = k;

	mov	rax, QWORD PTR wp$[rbp]
	mov	rcx, QWORD PTR k$[rbp]
	mov	QWORD PTR [rax], rcx
$LN21@Multiply_W:

; 360  : 
; 361  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 362  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
Multiply_WORD_using_MULX_ADCX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT Multiply_WORD_using_MUL_ADC
_TEXT	SEGMENT
k$ = 8
count$ = 40
up$ = 288
u_count$ = 296
v$ = 304
wp$ = 312
Multiply_WORD_using_MUL_ADC PROC			; COMDAT

; 71   : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 72   :     __UNIT_TYPE k = 0;

	mov	QWORD PTR k$[rbp], 0

; 73   :     __UNIT_TYPE count = u_count >> 5;

	mov	rax, QWORD PTR u_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@Multiply_W:

; 74   : 
; 75   :     while (count != 0)

	cmp	QWORD PTR count$[rbp], 0
	je	$LN3@Multiply_W

; 76   :     {
; 77   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 78   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[1], v, &wp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 79   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[2], v, &wp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 80   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[3], v, &wp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 81   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[4], v, &wp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 82   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[5], v, &wp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 83   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[6], v, &wp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 84   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[7], v, &wp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 85   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[8], v, &wp[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 86   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[9], v, &wp[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 87   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[10], v, &wp[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 88   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[11], v, &wp[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 89   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[12], v, &wp[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 90   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[13], v, &wp[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 91   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[14], v, &wp[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 92   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[15], v, &wp[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 93   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[16], v, &wp[16]);

	mov	eax, 8
	imul	rax, rax, 16
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 94   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[17], v, &wp[17]);

	mov	eax, 8
	imul	rax, rax, 17
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 17
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 95   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[18], v, &wp[18]);

	mov	eax, 8
	imul	rax, rax, 18
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 18
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 96   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[19], v, &wp[19]);

	mov	eax, 8
	imul	rax, rax, 19
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 19
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 97   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[20], v, &wp[20]);

	mov	eax, 8
	imul	rax, rax, 20
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 98   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[21], v, &wp[21]);

	mov	eax, 8
	imul	rax, rax, 21
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 21
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 99   :         k = _MULTIPLY_DIGIT_UNIT(k, &up[22], v, &wp[22]);

	mov	eax, 8
	imul	rax, rax, 22
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 100  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[23], v, &wp[23]);

	mov	eax, 8
	imul	rax, rax, 23
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 23
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 101  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[24], v, &wp[24]);

	mov	eax, 8
	imul	rax, rax, 24
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 102  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[25], v, &wp[25]);

	mov	eax, 8
	imul	rax, rax, 25
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 25
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 103  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[26], v, &wp[26]);

	mov	eax, 8
	imul	rax, rax, 26
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 104  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[27], v, &wp[27]);

	mov	eax, 8
	imul	rax, rax, 27
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 27
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 105  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[28], v, &wp[28]);

	mov	eax, 8
	imul	rax, rax, 28
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 106  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[29], v, &wp[29]);

	mov	eax, 8
	imul	rax, rax, 29
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 29
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 107  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[30], v, &wp[30]);

	mov	eax, 8
	imul	rax, rax, 30
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 30
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 108  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[31], v, &wp[31]);

	mov	eax, 8
	imul	rax, rax, 31
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 31
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 109  :         up += 32;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR up$[rbp], rax

; 110  :         wp += 32;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR wp$[rbp], rax

; 111  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 112  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 113  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@Multiply_W

; 114  :             AddToMULTI32Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI32Counter
	jmp	SHORT $LN5@Multiply_W
$LN4@Multiply_W:

; 115  :         else
; 116  :             AddToMULTI64Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI64Counter
$LN5@Multiply_W:

; 117  : #endif
; 118  :     }

	jmp	$LN2@Multiply_W
$LN3@Multiply_W:

; 119  : 
; 120  :     if (u_count & 0x10)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	$LN6@Multiply_W

; 121  :     {
; 122  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 123  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[1], v, &wp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 124  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[2], v, &wp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 125  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[3], v, &wp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 126  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[4], v, &wp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 127  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[5], v, &wp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 128  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[6], v, &wp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 129  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[7], v, &wp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 130  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[8], v, &wp[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 131  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[9], v, &wp[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 132  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[10], v, &wp[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 133  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[11], v, &wp[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 134  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[12], v, &wp[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 135  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[13], v, &wp[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 136  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[14], v, &wp[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 137  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[15], v, &wp[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 138  :         up += 16;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR up$[rbp], rax

; 139  :         wp += 16;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR wp$[rbp], rax

; 140  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 141  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN7@Multiply_W

; 142  :             AddToMULTI32Counter(16);

	mov	ecx, 16
	call	AddToMULTI32Counter
	jmp	SHORT $LN8@Multiply_W
$LN7@Multiply_W:

; 143  :         else
; 144  :             AddToMULTI64Counter(16);

	mov	ecx, 16
	call	AddToMULTI64Counter
$LN8@Multiply_W:
$LN6@Multiply_W:

; 145  : #endif
; 146  :     }
; 147  : 
; 148  :     if (u_count & 0x8)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	$LN9@Multiply_W

; 149  :     {
; 150  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 151  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[1], v, &wp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 152  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[2], v, &wp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 153  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[3], v, &wp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 154  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[4], v, &wp[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 155  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[5], v, &wp[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 156  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[6], v, &wp[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 157  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[7], v, &wp[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 158  :         up += 8;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR up$[rbp], rax

; 159  :         wp += 8;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR wp$[rbp], rax

; 160  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 161  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN10@Multiply_W

; 162  :             AddToMULTI32Counter(8);

	mov	ecx, 8
	call	AddToMULTI32Counter
	jmp	SHORT $LN11@Multiply_W
$LN10@Multiply_W:

; 163  :         else
; 164  :             AddToMULTI64Counter(8);

	mov	ecx, 8
	call	AddToMULTI64Counter
$LN11@Multiply_W:
$LN9@Multiply_W:

; 165  : #endif
; 166  :     }
; 167  : 
; 168  :     if (u_count & 0x4)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	$LN12@Multiply_W

; 169  :     {
; 170  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 171  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[1], v, &wp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 172  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[2], v, &wp[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 173  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[3], v, &wp[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 174  :         up += 4;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR up$[rbp], rax

; 175  :         wp += 4;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR wp$[rbp], rax

; 176  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 177  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN13@Multiply_W

; 178  :             AddToMULTI32Counter(4);

	mov	ecx, 4
	call	AddToMULTI32Counter
	jmp	SHORT $LN14@Multiply_W
$LN13@Multiply_W:

; 179  :         else
; 180  :             AddToMULTI64Counter(4);

	mov	ecx, 4
	call	AddToMULTI64Counter
$LN14@Multiply_W:
$LN12@Multiply_W:

; 181  : #endif
; 182  :     }
; 183  : 
; 184  :     if (u_count & 0x2)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	$LN15@Multiply_W

; 185  :     {
; 186  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 187  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[1], v, &wp[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 188  :         up += 2;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 16
	mov	QWORD PTR up$[rbp], rax

; 189  :         wp += 2;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 16
	mov	QWORD PTR wp$[rbp], rax

; 190  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 191  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN16@Multiply_W

; 192  :             AddToMULTI32Counter(2);

	mov	ecx, 2
	call	AddToMULTI32Counter
	jmp	SHORT $LN17@Multiply_W
$LN16@Multiply_W:

; 193  :         else
; 194  :             AddToMULTI64Counter(2);

	mov	ecx, 2
	call	AddToMULTI64Counter
$LN17@Multiply_W:
$LN15@Multiply_W:

; 195  : #endif
; 196  :     }
; 197  : 
; 198  :     if (u_count & 0x1)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN18@Multiply_W

; 199  :     {
; 200  :         k = _MULTIPLY_DIGIT_UNIT(k, &up[0], v, &wp[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR wp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR up$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, rcx
	mov	rcx, QWORD PTR k$[rbp]
	call	_MULTIPLY_DIGIT_UNIT
	mov	QWORD PTR k$[rbp], rax

; 201  :         up += 1;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 8
	mov	QWORD PTR up$[rbp], rax

; 202  :         wp += 1;

	mov	rax, QWORD PTR wp$[rbp]
	add	rax, 8
	mov	QWORD PTR wp$[rbp], rax

; 203  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 204  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN19@Multiply_W

; 205  :             IncrementMULTI32Counter();

	call	IncrementMULTI32Counter
	jmp	SHORT $LN20@Multiply_W
$LN19@Multiply_W:

; 206  :         else
; 207  :             IncrementMULTI64Counter();

	call	IncrementMULTI64Counter
$LN20@Multiply_W:
$LN18@Multiply_W:

; 208  : #endif
; 209  :     }
; 210  : 
; 211  :     if (k != 0)

	cmp	QWORD PTR k$[rbp], 0
	je	SHORT $LN21@Multiply_W

; 212  :         *wp = k;

	mov	rax, QWORD PTR wp$[rbp]
	mov	rcx, QWORD PTR k$[rbp]
	mov	QWORD PTR [rax], rcx
$LN21@Multiply_W:

; 213  : 
; 214  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 215  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
Multiply_WORD_using_MUL_ADC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT _MULTIPLYX_DIGIT_UNIT
_TEXT	SEGMENT
t_hi$ = 8
t_lo$ = 40
k$ = 288
up$ = 296
v$ = 304
wp$ = 312
_MULTIPLYX_DIGIT_UNIT PROC				; COMDAT

; 59   : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 60   :     __UNIT_TYPE t_hi;
; 61   :     __UNIT_TYPE t_lo;
; 62   :     t_lo = _MULTIPLYX_UNIT(*up, v, &t_hi);

	lea	r8, QWORD PTR t_hi$[rbp]
	mov	rdx, QWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	_MULTIPLYX_UNIT
	mov	QWORD PTR t_lo$[rbp], rax

; 63   :     _ADDX_UNIT(_ADDX_UNIT(0, t_lo, *wp, &t_lo), t_hi, 0, &t_hi);

	lea	r9, QWORD PTR t_lo$[rbp]
	mov	rax, QWORD PTR wp$[rbp]
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR t_lo$[rbp]
	xor	ecx, ecx
	call	_ADDX_UNIT
	lea	r9, QWORD PTR t_hi$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR t_hi$[rbp]
	movzx	ecx, al
	call	_ADDX_UNIT

; 64   :     _ADDX_UNIT(_ADDX_UNIT(0, t_lo, k, &t_lo), t_hi, 0, &t_hi);

	lea	r9, QWORD PTR t_lo$[rbp]
	mov	r8, QWORD PTR k$[rbp]
	mov	rdx, QWORD PTR t_lo$[rbp]
	xor	ecx, ecx
	call	_ADDX_UNIT
	lea	r9, QWORD PTR t_hi$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR t_hi$[rbp]
	movzx	ecx, al
	call	_ADDX_UNIT

; 65   :     *wp = t_lo;

	mov	rax, QWORD PTR wp$[rbp]
	mov	rcx, QWORD PTR t_lo$[rbp]
	mov	QWORD PTR [rax], rcx

; 66   :     k = t_hi;

	mov	rax, QWORD PTR t_hi$[rbp]
	mov	QWORD PTR k$[rbp], rax

; 67   :     return (k);

	mov	rax, QWORD PTR k$[rbp]

; 68   : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_MULTIPLYX_DIGIT_UNIT$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
_MULTIPLYX_DIGIT_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT _MULTIPLY_DIGIT_UNIT
_TEXT	SEGMENT
t_hi$ = 8
t_lo$ = 40
k$ = 288
up$ = 296
v$ = 304
wp$ = 312
_MULTIPLY_DIGIT_UNIT PROC				; COMDAT

; 47   : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 48   :     __UNIT_TYPE t_hi;
; 49   :     __UNIT_TYPE t_lo;
; 50   :     t_lo = _MULTIPLY_UNIT(*up, v, &t_hi);

	lea	r8, QWORD PTR t_hi$[rbp]
	mov	rdx, QWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	_MULTIPLY_UNIT
	mov	QWORD PTR t_lo$[rbp], rax

; 51   :     _ADD_UNIT(_ADD_UNIT(0, t_lo, *wp, &t_lo), t_hi, 0, &t_hi);

	lea	r9, QWORD PTR t_lo$[rbp]
	mov	rax, QWORD PTR wp$[rbp]
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR t_lo$[rbp]
	xor	ecx, ecx
	call	_ADD_UNIT
	lea	r9, QWORD PTR t_hi$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR t_hi$[rbp]
	movzx	ecx, al
	call	_ADD_UNIT

; 52   :     _ADD_UNIT(_ADD_UNIT(0, t_lo, k, &t_lo), t_hi, 0, &t_hi);

	lea	r9, QWORD PTR t_lo$[rbp]
	mov	r8, QWORD PTR k$[rbp]
	mov	rdx, QWORD PTR t_lo$[rbp]
	xor	ecx, ecx
	call	_ADD_UNIT
	lea	r9, QWORD PTR t_hi$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR t_hi$[rbp]
	movzx	ecx, al
	call	_ADD_UNIT

; 53   :     *wp = t_lo;

	mov	rax, QWORD PTR wp$[rbp]
	mov	rcx, QWORD PTR t_lo$[rbp]
	mov	QWORD PTR [rax], rcx

; 54   :     k = t_hi;

	mov	rax, QWORD PTR t_hi$[rbp]
	mov	QWORD PTR k$[rbp], rax

; 55   :     return (k);

	mov	rax, QWORD PTR k$[rbp]

; 56   : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_MULTIPLY_DIGIT_UNIT$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
_MULTIPLY_DIGIT_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT AddToMULTI64Counter
_TEXT	SEGMENT
value$ = 224
AddToMULTI64Counter PROC				; COMDAT

; 1112 : {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 1113 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lea	rax, OFFSET FLAT:statistics_info
	mov	ecx, DWORD PTR value$[rbp]
	lock add DWORD PTR [rax], ecx

; 1114 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
AddToMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT AddToMULTI32Counter
_TEXT	SEGMENT
value$ = 224
AddToMULTI32Counter PROC				; COMDAT

; 1106 : {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 1107 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lea	rax, OFFSET FLAT:statistics_info+4
	mov	ecx, DWORD PTR value$[rbp]
	lock add DWORD PTR [rax], ecx

; 1108 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
AddToMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT IncrementMULTI64Counter
_TEXT	SEGMENT
IncrementMULTI64Counter PROC				; COMDAT

; 1089 : {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 1090 :     _InterlockedIncrement(&statistics_info.COUNT_MULTI64);

	lea	rax, OFFSET FLAT:statistics_info
	lock inc DWORD PTR [rax]

; 1091 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
IncrementMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT IncrementMULTI32Counter
_TEXT	SEGMENT
IncrementMULTI32Counter PROC				; COMDAT

; 1083 : {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 1084 :     _InterlockedIncrement(&statistics_info.COUNT_MULTI32);

	lea	rax, OFFSET FLAT:statistics_info+4
	lock inc DWORD PTR [rax]

; 1085 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
IncrementMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _LZCNT_ALT_UNIT
_TEXT	SEGMENT
pos$ = 4
x$ = 256
_LZCNT_ALT_UNIT PROC					; COMDAT

; 915  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 916  :     if (x == 0)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN2@LZCNT_ALT_

; 917  :         return (sizeof(x) * 8);

	mov	eax, 64					; 00000040H
	jmp	SHORT $LN1@LZCNT_ALT_
$LN2@LZCNT_ALT_:

; 918  : #ifdef _M_IX86
; 919  :     _UINT32_T pos;
; 920  : #ifdef _MSC_VER
; 921  :     _BitScanReverse(&pos, x);
; 922  : #elif defined(__GNUC__)
; 923  :     __asm__("bsrl %1, %0" : "=r"(pos) : "rm"(x));
; 924  : #else
; 925  : #error unknown compiler
; 926  : #endif
; 927  : #elif defined(_M_X64)
; 928  : #ifdef _MSC_VER
; 929  :     _UINT32_T pos;
; 930  :     _BitScanReverse64(&pos, x);

	mov	rax, QWORD PTR x$[rbp]
	bsr	rax, rax
	mov	DWORD PTR pos$[rbp], eax

; 931  : #elif defined(__GNUC__)
; 932  :     _UINT64_T pos;
; 933  :     __asm__("bsrq %1, %0" : "=r"(pos) : "rm"(x));
; 934  : #else
; 935  : #error unknown compiler
; 936  : #endif
; 937  : #else
; 938  : #error unknown platform
; 939  : #endif
; 940  :     return (sizeof(x) * 8 - 1 - pos);

	mov	eax, DWORD PTR pos$[rbp]
	mov	ecx, 63					; 0000003fH
	sub	rcx, rax
	mov	rax, rcx
$LN1@LZCNT_ALT_:

; 941  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_LZCNT_ALT_UNIT$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_LZCNT_ALT_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _LZCNT_ALT_32
_TEXT	SEGMENT
pos$ = 4
x$ = 256
_LZCNT_ALT_32 PROC					; COMDAT

; 882  : {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 883  :     if (x == 0)

	cmp	DWORD PTR x$[rbp], 0
	jne	SHORT $LN2@LZCNT_ALT_

; 884  :         return (sizeof(x) * 8);

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN1@LZCNT_ALT_
$LN2@LZCNT_ALT_:

; 885  :     _UINT32_T pos;
; 886  : #ifdef _MSC_VER
; 887  :     _BitScanReverse(&pos, x);

	mov	eax, DWORD PTR x$[rbp]
	bsr	eax, eax
	mov	DWORD PTR pos$[rbp], eax

; 888  : #elif defined(__GNUC__)
; 889  :     __asm__( "bsrl %1, %0" : "=r"(pos) : "rm"(x) );
; 890  : #else
; 891  : #error unknown compiler
; 892  : #endif
; 893  :     return (sizeof(x) * 8 - 1 - pos);

	mov	eax, DWORD PTR pos$[rbp]
	mov	ecx, 31
	sub	rcx, rax
	mov	rax, rcx
$LN1@LZCNT_ALT_:

; 894  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_LZCNT_ALT_32$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_LZCNT_ALT_32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _MULTIPLYX_UNIT
_TEXT	SEGMENT
u$ = 224
v$ = 232
w_hi$ = 240
_MULTIPLYX_UNIT PROC					; COMDAT

; 621  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 622  : #ifdef _MSC_VER
; 623  : #ifdef _M_IX86
; 624  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));
; 625  : #elif defined(_M_X64)
; 626  :     return (_mulx_u64(u, v, w_hi));

	mov	rdx, QWORD PTR v$[rbp]
	mulx	rax, rcx, QWORD PTR u$[rbp]
	mov	rdx, QWORD PTR w_hi$[rbp]
	mov	QWORD PTR [rdx], rax
	mov	rax, rcx

; 627  : #else
; 628  : #error unknown platform
; 629  : #endif
; 630  : #elif defined(__GNUC__)
; 631  : #ifdef _M_IX86
; 632  :     _UINT32_T w_lo;
; 633  :     __asm__("mulxl %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 634  :     return (w_lo);
; 635  : #elif defined(_M_X64)
; 636  :     _UINT64_T w_lo;
; 637  :     __asm__("mulxq %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 638  :     return (w_lo);
; 639  : #else
; 640  : #error unknown platform
; 641  : #endif
; 642  : #else
; 643  : #error unknown compiler
; 644  : #endif
; 645  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_MULTIPLYX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _MULTIPLY_UNIT
_TEXT	SEGMENT
tv69 = 192
u$ = 240
v$ = 248
w_hi$ = 256
_MULTIPLY_UNIT PROC					; COMDAT

; 583  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 584  : #ifdef _M_IX86
; 585  : #ifdef _MSC_VER
; 586  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));
; 587  : #elif defined(__GNUC__)
; 588  :     _UINT32_T w_lo;
; 589  :     __asm__("mull %3": "=a"(w_lo), "=d"(*w_hi) : "0"(u), "rm"(v));
; 590  :     return (w_lo);
; 591  : #else
; 592  : #error unknown compiler
; 593  : #endif
; 594  : #elif defined(_M_X64)
; 595  :     return (_umul128(u, v, w_hi));

	mov	rax, QWORD PTR u$[rbp]
	mov	QWORD PTR tv69[rbp], rax
	mov	rcx, QWORD PTR v$[rbp]
	mov	rax, rcx
	mov	rcx, QWORD PTR tv69[rbp]
	mul	rcx
	mov	rcx, QWORD PTR w_hi$[rbp]
	mov	QWORD PTR [rcx], rdx

; 596  : #else
; 597  : #error unknown platform
; 598  : #endif
; 599  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
_MULTIPLY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _ADDX_UNIT
_TEXT	SEGMENT
carry$ = 224
u$ = 232
v$ = 240
w$ = 248
_ADDX_UNIT PROC						; COMDAT

; 527  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 528  : #ifdef _M_IX86
; 529  :     return (_addcarryx_u32(carry, u, v, w));
; 530  : #elif defined(_M_X64)
; 531  :     return (_addcarryx_u64(carry, u, v, w));

	mov	rax, QWORD PTR u$[rbp]
	movzx	ecx, BYTE PTR carry$[rbp]
	add	cl, -1
	adcx	rax, QWORD PTR v$[rbp]
	setb	cl
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx], rax
	movzx	eax, cl

; 532  : #else
; 533  : #error unknown platform
; 534  : #endif
; 535  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADDX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _ADD_UNIT
_TEXT	SEGMENT
carry$ = 224
u$ = 232
v$ = 240
w$ = 248
_ADD_UNIT PROC						; COMDAT

; 499  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 500  : #ifdef _M_IX86
; 501  :     return (_addcarry_u32(carry, u, v, w));
; 502  : #elif defined(_M_X64)
; 503  :     return (_addcarry_u64(carry, u, v, w));

	mov	rax, QWORD PTR u$[rbp]
	movzx	ecx, BYTE PTR carry$[rbp]
	add	cl, -1
	adc	rax, QWORD PTR v$[rbp]
	setb	cl
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx], rax
	movzx	eax, cl

; 504  : #else
; 505  : #error unknown platform
; 506  : #endif
; 507  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _FROMDWORDTOWORD
_TEXT	SEGMENT
value$ = 224
result_high$ = 232
_FROMDWORDTOWORD PROC					; COMDAT

; 468  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 469  :     *result_high = (_UINT32_T)(value >> 32);

	mov	rax, QWORD PTR value$[rbp]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR result_high$[rbp]
	mov	DWORD PTR [rcx], eax

; 470  :     return ((_UINT32_T)value);

	mov	eax, DWORD PTR value$[rbp]

; 471  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FROMDWORDTOWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT PMC_Multiply_X_X
_TEXT	SEGMENT
nu$ = 8
nv$ = 40
result$ = 68
nw$ = 104
u_bit_count$5 = 136
v_bit_count$6 = 168
w_bit_count$7 = 200
w_light_check_code$8 = 232
u$ = 480
v$ = 488
w$ = 496
PMC_Multiply_X_X PROC					; COMDAT

; 704  : {

$LN23:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 504				; 000001f8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 126				; 0000007eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+536]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 705  :     if (u == NULL)

	cmp	QWORD PTR u$[rbp], 0
	jne	SHORT $LN2@PMC_Multip

; 706  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Multip
$LN2@PMC_Multip:

; 707  :     if (v == NULL)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN3@PMC_Multip

; 708  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Multip
$LN3@PMC_Multip:

; 709  :     if (w == NULL)

	cmp	QWORD PTR w$[rbp], 0
	jne	SHORT $LN4@PMC_Multip

; 710  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Multip
$LN4@PMC_Multip:

; 711  :     NUMBER_HEADER* nu = (NUMBER_HEADER*)u;

	mov	rax, QWORD PTR u$[rbp]
	mov	QWORD PTR nu$[rbp], rax

; 712  :     NUMBER_HEADER* nv = (NUMBER_HEADER*)v;

	mov	rax, QWORD PTR v$[rbp]
	mov	QWORD PTR nv$[rbp], rax

; 713  :     PMC_STATUS_CODE result;
; 714  :     if ((result = CheckNumber(nu)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nu$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Multip

; 715  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN5@PMC_Multip:

; 716  :     if ((result = CheckNumber(nv)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nv$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_Multip

; 717  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN6@PMC_Multip:

; 718  :     NUMBER_HEADER* nw;
; 719  :     if (nu->IS_ZERO)

	mov	rax, QWORD PTR nu$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@PMC_Multip

; 720  :     {
; 721  :         // x が 0 である場合
; 722  : 
; 723  :         // y の値にかかわらず 0 を返す。
; 724  :         *w = &number_zero;

	mov	rax, QWORD PTR w$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 725  :     }

	jmp	$LN8@PMC_Multip
$LN7@PMC_Multip:

; 726  :     else if (nu->IS_ONE)

	mov	rax, QWORD PTR nu$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@PMC_Multip

; 727  :     {
; 728  :         // x が 1 である場合
; 729  :         if (nv->IS_ZERO)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@PMC_Multip

; 730  :         {
; 731  :             // y が 0 である場合
; 732  : 
; 733  :             //  0  を返す。
; 734  :             *w = &number_zero;

	mov	rax, QWORD PTR w$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 735  :         }

	jmp	SHORT $LN12@PMC_Multip
$LN11@PMC_Multip:

; 736  :         else
; 737  :         {
; 738  :             // y が 0 ではない場合
; 739  : 
; 740  :             // 乗算結果は y に等しいため、y の値を持つ NUMBER_HEADER 構造体を獲得し、呼び出し元へ返す。
; 741  :             if ((result = DuplicateNumber(nv, &nw)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nw$[rbp]
	mov	rcx, QWORD PTR nv$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN13@PMC_Multip

; 742  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN13@PMC_Multip:

; 743  :             *w = nw;

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR nw$[rbp]
	mov	QWORD PTR [rax], rcx
$LN12@PMC_Multip:

; 744  :         }
; 745  :     }

	jmp	$LN10@PMC_Multip
$LN9@PMC_Multip:

; 746  :     else
; 747  :     {
; 748  :         // x が 0 と 1 のどちらでもない場合
; 749  : 
; 750  :         if (nv->IS_ZERO)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN14@PMC_Multip

; 751  :         {
; 752  :             // y が 0 である場合
; 753  : 
; 754  :             //  0  を返す。
; 755  :             nw = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nw$[rbp], rax

; 756  :         }

	jmp	$LN15@PMC_Multip
$LN14@PMC_Multip:

; 757  :         else if (nv->IS_ONE)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN16@PMC_Multip

; 758  :         {
; 759  :             // y が 1 である場合
; 760  : 
; 761  :             // 乗算結果は x に等しいため、x の値を持つ NUMBER_HEADER 構造体を獲得し、呼び出し元へ返す。
; 762  :             if ((result = DuplicateNumber(nu, &nw)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nw$[rbp]
	mov	rcx, QWORD PTR nu$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN18@PMC_Multip

; 763  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN18@PMC_Multip:

; 764  :         }

	jmp	$LN17@PMC_Multip
$LN16@PMC_Multip:

; 765  :         else
; 766  :         {
; 767  :             // x と y がともに 0 、1 のどちらでもない場合
; 768  : 
; 769  :             // x と y の積を計算する
; 770  :             __UNIT_TYPE u_bit_count = nu->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nu$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR u_bit_count$5[rbp], rax

; 771  :             __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nv$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR v_bit_count$6[rbp], rax

; 772  :             __UNIT_TYPE w_bit_count = u_bit_count + v_bit_count;

	mov	rax, QWORD PTR v_bit_count$6[rbp]
	mov	rcx, QWORD PTR u_bit_count$5[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR w_bit_count$7[rbp], rax

; 773  :             __UNIT_TYPE w_light_check_code;
; 774  :             if ((result = AllocateNumber(&nw, w_bit_count, &w_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR w_light_check_code$8[rbp]
	mov	rdx, QWORD PTR w_bit_count$7[rbp]
	lea	rcx, QWORD PTR nw$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN19@PMC_Multip

; 775  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Multip
$LN19@PMC_Multip:

; 776  :             (*fp_Multiply_X_X)(nu->BLOCK, nu->UNIT_WORD_COUNT, nv->BLOCK, nv->UNIT_WORD_COUNT, nw->BLOCK);

	mov	rax, QWORD PTR nw$[rbp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR nv$[rbp]
	mov	r9, QWORD PTR [rax+8]
	mov	rax, QWORD PTR nv$[rbp]
	mov	r8, QWORD PTR [rax+56]
	mov	rax, QWORD PTR nu$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	QWORD PTR fp_Multiply_X_X

; 777  :             if ((result = CheckBlockLight(nw->BLOCK, w_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR w_light_check_code$8[rbp]
	mov	rax, QWORD PTR nw$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN20@PMC_Multip

; 778  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN20@PMC_Multip:

; 779  :             CommitNumber(nw);

	mov	rcx, QWORD PTR nw$[rbp]
	call	CommitNumber
$LN17@PMC_Multip:
$LN15@PMC_Multip:

; 780  :         }
; 781  :         *w = nw;

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR nw$[rbp]
	mov	QWORD PTR [rax], rcx
$LN10@PMC_Multip:
$LN8@PMC_Multip:

; 782  :     }
; 783  : #ifdef _DEBUG
; 784  :     if ((result = CheckNumber(*w)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN21@PMC_Multip

; 785  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN21@PMC_Multip:

; 786  : #endif
; 787  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Multip:

; 788  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:PMC_Multiply_X_X$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+456]
	pop	rdi
	pop	rbp
	ret	0
PMC_Multiply_X_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT PMC_Multiply_X_L
_TEXT	SEGMENT
result$ = 4
u$ = 256
v$ = 264
w$ = 272
PMC_Multiply_X_L PROC					; COMDAT

; 681  : {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 682  :     if (__UNIT_TYPE_BIT_COUNT * 2 < sizeof(v) * 8)

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_Multip

; 683  :     {
; 684  :         // _UINT64_T が 2 ワードで表現しきれない処理系には対応しない
; 685  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_Multip
$LN2@PMC_Multip:

; 686  :     }
; 687  :     if (u == NULL)

	cmp	QWORD PTR u$[rbp], 0
	jne	SHORT $LN3@PMC_Multip

; 688  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_Multip
$LN3@PMC_Multip:

; 689  :     if (w == NULL)

	cmp	QWORD PTR w$[rbp], 0
	jne	SHORT $LN4@PMC_Multip

; 690  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_Multip
$LN4@PMC_Multip:

; 691  :     PMC_STATUS_CODE result;
; 692  :     if ((result = CheckNumber((NUMBER_HEADER*)u)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR u$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Multip

; 693  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN5@PMC_Multip:

; 694  :     if ((result = PMC_Multiply_X_L_Imp((NUMBER_HEADER*)u, v, (NUMBER_HEADER**)w)) != PMC_STATUS_OK)

	mov	r8, QWORD PTR w$[rbp]
	mov	rdx, QWORD PTR v$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	call	PMC_Multiply_X_L_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_Multip

; 695  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN6@PMC_Multip:

; 696  : #ifdef _DEBUG
; 697  :     if ((result = CheckNumber(*w)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN7@PMC_Multip

; 698  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN7@PMC_Multip:

; 699  : #endif
; 700  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Multip:

; 701  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
PMC_Multiply_X_L ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT PMC_Multiply_X_I
_TEXT	SEGMENT
result$ = 4
u$ = 256
v$ = 264
w$ = 272
PMC_Multiply_X_I PROC					; COMDAT

; 529  : {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 530  :     if (__UNIT_TYPE_BIT_COUNT < sizeof(v) * 8)

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_Multip

; 531  :     {
; 532  :         // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
; 533  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_Multip
$LN2@PMC_Multip:

; 534  :     }
; 535  :     if (u == NULL)

	cmp	QWORD PTR u$[rbp], 0
	jne	SHORT $LN3@PMC_Multip

; 536  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_Multip
$LN3@PMC_Multip:

; 537  :     if (w == NULL)

	cmp	QWORD PTR w$[rbp], 0
	jne	SHORT $LN4@PMC_Multip

; 538  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_Multip
$LN4@PMC_Multip:

; 539  :     PMC_STATUS_CODE result;
; 540  :     if ((result = CheckNumber((NUMBER_HEADER*)u)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR u$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Multip

; 541  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN5@PMC_Multip:

; 542  :     if ((result = PMC_Multiply_X_I_Imp((NUMBER_HEADER*)u, v, (NUMBER_HEADER**)w)) != PMC_STATUS_OK)

	mov	r8, QWORD PTR w$[rbp]
	mov	edx, DWORD PTR v$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	call	PMC_Multiply_X_I_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_Multip

; 543  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN6@PMC_Multip:

; 544  : #ifdef _DEBUG
; 545  :     if ((result = CheckNumber(*w)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN7@PMC_Multip

; 546  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN7@PMC_Multip:

; 547  : #endif
; 548  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Multip:

; 549  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
PMC_Multiply_X_I ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT PMC_Multiply_L_X
_TEXT	SEGMENT
result$ = 4
u$ = 256
v$ = 264
w$ = 272
PMC_Multiply_L_X PROC					; COMDAT

; 658  : {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 659  :     if (__UNIT_TYPE_BIT_COUNT * 2 < sizeof(u) * 8)

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_Multip

; 660  :     {
; 661  :         // _UINT64_T が 2 ワードで表現しきれない処理系には対応しない
; 662  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_Multip
$LN2@PMC_Multip:

; 663  :     }
; 664  :     if (v == NULL)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN3@PMC_Multip

; 665  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_Multip
$LN3@PMC_Multip:

; 666  :     if (w == NULL)

	cmp	QWORD PTR w$[rbp], 0
	jne	SHORT $LN4@PMC_Multip

; 667  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_Multip
$LN4@PMC_Multip:

; 668  :     PMC_STATUS_CODE result;
; 669  :     if ((result = CheckNumber((NUMBER_HEADER*)v)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR v$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Multip

; 670  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN5@PMC_Multip:

; 671  :     if ((result = PMC_Multiply_X_L_Imp((NUMBER_HEADER*)v, u, (NUMBER_HEADER**)w)) != PMC_STATUS_OK)

	mov	r8, QWORD PTR w$[rbp]
	mov	rdx, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	call	PMC_Multiply_X_L_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_Multip

; 672  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN6@PMC_Multip:

; 673  : #ifdef _DEBUG
; 674  :     if ((result = CheckNumber(*w)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN7@PMC_Multip

; 675  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN7@PMC_Multip:

; 676  : #endif
; 677  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Multip:

; 678  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
PMC_Multiply_L_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT PMC_Multiply_I_X
_TEXT	SEGMENT
result$ = 4
u$ = 256
v$ = 264
w$ = 272
PMC_Multiply_I_X PROC					; COMDAT

; 506  : {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 507  :     if (__UNIT_TYPE_BIT_COUNT < sizeof(u) * 8)

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_Multip

; 508  :     {
; 509  :         // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
; 510  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_Multip
$LN2@PMC_Multip:

; 511  :     }
; 512  :     if (v == NULL)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN3@PMC_Multip

; 513  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_Multip
$LN3@PMC_Multip:

; 514  :     if (w == NULL)

	cmp	QWORD PTR w$[rbp], 0
	jne	SHORT $LN4@PMC_Multip

; 515  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_Multip
$LN4@PMC_Multip:

; 516  :     PMC_STATUS_CODE result;
; 517  :     if ((result = CheckNumber((NUMBER_HEADER*)v)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR v$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Multip

; 518  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN5@PMC_Multip:

; 519  :     if ((result = PMC_Multiply_X_I_Imp((NUMBER_HEADER*)v, u, (NUMBER_HEADER**)w)) != PMC_STATUS_OK)

	mov	r8, QWORD PTR w$[rbp]
	mov	edx, DWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	call	PMC_Multiply_X_I_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_Multip

; 520  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN6@PMC_Multip:

; 521  : #ifdef _DEBUG
; 522  :     if ((result = CheckNumber(*w)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR w$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN7@PMC_Multip

; 523  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Multip
$LN7@PMC_Multip:

; 524  : #endif
; 525  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Multip:

; 526  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
PMC_Multiply_I_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT Initialize_Multiply
_TEXT	SEGMENT
feature$ = 224
Initialize_Multiply PROC				; COMDAT

; 791  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 792  :     if (feature->PROCESSOR_FEATURE_ADX && feature->PROCESSOR_FEATURE_BMI2)

	mov	rax, QWORD PTR feature$[rbp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@Initialize
	mov	rax, QWORD PTR feature$[rbp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@Initialize

; 793  :     {
; 794  :         fp_Multiply_X_1W = Multiply_X_1W_using_MULX_ADCX;

	lea	rax, OFFSET FLAT:Multiply_X_1W_using_MULX_ADCX
	mov	QWORD PTR fp_Multiply_X_1W, rax

; 795  :         fp_Multiply_X_2W = Multiply_X_2W_using_MULX_ADCX;

	lea	rax, OFFSET FLAT:Multiply_X_2W_using_MULX_ADCX
	mov	QWORD PTR fp_Multiply_X_2W, rax

; 796  :         fp_Multiply_X_X = Multiply_X_X_using_MULX_ADCX;

	lea	rax, OFFSET FLAT:Multiply_X_X_using_MULX_ADCX
	mov	QWORD PTR fp_Multiply_X_X, rax

; 797  :     }

	jmp	SHORT $LN3@Initialize
$LN2@Initialize:

; 798  :     else
; 799  :     {
; 800  :         fp_Multiply_X_1W = Multiply_X_1W_using_MUL_ADC;

	lea	rax, OFFSET FLAT:Multiply_X_1W_using_MUL_ADC
	mov	QWORD PTR fp_Multiply_X_1W, rax

; 801  :         fp_Multiply_X_2W = Multiply_X_2W_using_MUL_ADC;

	lea	rax, OFFSET FLAT:Multiply_X_2W_using_MUL_ADC
	mov	QWORD PTR fp_Multiply_X_2W, rax

; 802  :         fp_Multiply_X_X = Multiply_X_X_using_MUL_ADC;

	lea	rax, OFFSET FLAT:Multiply_X_X_using_MUL_ADC
	mov	QWORD PTR fp_Multiply_X_X, rax
$LN3@Initialize:

; 803  :     }
; 804  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 805  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Initialize_Multiply ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_multiply.c
;	COMDAT Multiply_X_X_Imp
_TEXT	SEGMENT
u$ = 224
u_count$ = 232
v$ = 240
v_count$ = 248
w$ = 256
Multiply_X_X_Imp PROC					; COMDAT

; 42   : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__C53FCF4E_pmc_multiply@c
	call	__CheckForDebuggerJustMyCode

; 43   :     (*fp_Multiply_X_X)(u, u_count,  v,  v_count,  w);

	mov	rax, QWORD PTR w$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v_count$[rbp]
	mov	r8, QWORD PTR v$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	call	QWORD PTR fp_Multiply_X_X

; 44   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Multiply_X_X_Imp ENDP
_TEXT	ENDS
END
