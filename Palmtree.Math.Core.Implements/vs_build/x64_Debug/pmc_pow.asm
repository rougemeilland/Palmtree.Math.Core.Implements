; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__4522B509_pmc_internal@h DB 01H
__89DB6AB9_autogenerated_inline_func@h DB 01H
__336CEE9B_pmc_pow@c DB 01H
msvcjmc	ENDS
PUBLIC	Initialize_Pow
PUBLIC	PMC_Pow_X_I
PUBLIC	__JustMyCode_Default
EXTRN	AllocateBlock:PROC
EXTRN	DeallocateBlock:PROC
EXTRN	CheckBlockLight:PROC
EXTRN	AllocateNumber:PROC
EXTRN	CommitNumber:PROC
EXTRN	CheckNumber:PROC
EXTRN	From_I_Imp:PROC
EXTRN	Multiply_X_X_Imp:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	number_zero:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$Initialize_Pow DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$Initialize_Pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Pow_X_I DD imagerel $LN9
	DD	imagerel $LN9+219
	DD	imagerel $unwind$PMC_Pow_X_I
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_COPY_MEMORY_UNIT DD imagerel _COPY_MEMORY_UNIT
	DD	imagerel _COPY_MEMORY_UNIT+100
	DD	imagerel $unwind$_COPY_MEMORY_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ZERO_MEMORY_UNIT DD imagerel _ZERO_MEMORY_UNIT
	DD	imagerel _ZERO_MEMORY_UNIT+88
	DD	imagerel $unwind$_ZERO_MEMORY_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_LZCNT_ALT_32 DD imagerel _LZCNT_ALT_32
	DD	imagerel _LZCNT_ALT_32+126
	DD	imagerel $unwind$_LZCNT_ALT_32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pow_Imp DD imagerel Pow_Imp
	DD	imagerel Pow_Imp+546
	DD	imagerel $unwind$Pow_Imp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Pow_X_I_Imp DD imagerel PMC_Pow_X_I_Imp
	DD	imagerel PMC_Pow_X_I_Imp+721
	DD	imagerel $unwind$PMC_Pow_X_I_Imp
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Pow_X_I_Imp DD 035053301H
	DD	0117331cH
	DD	070100047H
	DD	0500fH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_Pow_X_I_Imp$rtcName$0 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	031H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+1
PMC_Pow_X_I_Imp$rtcName$1 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	031H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
PMC_Pow_X_I_Imp$rtcName$2 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	032H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+1
PMC_Pow_X_I_Imp$rtcName$3 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	032H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
PMC_Pow_X_I_Imp$rtcName$4 DB 07aH
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+3
PMC_Pow_X_I_Imp$rtcVarDesc DD 0158H
	DD	08H
	DQ	FLAT:PMC_Pow_X_I_Imp$rtcName$4
	DD	0118H
	DD	08H
	DQ	FLAT:PMC_Pow_X_I_Imp$rtcName$3
	DD	0f8H
	DD	08H
	DQ	FLAT:PMC_Pow_X_I_Imp$rtcName$2
	DD	0b8H
	DD	08H
	DQ	FLAT:PMC_Pow_X_I_Imp$rtcName$1
	DD	098H
	DD	08H
	DQ	FLAT:PMC_Pow_X_I_Imp$rtcName$0
	ORG $+240
PMC_Pow_X_I_Imp$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:PMC_Pow_X_I_Imp$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pow_Imp DD 035053901H
	DD	011d3322H
	DD	07016003bH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_LZCNT_ALT_32 DD 025052801H
	DD	010d2312H
	DD	070060021H
	DD	05005H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_LZCNT_ALT_32$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+12
_LZCNT_ALT_32$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:_LZCNT_ALT_32$rtcName$0
	ORG $+48
_LZCNT_ALT_32$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_LZCNT_ALT_32$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ZERO_MEMORY_UNIT DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_COPY_MEMORY_UNIT DD 025063501H
	DD	0119231eH
	DD	07012001cH
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Pow_X_I DD 025053301H
	DD	0117231cH
	DD	070100021H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Initialize_Pow DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_pow.c
;	COMDAT PMC_Pow_X_I_Imp
_TEXT	SEGMENT
result$ = 4
x_bit_count$8 = 40
work_bit_count$9 = 72
work1_buf_code$10 = 104
work1_buf_words$11 = 136
work1_buf$12 = 168
work2_buf_code$13 = 200
work2_buf_words$14 = 232
work2_buf$15 = 264
z_check_code$16 = 296
tv75 = 504
x$ = 544
n$ = 552
z$ = 560
PMC_Pow_X_I_Imp PROC					; COMDAT

; 85   : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 568				; 00000238H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 142				; 0000008eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+600]
	lea	rcx, OFFSET FLAT:__336CEE9B_pmc_pow@c
	call	__CheckForDebuggerJustMyCode

; 86   :     PMC_STATUS_CODE result;
; 87   :     if (x->IS_ZERO)

	mov	rax, QWORD PTR x$[rbp]
	mov	eax, DWORD PTR [rax+32]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@PMC_Pow_X_

; 88   :     {
; 89   :         // x が 0 である場合
; 90   : 
; 91   :         if (n == 0)

	cmp	DWORD PTR n$[rbp], 0
	jne	SHORT $LN4@PMC_Pow_X_

; 92   :         {
; 93   :             // n が 0 である場合
; 94   : 
; 95   :             // 0 の 0 乗となるので、エラーを返す
; 96   :             return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_Pow_X_

; 97   :         }

	jmp	SHORT $LN5@PMC_Pow_X_
$LN4@PMC_Pow_X_:

; 98   :         else
; 99   :         {
; 100  :             // n が 0 ではない場合
; 101  : 
; 102  :             *z = &number_zero;

	mov	rax, QWORD PTR z$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx
$LN5@PMC_Pow_X_:

; 103  :         }
; 104  :     }

	jmp	$LN3@PMC_Pow_X_
$LN2@PMC_Pow_X_:

; 105  :     else
; 106  :     {
; 107  :         // x が 0 ではない場合
; 108  : 
; 109  :         if (n == 0)

	cmp	DWORD PTR n$[rbp], 0
	jne	SHORT $LN6@PMC_Pow_X_

; 110  :         {
; 111  :             // n が 0 である場合
; 112  : 
; 113  :             // 計算結果の 1 を返す
; 114  :             if ((result = From_I_Imp(1, z)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR z$[rbp]
	mov	ecx, 1
	call	From_I_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN8@PMC_Pow_X_

; 115  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Pow_X_
$LN8@PMC_Pow_X_:

; 116  :         }

	jmp	$LN7@PMC_Pow_X_
$LN6@PMC_Pow_X_:

; 117  :         else
; 118  :         {
; 119  :             // x と n がともに 0 ではない場合
; 120  : 
; 121  :             // x の n 乗を計算する
; 122  :             __UNIT_TYPE x_bit_count = x->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR x_bit_count$8[rbp], rax

; 123  : 
; 124  :             // べき乗の計算結果のビット長が論理的な限界を超えると思われる場合、エラーを返す
; 125  :             if (x_bit_count > ((__UNIT_TYPE)-1 - __UNIT_TYPE_BIT_COUNT) / n)

	mov	eax, DWORD PTR n$[rbp]
	mov	QWORD PTR tv75[rbp], rax
	xor	edx, edx
	mov	rax, -65				; ffffffffffffffbfH
	mov	rcx, QWORD PTR tv75[rbp]
	div	rcx
	cmp	QWORD PTR x_bit_count$8[rbp], rax
	jbe	SHORT $LN9@PMC_Pow_X_

; 126  :                 return (PMC_STATUS_OVERFLOW);

	mov	eax, -2
	jmp	$LN1@PMC_Pow_X_
$LN9@PMC_Pow_X_:

; 127  : 
; 128  :             __UNIT_TYPE work_bit_count = x_bit_count * n + __UNIT_TYPE_BIT_COUNT;

	mov	eax, DWORD PTR n$[rbp]
	mov	rcx, QWORD PTR x_bit_count$8[rbp]
	imul	rcx, rax
	mov	rax, rcx
	add	rax, 64					; 00000040H
	mov	QWORD PTR work_bit_count$9[rbp], rax

; 129  : 
; 130  :             __UNIT_TYPE work1_buf_code;
; 131  :             __UNIT_TYPE work1_buf_words;
; 132  :             __UNIT_TYPE* work1_buf = AllocateBlock(work_bit_count, &work1_buf_words, &work1_buf_code);

	lea	r8, QWORD PTR work1_buf_code$10[rbp]
	lea	rdx, QWORD PTR work1_buf_words$11[rbp]
	mov	rcx, QWORD PTR work_bit_count$9[rbp]
	call	AllocateBlock
	mov	QWORD PTR work1_buf$12[rbp], rax

; 133  :             if (work1_buf == NULL)

	cmp	QWORD PTR work1_buf$12[rbp], 0
	jne	SHORT $LN10@PMC_Pow_X_

; 134  :             {
; 135  :                 return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@PMC_Pow_X_
$LN10@PMC_Pow_X_:

; 136  :             }
; 137  :             __UNIT_TYPE work2_buf_code;
; 138  :             __UNIT_TYPE work2_buf_words;
; 139  :             __UNIT_TYPE* work2_buf = AllocateBlock(work_bit_count, &work2_buf_words, &work2_buf_code);

	lea	r8, QWORD PTR work2_buf_code$13[rbp]
	lea	rdx, QWORD PTR work2_buf_words$14[rbp]
	mov	rcx, QWORD PTR work_bit_count$9[rbp]
	call	AllocateBlock
	mov	QWORD PTR work2_buf$15[rbp], rax

; 140  :             if (work1_buf == NULL)

	cmp	QWORD PTR work1_buf$12[rbp], 0
	jne	SHORT $LN11@PMC_Pow_X_

; 141  :             {
; 142  :                 DeallocateBlock(work1_buf, work1_buf_words);

	mov	rdx, QWORD PTR work1_buf_words$11[rbp]
	mov	rcx, QWORD PTR work1_buf$12[rbp]
	call	DeallocateBlock

; 143  :                 return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@PMC_Pow_X_
$LN11@PMC_Pow_X_:

; 144  :             }
; 145  :             __UNIT_TYPE z_check_code;
; 146  :             if ((result = AllocateNumber(z, work_bit_count, &z_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR z_check_code$16[rbp]
	mov	rdx, QWORD PTR work_bit_count$9[rbp]
	mov	rcx, QWORD PTR z$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN12@PMC_Pow_X_

; 147  :             {
; 148  :                 DeallocateBlock(work1_buf, work1_buf_words);

	mov	rdx, QWORD PTR work1_buf_words$11[rbp]
	mov	rcx, QWORD PTR work1_buf$12[rbp]
	call	DeallocateBlock

; 149  :                 DeallocateBlock(work2_buf, work2_buf_words);

	mov	rdx, QWORD PTR work2_buf_words$14[rbp]
	mov	rcx, QWORD PTR work2_buf$15[rbp]
	call	DeallocateBlock

; 150  :                 return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@PMC_Pow_X_
$LN12@PMC_Pow_X_:

; 151  :             }
; 152  : 
; 153  :             Pow_Imp(x->BLOCK, x->UNIT_WORD_COUNT, n, work1_buf, work2_buf, (*z)->BLOCK);

	mov	rax, QWORD PTR z$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR work2_buf$15[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR work1_buf$12[rbp]
	mov	r8d, DWORD PTR n$[rbp]
	mov	rax, QWORD PTR x$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	Pow_Imp

; 154  : 
; 155  :             if ((result = CheckBlockLight(work1_buf, work1_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work1_buf_code$10[rbp]
	mov	rcx, QWORD PTR work1_buf$12[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN13@PMC_Pow_X_

; 156  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_Pow_X_
$LN13@PMC_Pow_X_:

; 157  :             if ((result = CheckBlockLight(work2_buf, work2_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work2_buf_code$13[rbp]
	mov	rcx, QWORD PTR work2_buf$15[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN14@PMC_Pow_X_

; 158  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Pow_X_
$LN14@PMC_Pow_X_:

; 159  :             if ((result = CheckBlockLight((*z)->BLOCK, z_check_code)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR z$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR z_check_code$16[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN15@PMC_Pow_X_

; 160  :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Pow_X_
$LN15@PMC_Pow_X_:

; 161  :             DeallocateBlock(work1_buf, work1_buf_words);

	mov	rdx, QWORD PTR work1_buf_words$11[rbp]
	mov	rcx, QWORD PTR work1_buf$12[rbp]
	call	DeallocateBlock

; 162  :             DeallocateBlock(work2_buf, work2_buf_words);

	mov	rdx, QWORD PTR work2_buf_words$14[rbp]
	mov	rcx, QWORD PTR work2_buf$15[rbp]
	call	DeallocateBlock

; 163  :             CommitNumber(*z);

	mov	rax, QWORD PTR z$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CommitNumber
$LN7@PMC_Pow_X_:
$LN3@PMC_Pow_X_:

; 164  :         }
; 165  :     }
; 166  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Pow_X_:

; 167  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:PMC_Pow_X_I_Imp$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+520]
	pop	rdi
	pop	rbp
	ret	0
PMC_Pow_X_I_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_pow.c
;	COMDAT Pow_Imp
_TEXT	SEGMENT
n_mask$ = 4
u_ptr$ = 40
v_ptr$ = 72
w_ptr$ = 104
u_count$ = 136
v_count$ = 168
t_ptr$1 = 200
x_buf$ = 448
x_buf_count$ = 456
n$ = 464
work1_buf$ = 472
work2_buf$ = 480
z_buf$ = 488
Pow_Imp	PROC						; COMDAT

; 39   : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 472				; 000001d8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 118				; 00000076H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+504]
	lea	rcx, OFFSET FLAT:__336CEE9B_pmc_pow@c
	call	__CheckForDebuggerJustMyCode

; 40   :     _UINT32_T n_mask = 1;

	mov	DWORD PTR n_mask$[rbp], 1

; 41   :     n_mask = _rotr(n_mask, _LZCNT_ALT_32(n) + 1);

	mov	ecx, DWORD PTR n$[rbp]
	call	_LZCNT_ALT_32
	inc	eax
	movzx	ecx, al
	mov	eax, DWORD PTR n_mask$[rbp]
	ror	eax, cl
	mov	DWORD PTR n_mask$[rbp], eax

; 42   : 
; 43   :     // この時点で n & n_mask は 0ではないはず
; 44   : 
; 45   :     __UNIT_TYPE* u_ptr = work1_buf;

	mov	rax, QWORD PTR work1_buf$[rbp]
	mov	QWORD PTR u_ptr$[rbp], rax

; 46   :     __UNIT_TYPE* v_ptr = x_buf;

	mov	rax, QWORD PTR x_buf$[rbp]
	mov	QWORD PTR v_ptr$[rbp], rax

; 47   :     __UNIT_TYPE* w_ptr = work2_buf;

	mov	rax, QWORD PTR work2_buf$[rbp]
	mov	QWORD PTR w_ptr$[rbp], rax

; 48   :     __UNIT_TYPE u_count = x_buf_count;

	mov	rax, QWORD PTR x_buf_count$[rbp]
	mov	QWORD PTR u_count$[rbp], rax

; 49   :     __UNIT_TYPE v_count = x_buf_count;

	mov	rax, QWORD PTR x_buf_count$[rbp]
	mov	QWORD PTR v_count$[rbp], rax

; 50   :     _COPY_MEMORY_UNIT(work1_buf, x_buf, x_buf_count);

	mov	r8, QWORD PTR x_buf_count$[rbp]
	mov	rdx, QWORD PTR x_buf$[rbp]
	mov	rcx, QWORD PTR work1_buf$[rbp]
	call	_COPY_MEMORY_UNIT

; 51   :     n_mask >>= 1;

	mov	eax, DWORD PTR n_mask$[rbp]
	shr	eax, 1
	mov	DWORD PTR n_mask$[rbp], eax
$LN2@Pow_Imp:

; 52   :     while (n_mask != 0)

	cmp	DWORD PTR n_mask$[rbp], 0
	je	$LN3@Pow_Imp

; 53   :     {
; 54   :         // u を自乗して w に格納する
; 55   :         _ZERO_MEMORY_UNIT(w_ptr, u_count * 2);

	mov	rax, QWORD PTR u_count$[rbp]
	add	rax, rax
	mov	rdx, rax
	mov	rcx, QWORD PTR w_ptr$[rbp]
	call	_ZERO_MEMORY_UNIT

; 56   :         Multiply_X_X_Imp(u_ptr, u_count, u_ptr, u_count, w_ptr);

	mov	rax, QWORD PTR w_ptr$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR u_count$[rbp]
	mov	r8, QWORD PTR u_ptr$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR u_ptr$[rbp]
	call	Multiply_X_X_Imp

; 57   :         u_count *= 2;

	mov	rax, QWORD PTR u_count$[rbp]
	add	rax, rax
	mov	QWORD PTR u_count$[rbp], rax

; 58   :         if (w_ptr[u_count - 1] == 0)

	mov	rax, QWORD PTR w_ptr$[rbp]
	mov	rcx, QWORD PTR u_count$[rbp]
	cmp	QWORD PTR [rax+rcx*8-8], 0
	jne	SHORT $LN4@Pow_Imp

; 59   :             --u_count;

	mov	rax, QWORD PTR u_count$[rbp]
	dec	rax
	mov	QWORD PTR u_count$[rbp], rax
$LN4@Pow_Imp:

; 60   : 
; 61   :         // n の該当桁の bit を調べる
; 62   :         if (n & n_mask)

	mov	eax, DWORD PTR n_mask$[rbp]
	mov	ecx, DWORD PTR n$[rbp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	$LN5@Pow_Imp

; 63   :         {
; 64   :             // bit が立っていたら u = w * v とする
; 65   :             _ZERO_MEMORY_UNIT(u_ptr, u_count + v_count);

	mov	rax, QWORD PTR v_count$[rbp]
	mov	rcx, QWORD PTR u_count$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR u_ptr$[rbp]
	call	_ZERO_MEMORY_UNIT

; 66   :             Multiply_X_X_Imp(w_ptr, u_count, v_ptr, v_count, u_ptr);

	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v_count$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_count$[rbp]
	mov	rcx, QWORD PTR w_ptr$[rbp]
	call	Multiply_X_X_Imp

; 67   :             u_count += v_count;

	mov	rax, QWORD PTR v_count$[rbp]
	mov	rcx, QWORD PTR u_count$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR u_count$[rbp], rax

; 68   :             if (u_ptr[u_count - 1] == 0)

	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	rcx, QWORD PTR u_count$[rbp]
	cmp	QWORD PTR [rax+rcx*8-8], 0
	jne	SHORT $LN7@Pow_Imp

; 69   :                 --u_count;

	mov	rax, QWORD PTR u_count$[rbp]
	dec	rax
	mov	QWORD PTR u_count$[rbp], rax
$LN7@Pow_Imp:

; 70   :         }

	jmp	SHORT $LN6@Pow_Imp
$LN5@Pow_Imp:

; 71   :         else
; 72   :         {
; 73   :             // u と w を交換する
; 74   :             __UNIT_TYPE* t_ptr = u_ptr;

	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	QWORD PTR t_ptr$1[rbp], rax

; 75   :             u_ptr = w_ptr;

	mov	rax, QWORD PTR w_ptr$[rbp]
	mov	QWORD PTR u_ptr$[rbp], rax

; 76   :             w_ptr = t_ptr;

	mov	rax, QWORD PTR t_ptr$1[rbp]
	mov	QWORD PTR w_ptr$[rbp], rax
$LN6@Pow_Imp:

; 77   :         }
; 78   : 
; 79   :         n_mask >>= 1;

	mov	eax, DWORD PTR n_mask$[rbp]
	shr	eax, 1
	mov	DWORD PTR n_mask$[rbp], eax

; 80   :     }

	jmp	$LN2@Pow_Imp
$LN3@Pow_Imp:

; 81   :     _COPY_MEMORY_UNIT(z_buf, u_ptr, u_count);

	mov	r8, QWORD PTR u_count$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	mov	rcx, QWORD PTR z_buf$[rbp]
	call	_COPY_MEMORY_UNIT

; 82   : }

	lea	rsp, QWORD PTR [rbp+424]
	pop	rdi
	pop	rbp
	ret	0
Pow_Imp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _LZCNT_ALT_32
_TEXT	SEGMENT
pos$ = 4
x$ = 256
_LZCNT_ALT_32 PROC					; COMDAT

; 856  : {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 857  :     if (x == 0)

	cmp	DWORD PTR x$[rbp], 0
	jne	SHORT $LN2@LZCNT_ALT_

; 858  :         return (sizeof(x) * 8);

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN1@LZCNT_ALT_
$LN2@LZCNT_ALT_:

; 859  :     _UINT32_T pos;
; 860  : #ifdef _MSC_VER
; 861  :     _BitScanReverse(&pos, x);

	mov	eax, DWORD PTR x$[rbp]
	bsr	eax, eax
	mov	DWORD PTR pos$[rbp], eax

; 862  : #elif defined(__GNUC__)
; 863  :     __asm__( "bsrl %1, %0" : "=r"(pos) : "rm"(x) );
; 864  : #else
; 865  : #error unknown compiler
; 866  : #endif
; 867  :     return (sizeof(x) * 8 - 1 - pos);

	mov	eax, DWORD PTR pos$[rbp]
	mov	ecx, 31
	sub	rcx, rax
	mov	rax, rcx
$LN1@LZCNT_ALT_:

; 868  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_LZCNT_ALT_32$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_LZCNT_ALT_32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _ZERO_MEMORY_UNIT
_TEXT	SEGMENT
d$ = 224
count$ = 232
_ZERO_MEMORY_UNIT PROC					; COMDAT

; 376  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 377  : #ifdef _M_IX86
; 378  :     __stosd((unsigned long*)d, 0, (unsigned long)count);
; 379  : #elif defined(_M_X64)
; 380  :     __stosq(d, 0, count);

	mov	rdi, QWORD PTR d$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR count$[rbp]
	rep stosq

; 381  : #else
; 382  : #error unknown platform
; 383  : #endif
; 384  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ZERO_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _COPY_MEMORY_UNIT
_TEXT	SEGMENT
d$ = 224
s$ = 232
count$ = 240
_COPY_MEMORY_UNIT PROC					; COMDAT

; 326  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4522B509_pmc_internal@h
	call	__CheckForDebuggerJustMyCode

; 327  : #ifdef _M_IX86
; 328  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 329  : #elif defined(_M_X64)
; 330  :     __movsq(d, s, count);

	mov	rdi, QWORD PTR d$[rbp]
	mov	rsi, QWORD PTR s$[rbp]
	mov	rcx, QWORD PTR count$[rbp]
	rep movsq

; 331  : #else
; 332  : #error unknown platform
; 333  : #endif
; 334  : }

	lea	rsp, QWORD PTR [rbp+192]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
_COPY_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_pow.c
;	COMDAT PMC_Pow_X_I
_TEXT	SEGMENT
result$ = 4
x$ = 256
n$ = 264
z$ = 272
PMC_Pow_X_I PROC					; COMDAT

; 170  : {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__336CEE9B_pmc_pow@c
	call	__CheckForDebuggerJustMyCode

; 171  :     if (__UNIT_TYPE_BIT_COUNT < sizeof(n) * 8)

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_Pow_X_

; 172  :     {
; 173  :         // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
; 174  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_Pow_X_
$LN2@PMC_Pow_X_:

; 175  :     }
; 176  :     if (x == NULL)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN3@PMC_Pow_X_

; 177  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_Pow_X_
$LN3@PMC_Pow_X_:

; 178  :     if (z == NULL)

	cmp	QWORD PTR z$[rbp], 0
	jne	SHORT $LN4@PMC_Pow_X_

; 179  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_Pow_X_
$LN4@PMC_Pow_X_:

; 180  :     PMC_STATUS_CODE result;
; 181  :     if ((result = CheckNumber((NUMBER_HEADER*)x)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR x$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_Pow_X_

; 182  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Pow_X_
$LN5@PMC_Pow_X_:

; 183  :     if ((result = PMC_Pow_X_I_Imp((NUMBER_HEADER*)x, n, (NUMBER_HEADER**)z)) != PMC_STATUS_OK)

	mov	r8, QWORD PTR z$[rbp]
	mov	edx, DWORD PTR n$[rbp]
	mov	rcx, QWORD PTR x$[rbp]
	call	PMC_Pow_X_I_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_Pow_X_

; 184  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Pow_X_
$LN6@PMC_Pow_X_:

; 185  : #ifdef _DEBUG
; 186  :     if ((result = CheckNumber(*z)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR z$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN7@PMC_Pow_X_

; 187  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_Pow_X_
$LN7@PMC_Pow_X_:

; 188  : #endif
; 189  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_Pow_X_:

; 190  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
PMC_Pow_X_I ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_pow.c
;	COMDAT Initialize_Pow
_TEXT	SEGMENT
feature$ = 224
Initialize_Pow PROC					; COMDAT

; 193  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__336CEE9B_pmc_pow@c
	call	__CheckForDebuggerJustMyCode

; 194  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 195  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Initialize_Pow ENDP
_TEXT	ENDS
END
