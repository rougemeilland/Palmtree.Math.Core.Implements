; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	From_I_Imp
PUBLIC	From_L_Imp
PUBLIC	Initialize_From
PUBLIC	PMC_From_I
PUBLIC	PMC_From_L
PUBLIC	PMC_From_B
EXTRN	AllocateNumber:PROC
EXTRN	CommitNumber:PROC
EXTRN	number_zero:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$From_I_Imp DD imagerel $LN8
	DD	imagerel $LN8+93
	DD	imagerel $unwind$From_I_Imp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$From_L_Imp DD imagerel $LN24
	DD	imagerel $LN24+78
	DD	imagerel $unwind$From_L_Imp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_From_I DD imagerel $LN14
	DD	imagerel $LN14+122
	DD	imagerel $unwind$PMC_From_I
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_From_L DD imagerel $LN30
	DD	imagerel $LN30+111
	DD	imagerel $unwind$PMC_From_L
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_From_B DD imagerel $LN29
	DD	imagerel $LN29+34
	DD	imagerel $unwind$PMC_From_B
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PMC_From_B DD imagerel $LN29+34
	DD	imagerel $LN29+94
	DD	imagerel $chain$0$PMC_From_B
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PMC_From_B DD imagerel $LN29+94
	DD	imagerel $LN29+198
	DD	imagerel $chain$2$PMC_From_B
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PMC_From_B DD imagerel $LN29+198
	DD	imagerel $LN29+214
	DD	imagerel $chain$3$PMC_From_B
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_COPY_MEMORY_BYTE DD imagerel _COPY_MEMORY_BYTE
	DD	imagerel _COPY_MEMORY_BYTE+32
	DD	imagerel $unwind$_COPY_MEMORY_BYTE
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_COPY_MEMORY_BYTE DD 040a01H
	DD	02740aH
	DD	016405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PMC_From_B DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+34
	DD	imagerel $unwind$PMC_From_B
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PMC_From_B DD 020021H
	DD	077400H
	DD	imagerel $LN29
	DD	imagerel $LN29+34
	DD	imagerel $unwind$PMC_From_B
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PMC_From_B DD 020521H
	DD	077405H
	DD	imagerel $LN29
	DD	imagerel $LN29+34
	DD	imagerel $unwind$PMC_From_B
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_From_B DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_From_L DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_From_I DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$From_L_Imp DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$From_I_Imp DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
;	COMDAT CountActualBitsFromBuffer
_TEXT	SEGMENT
p$ = 8
count$ = 16
CountActualBitsFromBuffer PROC				; COMDAT

; 135  :     p += count;

	add	rcx, rdx
	mov	r8, rdx

; 136  :     while (count > 0)

	test	rdx, rdx
	je	SHORT $LN3@CountActua
	npad	5
$LL2@CountActua:

; 137  :     {
; 138  :         --p;
; 139  :         if (*p != 0)

	movzx	eax, BYTE PTR [rcx-1]
	lea	rcx, QWORD PTR [rcx-1]
	test	al, al
	jne	SHORT $LN10@CountActua

; 141  :         --count;

	sub	r8, 1
	jne	SHORT $LL2@CountActua
$LN3@CountActua:

; 142  :     }
; 143  :     return (0);

	xor	eax, eax

; 144  : }

	ret	0
$LN10@CountActua:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 797  :     _BitScanReverse(&pos, x);

	movzx	eax, al

; 803  :     return ((unsigned char)(sizeof(x) * 8 - 1 - pos));

	mov	edx, 7
	bsr	ecx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c

; 140  :             return (count * 8 - _LZCNT_ALT_8(*p));

	lea	rax, QWORD PTR [r8*8]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 803  :     return ((unsigned char)(sizeof(x) * 8 - 1 - pos));

	sub	dl, cl
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c

; 140  :             return (count * 8 - _LZCNT_ALT_8(*p));

	movzx	ecx, dl
	sub	rax, rcx

; 144  : }

	ret	0
CountActualBitsFromBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _LZCNT_ALT_UNIT
_TEXT	SEGMENT
x$ = 8
_LZCNT_ALT_UNIT PROC					; COMDAT

; 841  :     if (x == 0)

	test	rcx, rcx
	jne	SHORT $LN2@LZCNT_ALT_

; 842  :         return (sizeof(x) * 8);

	mov	eax, 64					; 00000040H

; 866  : }

	ret	0
$LN2@LZCNT_ALT_:

; 843  : #ifdef _M_IX86
; 844  :     _UINT32_T pos;
; 845  : #ifdef _MSC_VER
; 846  :     _BitScanReverse(&pos, x);
; 847  : #elif defined(__GNUC__)
; 848  :     __asm__("bsrl %1, %0" : "=r"(pos) : "rm"(x));
; 849  : #else
; 850  : #error unknown compiler
; 851  : #endif
; 852  : #elif defined(_M_X64)
; 853  : #ifdef _MSC_VER
; 854  :     _UINT32_T pos;
; 855  :     _BitScanReverse64(&pos, x);

	bsr	rcx, rcx

; 856  : #elif defined(__GNUC__)
; 857  :     _UINT64_T pos;
; 858  :     __asm__("bsrq %1, %0" : "=r"(pos) : "rm"(x));
; 859  : #else
; 860  : #error unknown compiler
; 861  : #endif
; 862  : #else
; 863  : #error unknown platform
; 864  : #endif
; 865  :     return (sizeof(x) * 8 - 1 - pos);

	mov	eax, 63					; 0000003fH
	sub	rax, rcx

; 866  : }

	ret	0
_LZCNT_ALT_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _LZCNT_ALT_32
_TEXT	SEGMENT
x$ = 8
_LZCNT_ALT_32 PROC					; COMDAT

; 808  :     if (x == 0)

	test	ecx, ecx
	jne	SHORT $LN2@LZCNT_ALT_

; 809  :         return (sizeof(x) * 8);

	mov	eax, 32					; 00000020H

; 819  : }

	ret	0
$LN2@LZCNT_ALT_:

; 810  :     _UINT32_T pos;
; 811  : #ifdef _MSC_VER
; 812  :     _BitScanReverse(&pos, x);

	bsr	ecx, ecx

; 813  : #elif defined(__GNUC__)
; 814  :     __asm__( "bsrl %1, %0" : "=r"(pos) : "rm"(x) );
; 815  : #else
; 816  : #error unknown compiler
; 817  : #endif
; 818  :     return (sizeof(x) * 8 - 1 - pos);

	mov	eax, 31
	sub	eax, ecx

; 819  : }

	ret	0
_LZCNT_ALT_32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _LZCNT_ALT_8
_TEXT	SEGMENT
x$ = 8
_LZCNT_ALT_8 PROC					; COMDAT

; 793  :     if (x == 0)

	test	cl, cl
	jne	SHORT $LN2@LZCNT_ALT_

; 794  :         return (sizeof(x) * 8);

	mov	al, 8

; 804  : }

	ret	0
$LN2@LZCNT_ALT_:

; 795  :     _UINT32_T pos;
; 796  : #ifdef _MSC_VER
; 797  :     _BitScanReverse(&pos, x);

	movzx	eax, cl
	bsr	ecx, eax

; 798  : #elif defined(__GNUC__)
; 799  :     __asm__( "bsrl %1, %0" : "=r"(pos) : "rm"((_UINT32_T)x) );
; 800  : #else
; 801  : #error unknown compiler
; 802  : #endif
; 803  :     return ((unsigned char)(sizeof(x) * 8 - 1 - pos));

	mov	eax, 7
	sub	al, cl

; 804  : }

	ret	0
_LZCNT_ALT_8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _DIVIDE_CEILING_SIZE
_TEXT	SEGMENT
u$ = 8
v$ = 16
_DIVIDE_CEILING_SIZE PROC				; COMDAT

; 410  :     return ((u + v - 1) / v);

	lea	rax, QWORD PTR [rdx-1]
	mov	r8, rdx
	add	rax, rcx
	xor	edx, edx
	div	r8

; 411  : }

	ret	0
_DIVIDE_CEILING_SIZE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _FROMDWORDTOWORD
_TEXT	SEGMENT
value$ = 8
result_high$ = 16
_FROMDWORDTOWORD PROC					; COMDAT

; 394  :     *result_high = (_UINT32_T)(value >> 32);

	mov	rax, rcx
	shr	rax, 32					; 00000020H
	mov	DWORD PTR [rdx], eax

; 395  :     return ((_UINT32_T)value);

	mov	eax, ecx

; 396  : }

	ret	0
_FROMDWORDTOWORD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _COPY_MEMORY_BYTE
_TEXT	SEGMENT
d$ = 8
s$ = 16
count$ = 24
_COPY_MEMORY_BYTE PROC					; COMDAT

; 260  : {

	mov	QWORD PTR [rsp+8], rsi
	mov	QWORD PTR [rsp+16], rdi

; 261  :     __movsb(d, s, count);

	mov	rdi, rcx
	mov	rsi, rdx
	mov	rcx, r8
	rep movsb

; 262  : }

	mov	rsi, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
_COPY_MEMORY_BYTE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
;	COMDAT PMC_From_B
_TEXT	SEGMENT
p$1 = 48
buffer$ = 48
count$ = 56
o$ = 64
PMC_From_B PROC						; COMDAT

; 148  : {

$LN29:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rsi, rcx

; 149  :     PMC_STATUS_CODE result;
; 150  :     if (buffer == NULL)

	test	rcx, rcx
	je	$LN26@PMC_From_B

; 151  :         return (PMC_STATUS_ARGUMENT_ERROR);
; 152  :     if (o == NULL)

	test	rbx, rbx
	je	$LN26@PMC_From_B

; 135  :     p += count;

	mov	QWORD PTR [rsp+56], rdi
	lea	rax, QWORD PTR [rcx+rdx]

; 136  :     while (count > 0)

	test	rdx, rdx
	je	SHORT $LN25@PMC_From_B
$LL9@PMC_From_B:

; 137  :     {
; 138  :         --p;
; 139  :         if (*p != 0)

	movzx	ecx, BYTE PTR [rax-1]
	lea	rax, QWORD PTR [rax-1]
	test	cl, cl
	jne	SHORT $LN21@PMC_From_B

; 141  :         --count;

	sub	rdx, 1
	jne	SHORT $LL9@PMC_From_B
$LN25@PMC_From_B:

; 156  :         *o = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR [r8], rax

; 165  :     }
; 166  : #ifdef _DEBUG
; 167  :     if ((result = CheckNumber(*o)) != PMC_STATUS_OK)
; 168  :         return (result);
; 169  : #endif
; 170  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN27@PMC_From_B:
	mov	rdi, QWORD PTR [rsp+56]

; 171  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN21@PMC_From_B:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 797  :     _BitScanReverse(&pos, x);

	movzx	eax, cl
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c

; 140  :             return (count * 8 - _LZCNT_ALT_8(*p));

	lea	rdi, QWORD PTR [rdx*8]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 797  :     _BitScanReverse(&pos, x);

	bsr	ecx, eax

; 798  : #elif defined(__GNUC__)
; 799  :     __asm__( "bsrl %1, %0" : "=r"(pos) : "rm"((_UINT32_T)x) );
; 800  : #else
; 801  : #error unknown compiler
; 802  : #endif
; 803  :     return ((unsigned char)(sizeof(x) * 8 - 1 - pos));

	mov	eax, 7
	sub	al, cl
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c

; 140  :             return (count * 8 - _LZCNT_ALT_8(*p));

	movzx	eax, al
	sub	rdi, rax

; 153  :         return (PMC_STATUS_ARGUMENT_ERROR);
; 154  :     __UNIT_TYPE bit_count = CountActualBitsFromBuffer(buffer, count);
; 155  :     if (bit_count == 0)

	je	SHORT $LN25@PMC_From_B

; 157  :     else
; 158  :     {
; 159  :         NUMBER_HEADER* p;
; 160  :         if ((result = AllocateNumber(&p, bit_count, NULL)) != PMC_STATUS_OK)

	xor	r8d, r8d
	lea	rcx, QWORD PTR p$1[rsp]
	mov	rdx, rdi
	call	AllocateNumber
	test	eax, eax
	jne	SHORT $LN27@PMC_From_B
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 410  :     return ((u + v - 1) / v);

	lea	rcx, QWORD PTR [rdi+7]

; 261  :     __movsb(d, s, count);

	mov	rdi, QWORD PTR p$1[rsp]

; 410  :     return ((u + v - 1) / v);

	shr	rcx, 3

; 261  :     __movsb(d, s, count);

	mov	rdi, QWORD PTR [rdi+48]
	rep movsb
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c

; 163  :         CommitNumber(p);

	mov	rcx, QWORD PTR p$1[rsp]
	call	CommitNumber

; 164  :         *o = p;

	mov	rax, QWORD PTR p$1[rsp]
	mov	rdi, QWORD PTR [rsp+56]
	mov	QWORD PTR [rbx], rax

; 165  :     }
; 166  : #ifdef _DEBUG
; 167  :     if ((result = CheckNumber(*o)) != PMC_STATUS_OK)
; 168  :         return (result);
; 169  : #endif
; 170  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 171  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN26@PMC_From_B:
	mov	rbx, QWORD PTR [rsp+64]
	mov	eax, -1
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
PMC_From_B ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
;	COMDAT PMC_From_L
_TEXT	SEGMENT
p$ = 48
x$ = 48
o$ = 56
PMC_From_L PROC						; COMDAT

; 110  : {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 111  :     NUMBER_HEADER* p;
; 112  :     PMC_STATUS_CODE result;
; 113  :     if (sizeof(__UNIT_TYPE) * 2 < sizeof(x))
; 114  :     {
; 115  :         // 32bit–¢–ž‚ÌCPU‚É‚Í–¢‘Î‰ž
; 116  :         return (PMC_STATUS_INTERNAL_ERROR);
; 117  :     }
; 118  :     if (x == 0)

	test	rcx, rcx
	jne	SHORT $LN3@PMC_From_L

; 119  :         *o = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR [rdx], rax

; 125  :     }
; 126  : #ifdef _DEBUG
; 127  :     if ((result = CheckNumber(*o)) != PMC_STATUS_OK)
; 128  :         return (result);
; 129  : #endif
; 130  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 131  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@PMC_From_L:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 855  :     _BitScanReverse64(&pos, x);

	bsr	rdx, rbx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c

; 80   :         if ((result = AllocateNumber(o, x_bit_length, NULL)) != PMC_STATUS_OK)

	xor	r8d, r8d
	lea	rcx, QWORD PTR p$[rsp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 865  :     return (sizeof(x) * 8 - 1 - pos);

	inc	rdx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c

; 80   :         if ((result = AllocateNumber(o, x_bit_length, NULL)) != PMC_STATUS_OK)

	call	AllocateNumber
	test	eax, eax
	jne	SHORT $LN7@PMC_From_L

; 81   :             return (result);
; 82   :         (*o)->BLOCK[0] = (__UNIT_TYPE)x;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	mov	QWORD PTR [rcx], rbx

; 83   :     }
; 84   :     CommitNumber(*o);

	mov	rcx, QWORD PTR p$[rsp]
	call	CommitNumber

; 120  :     else
; 121  :     {
; 122  :         if ((result = From_L_Imp(x, &p)) != PMC_STATUS_OK)
; 123  :             return (result);
; 124  :         *o = p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rdi], rax

; 125  :     }
; 126  : #ifdef _DEBUG
; 127  :     if ((result = CheckNumber(*o)) != PMC_STATUS_OK)
; 128  :         return (result);
; 129  : #endif
; 130  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN7@PMC_From_L:

; 131  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
PMC_From_L ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
;	COMDAT PMC_From_I
_TEXT	SEGMENT
x$ = 48
o$ = 56
p$1 = 64
PMC_From_I PROC						; COMDAT

; 89   : {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, ecx
	mov	rdi, rdx

; 90   :     PMC_STATUS_CODE result;
; 91   :     if (sizeof(__UNIT_TYPE) < sizeof(x))
; 92   :         return (PMC_STATUS_INTERNAL_ERROR);
; 93   :     if (x == 0)

	test	ecx, ecx
	jne	SHORT $LN3@PMC_From_I

; 94   :         *o = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR [rdx], rax

; 101  :     }
; 102  : #ifdef _DEBUG
; 103  :     if ((result = CheckNumber(*o)) != PMC_STATUS_OK)
; 104  :         return (result);
; 105  : #endif
; 106  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 107  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@PMC_From_I:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 812  :     _BitScanReverse(&pos, x);

	bsr	eax, ebx

; 818  :     return (sizeof(x) * 8 - 1 - pos);

	mov	ecx, 31
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c

; 39   :     if ((result = AllocateNumber(o, sizeof(x) * 8 - _LZCNT_ALT_32(x), NULL)) != PMC_STATUS_OK)

	mov	edx, 32					; 00000020H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 818  :     return (sizeof(x) * 8 - 1 - pos);

	sub	ecx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c

; 39   :     if ((result = AllocateNumber(o, sizeof(x) * 8 - _LZCNT_ALT_32(x), NULL)) != PMC_STATUS_OK)

	xor	r8d, r8d
	mov	eax, ecx
	lea	rcx, QWORD PTR p$1[rsp]
	sub	rdx, rax
	call	AllocateNumber
	test	eax, eax
	jne	SHORT $LN7@PMC_From_I

; 40   :         return (result);
; 41   :     (*o)->BLOCK[0] = x;

	mov	rax, QWORD PTR p$1[rsp]
	mov	rcx, QWORD PTR [rax+48]
	mov	QWORD PTR [rcx], rbx

; 42   :     CommitNumber(*o);

	mov	rcx, QWORD PTR p$1[rsp]
	call	CommitNumber

; 95   :     else
; 96   :     {
; 97   :         NUMBER_HEADER* p;
; 98   :         if ((result = From_I_Imp(x, &p)) != PMC_STATUS_OK)
; 99   :             return (result);
; 100  :         *o = p;

	mov	rax, QWORD PTR p$1[rsp]
	mov	QWORD PTR [rdi], rax

; 101  :     }
; 102  : #ifdef _DEBUG
; 103  :     if ((result = CheckNumber(*o)) != PMC_STATUS_OK)
; 104  :         return (result);
; 105  : #endif
; 106  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN7@PMC_From_I:

; 107  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
PMC_From_I ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
;	COMDAT Initialize_From
_TEXT	SEGMENT
feature$ = 8
Initialize_From PROC					; COMDAT

; 175  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 176  : }

	ret	0
Initialize_From ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
;	COMDAT From_L_Imp
_TEXT	SEGMENT
x$ = 48
o$ = 56
From_L_Imp PROC						; COMDAT

; 47   : {

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 841  :     if (x == 0)

	test	rcx, rcx
	jne	SHORT $LN21@From_L_Imp

; 842  :         return (sizeof(x) * 8);

	xor	edx, edx
	jmp	SHORT $LN20@From_L_Imp
$LN21@From_L_Imp:

; 843  : #ifdef _M_IX86
; 844  :     _UINT32_T pos;
; 845  : #ifdef _MSC_VER
; 846  :     _BitScanReverse(&pos, x);
; 847  : #elif defined(__GNUC__)
; 848  :     __asm__("bsrl %1, %0" : "=r"(pos) : "rm"(x));
; 849  : #else
; 850  : #error unknown compiler
; 851  : #endif
; 852  : #elif defined(_M_X64)
; 853  : #ifdef _MSC_VER
; 854  :     _UINT32_T pos;
; 855  :     _BitScanReverse64(&pos, x);

	bsr	rdx, rbx

; 856  : #elif defined(__GNUC__)
; 857  :     _UINT64_T pos;
; 858  :     __asm__("bsrq %1, %0" : "=r"(pos) : "rm"(x));
; 859  : #else
; 860  : #error unknown compiler
; 861  : #endif
; 862  : #else
; 863  : #error unknown platform
; 864  : #endif
; 865  :     return (sizeof(x) * 8 - 1 - pos);

	inc	rdx
$LN20@From_L_Imp:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c

; 80   :         if ((result = AllocateNumber(o, x_bit_length, NULL)) != PMC_STATUS_OK)

	xor	r8d, r8d
	mov	rcx, rdi
	call	AllocateNumber
	test	eax, eax
	jne	SHORT $LN1@From_L_Imp

; 81   :             return (result);
; 82   :         (*o)->BLOCK[0] = (__UNIT_TYPE)x;

	mov	rax, QWORD PTR [rdi]
	mov	rcx, QWORD PTR [rax+48]
	mov	QWORD PTR [rcx], rbx

; 83   :     }
; 84   :     CommitNumber(*o);

	mov	rcx, QWORD PTR [rdi]
	call	CommitNumber

; 85   :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@From_L_Imp:

; 86   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
From_L_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c
;	COMDAT From_I_Imp
_TEXT	SEGMENT
x$ = 48
o$ = 56
From_I_Imp PROC						; COMDAT

; 37   : {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, ecx
	mov	rdi, rdx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 808  :     if (x == 0)

	mov	edx, 32					; 00000020H
	test	ecx, ecx
	jne	SHORT $LN5@From_I_Imp

; 809  :         return (sizeof(x) * 8);

	mov	r8d, edx
	jmp	SHORT $LN4@From_I_Imp
$LN5@From_I_Imp:

; 810  :     _UINT32_T pos;
; 811  : #ifdef _MSC_VER
; 812  :     _BitScanReverse(&pos, x);

	bsr	eax, ebx

; 813  : #elif defined(__GNUC__)
; 814  :     __asm__( "bsrl %1, %0" : "=r"(pos) : "rm"(x) );
; 815  : #else
; 816  : #error unknown compiler
; 817  : #endif
; 818  :     return (sizeof(x) * 8 - 1 - pos);

	mov	r8d, 31
	sub	r8d, eax
$LN4@From_I_Imp:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_from.c

; 39   :     if ((result = AllocateNumber(o, sizeof(x) * 8 - _LZCNT_ALT_32(x), NULL)) != PMC_STATUS_OK)

	mov	eax, r8d
	mov	rcx, rdi
	sub	rdx, rax
	xor	r8d, r8d
	call	AllocateNumber
	test	eax, eax
	jne	SHORT $LN1@From_I_Imp

; 40   :         return (result);
; 41   :     (*o)->BLOCK[0] = x;

	mov	rax, QWORD PTR [rdi]
	mov	rcx, QWORD PTR [rax+48]
	mov	QWORD PTR [rcx], rbx

; 42   :     CommitNumber(*o);

	mov	rcx, QWORD PTR [rdi]
	call	CommitNumber

; 43   :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@From_I_Imp:

; 44   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
From_I_Imp ENDP
_TEXT	ENDS
END
