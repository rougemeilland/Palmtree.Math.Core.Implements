; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	Initialize_ToString
PUBLIC	PMC_ToString
PUBLIC	??_C@_13DEFPDAGF@?$AA?0@			; `string'
PUBLIC	??_C@_13JOFGPIOO@?$AA?4@			; `string'
PUBLIC	??_C@_01EKENIIDA@3@				; `string'
PUBLIC	??_C@_13KJIIAINM@?$AA?$CL@			; `string'
PUBLIC	??_C@_13IMODFHAA@?$AA?9@			; `string'
EXTRN	__imp_lstrcpyA:PROC
EXTRN	__imp_lstrcpyW:PROC
EXTRN	__imp_lstrlenW:PROC
EXTRN	AllocateBlock:PROC
EXTRN	DeallocateBlock:PROC
EXTRN	CheckBlockLight:PROC
EXTRN	CheckNumber:PROC
EXTRN	DivRem_X_1W:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
default_number_format_option DB 028H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Initialize_ToString DD imagerel $LN4
	DD	imagerel $LN4+121
	DD	imagerel $unwind$Initialize_ToString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_ToString DD imagerel $LN19
	DD	imagerel $LN19+401
	DD	imagerel $unwind$PMC_ToString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_COPY_MEMORY_UNIT_DIV DD imagerel _COPY_MEMORY_UNIT_DIV
	DD	imagerel _COPY_MEMORY_UNIT_DIV+32
	DD	imagerel $unwind$_COPY_MEMORY_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ZERO_MEMORY_UNIT_DIV DD imagerel _ZERO_MEMORY_UNIT_DIV
	DD	imagerel _ZERO_MEMORY_UNIT_DIV+20
	DD	imagerel $unwind$_ZERO_MEMORY_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FILL_MEMORY_16 DD imagerel _FILL_MEMORY_16
	DD	imagerel _FILL_MEMORY_16+23
	DD	imagerel $unwind$_FILL_MEMORY_16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertCardinalNumber DD imagerel ConvertCardinalNumber
	DD	imagerel ConvertCardinalNumber+132
	DD	imagerel $unwind$ConvertCardinalNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ConvertCardinalNumber DD imagerel ConvertCardinalNumber+132
	DD	imagerel ConvertCardinalNumber+386
	DD	imagerel $chain$2$ConvertCardinalNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ConvertCardinalNumber DD imagerel ConvertCardinalNumber+386
	DD	imagerel ConvertCardinalNumber+406
	DD	imagerel $chain$3$ConvertCardinalNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitializeOutputState DD imagerel InitializeOutputState
	DD	imagerel InitializeOutputState+215
	DD	imagerel $unwind$InitializeOutputState
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OutputDecimalSeparator DD imagerel OutputDecimalSeparator
	DD	imagerel OutputDecimalSeparator+40
	DD	imagerel $unwind$OutputDecimalSeparator
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OutputOneChar DD imagerel OutputOneChar
	DD	imagerel OutputOneChar+198
	DD	imagerel $unwind$OutputOneChar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ToStringDN_LEADING_1WORD DD imagerel ToStringDN_LEADING_1WORD
	DD	imagerel ToStringDN_LEADING_1WORD+90
	DD	imagerel $unwind$ToStringDN_LEADING_1WORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ToStringDN_1WORD DD imagerel ToStringDN_1WORD
	DD	imagerel ToStringDN_1WORD+331
	DD	imagerel $unwind$ToStringDN_1WORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PrintDecimal DD imagerel PrintDecimal
	DD	imagerel PrintDecimal+2391
	DD	imagerel $unwind$PrintDecimal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ToStringDN DD imagerel ToStringDN
	DD	imagerel ToStringDN+834
	DD	imagerel $unwind$ToStringDN
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ToStringX DD imagerel ToStringX
	DD	imagerel ToStringX+289
	DD	imagerel $unwind$ToStringX
pdata	ENDS
;	COMDAT ??_C@_13IMODFHAA@?$AA?9@
CONST	SEGMENT
??_C@_13IMODFHAA@?$AA?9@ DB '-', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13KJIIAINM@?$AA?$CL@
CONST	SEGMENT
??_C@_13KJIIAINM@?$AA?$CL@ DB '+', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EKENIIDA@3@
CONST	SEGMENT
??_C@_01EKENIIDA@3@ DB '3', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13JOFGPIOO@?$AA?4@
CONST	SEGMENT
??_C@_13JOFGPIOO@?$AA?4@ DB '.', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13DEFPDAGF@?$AA?0@
CONST	SEGMENT
??_C@_13DEFPDAGF@?$AA?0@ DB ',', 00H, 00H, 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
decimal_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H, '5', 00H
	DB	'6', 00H, '7', 00H, '8', 00H, '9', 00H, 00H, 00H
	ORG $+2
hexadecimal_lower_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H
	DB	'5', 00H, '6', 00H, '7', 00H, '8', 00H, '9', 00H, 'a', 00H, 'b'
	DB	00H, 'c', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 00H, 00H
	ORG $+6
hexadecimal_upper_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H
	DB	'5', 00H, '6', 00H, '7', 00H, '8', 00H, '9', 00H, 'A', 00H, 'B'
	DB	00H, 'C', 00H, 'D', 00H, 'E', 00H, 'F', 00H, 00H, 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ToStringX DD 089b01H
	DD	06349bH
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ToStringDN DD 0b2601H
	DD	01b3426H
	DD	0120126H
	DD	0e018f01aH
	DD	0c014d016H
	DD	060117012H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PrintDecimal DD 0c2d19H
	DD	016741fH
	DD	015641fH
	DD	014341fH
	DD	0f018d21fH
	DD	0d014e016H
	DD	05010c012H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ToStringDN_1WORD DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ToStringDN_LEADING_1WORD DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OutputOneChar DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OutputDecimalSeparator DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitializeOutputState DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ConvertCardinalNumber DD 021H
	DD	imagerel ConvertCardinalNumber
	DD	imagerel ConvertCardinalNumber+132
	DD	imagerel $unwind$ConvertCardinalNumber
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ConvertCardinalNumber DD 042221H
	DD	013e422H
	DD	0105408H
	DD	imagerel ConvertCardinalNumber
	DD	imagerel ConvertCardinalNumber+132
	DD	imagerel $unwind$ConvertCardinalNumber
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertCardinalNumber DD 085001H
	DD	011c450H
	DD	0f008920cH
	DD	07004d006H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FILL_MEMORY_16 DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ZERO_MEMORY_UNIT_DIV DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_COPY_MEMORY_UNIT_DIV DD 040a01H
	DD	02740aH
	DD	016405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_ToString DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0e016521aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Initialize_ToString DD 010401H
	DD	04204H
xdata	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT ToStringX
_TEXT	SEGMENT
x$ = 48
buffer$ = 56
buffer_size$ = 64
width$ = 72
format_option$ = 80
using_upper_letter$ = 88
ToStringX PROC						; COMDAT

; 449  : {

	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 450  :     if (x->IS_ZERO)

	test	BYTE PTR [rcx+32], 2
	mov	r10, rdx
	mov	r11, rcx
	je	SHORT $LN4@ToStringX

; 451  :     {
; 452  :         // x が 0 である場合
; 453  :         // 最低で 1 桁、最高で format_option->MinimumWidth 桁だけ '0' を出力する。
; 454  : 
; 455  :         if (width < 1)
; 456  :             width = 1;
; 457  :         if (buffer_size < width + 1)

	mov	edi, 1
	cmp	r9d, edi
	cmovae	edi, r9d
	lea	ecx, DWORD PTR [rdi+1]
	cmp	r8, rcx
	jb	SHORT $LN23@ToStringX

; 458  :             return (PMC_STATUS_INSUFFICIENT_BUFFER);
; 459  :         _FILL_MEMORY_16(buffer, L'0', width);

	mov	edx, edi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 361  :     __stosw(d, x, count);

	mov	eax, 48					; 00000030H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 460  :         buffer[width] = L'\0';

	xor	esi, esi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 361  :     __stosw(d, x, count);

	mov	ecx, edx
	mov	rdi, r10
	rep stosw
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 460  :         buffer[width] = L'\0';

	mov	WORD PTR [r10+rdx*2], si

; 497  :     }
; 498  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 499  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@ToStringX:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 405  :     return ((u + v - 1) / v);

	mov	rbp, QWORD PTR [rcx+8]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 478  :         if (buffer_size < total_length + 1)

	xor	esi, esi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 405  :     return ((u + v - 1) / v);

	add	rbp, 3
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 465  :         __UNIT_TYPE output_len = _DIVIDE_CEILING_UNIT(x->UNIT_BIT_COUNT, 4);

	mov	eax, r9d
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 405  :     return ((u + v - 1) / v);

	shr	rbp, 2
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 478  :         if (buffer_size < total_length + 1)

	mov	edx, r9d
	sub	rdx, rbp
	cmp	rbp, rax
	cmovae	rax, rbp
	cmovae	rdx, rsi
	inc	rax
	cmp	r8, rax
	jae	SHORT $LN10@ToStringX
$LN23@ToStringX:

; 479  :             return (PMC_STATUS_INSUFFICIENT_BUFFER);

	mov	eax, -4

; 499  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN10@ToStringX:
	mov	QWORD PTR [rsp+48], rbx

; 480  :         __UNIT_TYPE filling_digit_count = filling_digit_len;
; 481  :         if (filling_digit_len > 0)

	test	rdx, rdx
	je	SHORT $LN17@ToStringX
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 361  :     __stosw(d, x, count);

	mov	eax, 48					; 00000030H
	mov	rdi, r10
	mov	rcx, rdx
	rep stosw
$LN17@ToStringX:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 483  :         __UNIT_TYPE* s_ptr = x->BLOCK + x->UNIT_WORD_COUNT - 1;

	mov	rdi, QWORD PTR [r11]

; 484  :         wchar_t* d_ptr = buffer + filling_digit_len;

	lea	r9, QWORD PTR [r10+rdx*2]
	mov	rax, QWORD PTR [r11+48]

; 485  :         wchar_t* digit_table = using_upper_letter ? hexadecimal_upper_digits : hexadecimal_lower_digits;

	lea	r8, OFFSET FLAT:hexadecimal_lower_digits
	cmp	DWORD PTR using_upper_letter$[rsp], esi
	lea	rbx, QWORD PTR [rax+rdi*8]

; 486  :         __UNIT_TYPE w_count = x->UNIT_WORD_COUNT;
; 487  :         d_ptr = ToStringX_1WORD(*s_ptr, (int)(x->UNIT_WORD_COUNT * (__UNIT_TYPE_BIT_COUNT / 4) - output_len), digit_table, d_ptr);

	mov	rcx, QWORD PTR [rbx-8]
	lea	rax, OFFSET FLAT:hexadecimal_upper_digits
	cmovne	r8, rax
	mov	edx, edi
	shl	edx, 4
	sub	edx, ebp
	call	ToStringX_1WORD

; 488  :         --s_ptr;

	sub	rbx, 16

; 489  :         --w_count;

	sub	rdi, 1

; 490  :         while (w_count > 0)

	je	SHORT $LN3@ToStringX
	npad	3
$LL2@ToStringX:

; 491  :         {
; 492  :             d_ptr = ToStringX_1WORD(*s_ptr, 0, digit_table, d_ptr);

	mov	rcx, QWORD PTR [rbx]
	mov	r9, rax
	xor	edx, edx
	call	ToStringX_1WORD

; 493  :             --s_ptr;

	lea	rbx, QWORD PTR [rbx-8]

; 494  :             --w_count;

	sub	rdi, 1
	jne	SHORT $LL2@ToStringX
$LN3@ToStringX:

; 495  :         }
; 496  :         *d_ptr = '\0';

	mov	rbx, QWORD PTR [rsp+48]

; 499  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	WORD PTR [rax], si
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ToStringX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT ToStringX_1WORD
_TEXT	SEGMENT
x$ = 8
skip_digit_len$ = 16
digit_table$ = 24
ptr$ = 32
ToStringX_1WORD PROC					; COMDAT

; 381  : {

	mov	r10, rcx

; 382  :     if (sizeof(__UNIT_TYPE) > sizeof(_UINT64_T))
; 383  :     {
; 384  :         // 64bit を超える __UNIT_TYPE には未対応
; 385  :         // 対応するには以降のコーディングを見直す必要がある
; 386  :         return (NULL);
; 387  :     }
; 388  :     int count = __UNIT_TYPE_BIT_COUNT / 4;

	mov	r11d, 16

; 389  :     if (skip_digit_len > 0)

	test	edx, edx
	jle	SHORT $LN3@ToStringX_

; 390  :     {
; 391  :         x = _ROTATE_L_UNIT(x, 4 * skip_digit_len);

	lea	ecx, DWORD PTR [rdx*4]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, cl
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 392  :         count -= skip_digit_len;

	sub	r11d, edx
$LN3@ToStringX_:

; 393  :     }
; 394  :     if (count & 0x10)

	test	r11b, 16
	je	$LN4@ToStringX_
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 396  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	rax, r10
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 396  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	and	eax, 15
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9], ax

; 397  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 397  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+2], ax

; 398  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 398  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+4], ax

; 399  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 399  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+6], ax

; 400  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 400  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+8], ax

; 401  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 401  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+10], ax

; 402  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 402  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+12], ax

; 403  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 403  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+14], ax

; 404  :         x = _ROTATE_L_UNIT(x, 4); ptr[8] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 404  :         x = _ROTATE_L_UNIT(x, 4); ptr[8] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+16], ax

; 405  :         x = _ROTATE_L_UNIT(x, 4); ptr[9] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 405  :         x = _ROTATE_L_UNIT(x, 4); ptr[9] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+18], ax

; 406  :         x = _ROTATE_L_UNIT(x, 4); ptr[10] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 406  :         x = _ROTATE_L_UNIT(x, 4); ptr[10] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+20], ax

; 407  :         x = _ROTATE_L_UNIT(x, 4); ptr[11] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 407  :         x = _ROTATE_L_UNIT(x, 4); ptr[11] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+22], ax

; 408  :         x = _ROTATE_L_UNIT(x, 4); ptr[12] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 408  :         x = _ROTATE_L_UNIT(x, 4); ptr[12] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+24], ax

; 409  :         x = _ROTATE_L_UNIT(x, 4); ptr[13] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 409  :         x = _ROTATE_L_UNIT(x, 4); ptr[13] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+26], ax

; 410  :         x = _ROTATE_L_UNIT(x, 4); ptr[14] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 410  :         x = _ROTATE_L_UNIT(x, 4); ptr[14] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+28], ax

; 411  :         x = _ROTATE_L_UNIT(x, 4); ptr[15] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+30], ax

; 412  :         ptr += 16;

	add	r9, 32					; 00000020H
$LN4@ToStringX_:

; 413  :     }
; 414  :     if (count & 0x8)

	test	r11b, 8
	je	$LN5@ToStringX_
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 416  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	rax, r10
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 416  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	and	eax, 15
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9], ax

; 417  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 417  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+2], ax

; 418  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 418  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+4], ax

; 419  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 419  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+6], ax

; 420  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 420  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+8], ax

; 421  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 421  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+10], ax

; 422  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 422  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+12], ax

; 423  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+14], ax

; 424  :         ptr+=8;

	add	r9, 16
$LN5@ToStringX_:

; 425  :     }
; 426  :     if (count & 0x4)

	test	r11b, 4
	je	SHORT $LN6@ToStringX_
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 428  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	rax, r10
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 428  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	and	eax, 15
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9], ax

; 429  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 429  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+2], ax

; 430  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 430  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+4], ax

; 431  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+6], ax

; 432  :         ptr += 4;

	add	r9, 8
$LN6@ToStringX_:

; 433  :     }
; 434  :     if (count & 0x2)

	test	r11b, 2
	je	SHORT $LN7@ToStringX_
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 436  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	rax, r10
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 436  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	and	eax, 15
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9], ax

; 437  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	rax, r10
	and	eax, 15
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [r9+2], ax

; 438  :         ptr += 2;

	add	r9, 4
$LN7@ToStringX_:

; 439  :     }
; 440  :     if (count & 0x1)

	test	r11b, 1
	je	SHORT $LN74@ToStringX_
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 696  :     return (_rotl64(x, count));

	rol	r10, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 442  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	and	r10d, 15
	movzx	eax, WORD PTR [r8+r10*2]
	mov	WORD PTR [r9], ax

; 443  :         ptr += 1;

	lea	rax, QWORD PTR [r9+2]

; 446  : }

	ret	0
$LN74@ToStringX_:

; 444  :     }
; 445  :     return (ptr);

	mov	rax, r9

; 446  : }

	ret	0
ToStringX_1WORD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT ToStringDN
_TEXT	SEGMENT
r_buf$1$ = 64
work_buf_1_words$1 = 72
work_buf_2$1$ = 80
r_buf_words$2 = 88
rev_str_buf_words$3 = 96
work_buf_2_code$4 = 104
work_buf_1_code$5 = 112
work_buf_2_words$6 = 120
r_buf_code$7 = 128
rev_str_buf_code$8 = 136
r_value$9 = 208
rev_str_buf_count$10 = 208
x$ = 208
buffer$ = 216
buffer_size$ = 224
format$ = 232
width$ = 240
format_option$ = 248
ToStringDN PROC						; COMDAT

; 288  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-23]
	sub	rsp, 144				; 00000090H

; 289  :     __UNIT_TYPE_DIV base_value;
; 290  :     int word_digit_count;
; 291  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 292  :     {
; 293  :         base_value = 1000000000U; // 10^9
; 294  :         word_digit_count = 9;
; 295  :     }
; 296  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 297  :     {
; 298  :         base_value = (__UNIT_TYPE_DIV)10000000000000000000UL; // 10^19
; 299  :         word_digit_count = 19;
; 300  :     }
; 301  :     else
; 302  :         return (PMC_STATUS_NOT_SUPPORTED);
; 303  : 
; 304  :     if (x->IS_ZERO)

	test	BYTE PTR [rcx+32], 2
	movzx	eax, r9b
	mov	rbx, rdx
	mov	rdi, rcx
	je	$LN6@ToStringDN

; 305  :     {
; 306  :         // x が 0 である場合
; 307  :         if (format == 'N')

	cmp	al, 78					; 0000004eH
	jne	SHORT $LN8@ToStringDN

; 308  :         {
; 309  :             // format が 'N' である場合
; 310  : 
; 311  :             // 整数部が 1 桁の 0、小数部が width 桁の 0 である文字列を出力する。
; 312  :             buffer[0] = '0';
; 313  :             if (width == 0)

	mov	r15d, DWORD PTR width$[rbp-121]
	lea	rcx, QWORD PTR [rdx+2]
	mov	r14d, 48				; 00000030H
	mov	WORD PTR [rdx], r14w
	test	r15d, r15d
	jne	SHORT $LN10@ToStringDN

; 314  :                 buffer[1] = L'\0';

	xor	eax, eax
	mov	WORD PTR [rcx], ax
	jmp	$LN7@ToStringDN
$LN10@ToStringDN:

; 315  :             else
; 316  :             {
; 317  :                 lstrcpyW(&buffer[1], format_option->DecimalSeparator);

	mov	rdi, QWORD PTR format_option$[rbp-121]
	lea	rdx, QWORD PTR [rdi+10]
	call	QWORD PTR __imp_lstrcpyW

; 318  :                 int decimal_separator_len = lstrlenW(format_option->DecimalSeparator);

	lea	rcx, QWORD PTR [rdi+10]
	call	QWORD PTR __imp_lstrlenW
	movsxd	rsi, eax

; 319  :                 _FILL_MEMORY_16(buffer + 1 + decimal_separator_len, L'0', width);

	lea	rdi, QWORD PTR [rbx+2]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 361  :     __stosw(d, x, count);

	mov	eax, r14d
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 319  :                 _FILL_MEMORY_16(buffer + 1 + decimal_separator_len, L'0', width);

	mov	rcx, r15
	lea	rdi, QWORD PTR [rdi+rsi*2]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 361  :     __stosw(d, x, count);

	rep stosw
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 320  :                 buffer[1 + decimal_separator_len + width] = L'\0';

	lea	ecx, DWORD PTR [r15+1]
	add	ecx, esi
	xor	eax, eax
	mov	WORD PTR [rbx+rcx*2], ax

; 321  :             }
; 322  :         }

	jmp	$LN7@ToStringDN
$LN8@ToStringDN:

; 323  :         else
; 324  :         {
; 325  :             // format が 'D' である場合
; 326  : 
; 327  :             // 最低で 1 桁、最高で width 桁だけ '0' を出力する。
; 328  :             if (width < 1)
; 329  :                 width = 1;
; 330  :             if (buffer_size < width + 1)

	mov	edx, 1
	cmp	DWORD PTR width$[rbp-121], edx
	cmovae	edx, DWORD PTR width$[rbp-121]
	lea	ecx, DWORD PTR [rdx+1]
	cmp	r8, rcx
	jb	$LN62@ToStringDN
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 361  :     __stosw(d, x, count);

	mov	eax, 48					; 00000030H
	mov	rdi, rbx
	mov	ecx, edx
	rep stosw
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 333  :             buffer[width] = L'\0';

	xor	eax, eax
	mov	WORD PTR [rbx+rdx*2], ax

; 334  :         }
; 335  :     }

	jmp	$LN7@ToStringDN
$LN6@ToStringDN:

; 336  :     else
; 337  :     {
; 338  :         // x が 0 ではない場合
; 339  :         PMC_STATUS_CODE result;
; 340  :         __UNIT_TYPE r_buf_code;
; 341  :         __UNIT_TYPE r_buf_words;
; 342  :         // xを base_value 基数として変換した数値が r に格納される。約 7% ほど余分に領域が必要な計算になるが、余裕を見て 12.5% 程度の領域を獲得している。
; 343  :         __UNIT_TYPE_DIV* r_buf = (__UNIT_TYPE_DIV*)AllocateBlock(x->UNIT_BIT_COUNT + (x->UNIT_BIT_COUNT >> 3) + __UNIT_TYPE_BIT_COUNT, &r_buf_words, &r_buf_code);

	mov	rcx, QWORD PTR [rcx+8]
	lea	r8, QWORD PTR r_buf_code$7[rbp-121]
	mov	rax, rcx
	lea	rdx, QWORD PTR r_buf_words$2[rbp-121]
	shr	rax, 3
	add	rcx, 64					; 00000040H
	add	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR r_buf$1$[rbp-121], rax

; 344  :         if (r_buf == NULL)

	test	rax, rax
	jne	SHORT $LN14@ToStringDN

; 345  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ToStringDN
$LN14@ToStringDN:

; 346  :         __UNIT_TYPE r_buf_count;
; 347  :         if ((result = ConvertCardinalNumber((__UNIT_TYPE_DIV*)x->BLOCK, x->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), x->UNIT_BIT_COUNT, base_value, r_buf, &r_buf_count)) != PMC_STATUS_OK)

	mov	rsi, QWORD PTR [rdi]

; 62   :     __UNIT_TYPE_DIV* work_buf_1 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_1_words, &work_buf_1_code);

	lea	r8, QWORD PTR work_buf_1_code$5[rbp-121]

; 346  :         __UNIT_TYPE r_buf_count;
; 347  :         if ((result = ConvertCardinalNumber((__UNIT_TYPE_DIV*)x->BLOCK, x->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), x->UNIT_BIT_COUNT, base_value, r_buf, &r_buf_count)) != PMC_STATUS_OK)

	mov	r14, QWORD PTR [rdi+48]

; 62   :     __UNIT_TYPE_DIV* work_buf_1 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_1_words, &work_buf_1_code);

	lea	rdx, QWORD PTR work_buf_1_words$1[rbp-121]
	mov	rdi, QWORD PTR [rdi+8]

; 346  :         __UNIT_TYPE r_buf_count;
; 347  :         if ((result = ConvertCardinalNumber((__UNIT_TYPE_DIV*)x->BLOCK, x->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), x->UNIT_BIT_COUNT, base_value, r_buf, &r_buf_count)) != PMC_STATUS_OK)

	shl	rsi, 3
	shr	rsi, 2

; 62   :     __UNIT_TYPE_DIV* work_buf_1 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_1_words, &work_buf_1_code);

	lea	rcx, QWORD PTR [rdi+64]
	call	AllocateBlock
	mov	r13, rax

; 63   :     if (work_buf_1 == NULL)

	test	rax, rax
	je	SHORT $LN61@ToStringDN

; 64   :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 65   :     __UNIT_TYPE work_buf_2_code;
; 66   :     __UNIT_TYPE work_buf_2_words;
; 67   :     __UNIT_TYPE_DIV* work_buf_2 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_2_words, &work_buf_2_code);

	lea	r8, QWORD PTR work_buf_2_code$4[rbp-121]
	lea	rdx, QWORD PTR work_buf_2_words$6[rbp-121]
	lea	rcx, QWORD PTR [rdi+64]
	call	AllocateBlock
	mov	QWORD PTR work_buf_2$1$[rbp-121], rax

; 68   :     if (work_buf_2 == NULL)

	test	rax, rax
	jne	SHORT $LN33@ToStringDN

; 69   :     {
; 70   :         DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	mov	rdx, QWORD PTR work_buf_1_words$1[rbp-121]
	mov	rcx, r13
	call	DeallocateBlock
$LN61@ToStringDN:

; 348  :         {
; 349  :             DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	edi, -5
$LN49@ToStringDN:
	mov	rdx, QWORD PTR r_buf_words$2[rbp-121]
	mov	rcx, QWORD PTR r_buf$1$[rbp-121]
	call	DeallocateBlock

; 350  :             return (result);

	mov	eax, edi
	jmp	$LN1@ToStringDN
$LN33@ToStringDN:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 293  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ecx, esi
	mov	rdi, r13
	mov	rsi, r14
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 73   :     __UNIT_TYPE_DIV* u_ptr = work_buf_1;

	mov	r15, r13

; 74   :     __UNIT_TYPE_DIV* q_ptr = work_buf_2;
; 75   :     _COPY_MEMORY_UNIT_DIV(u_ptr, x_buf, x_buf_size);
; 76   :     __UNIT_TYPE_DIV* r_ptr = r_buf;

	mov	r14, QWORD PTR r_buf$1$[rbp-121]
	mov	r12, rax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 293  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 77   :     __UNIT_TYPE work_u_count = work_buf_1_words * (sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV));

	mov	rsi, QWORD PTR work_buf_1_words$1[rbp-121]
	add	rsi, rsi

; 78   :     while (work_u_count > 0)

	je	$LN29@ToStringDN
	npad	6
$LL28@ToStringDN:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 343  :     __stosd((unsigned long*)d, 0, (unsigned long)count);

	xor	eax, eax
	mov	ecx, esi
	mov	rdi, r12
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 82   :         DivRem_X_1W(u_ptr, work_u_count, base_value, q_ptr, &r_value);

	mov	r9, r12
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 343  :     __stosd((unsigned long*)d, 0, (unsigned long)count);

	rep stosd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 82   :         DivRem_X_1W(u_ptr, work_u_count, base_value, q_ptr, &r_value);

	lea	rax, QWORD PTR r_value$9[rbp-121]
	mov	rcx, r15
	mov	r8d, 1000000000				; 3b9aca00H
	mov	QWORD PTR [rsp+32], rax
	mov	rdx, rsi
	call	DivRem_X_1W

; 83   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_2, work_buf_2_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_buf_2_code$4[rbp-121]
	mov	rcx, QWORD PTR work_buf_2$1$[rbp-121]
	call	CheckBlockLight
	mov	edi, eax
	test	eax, eax
	jne	SHORT $LN49@ToStringDN

; 84   :             return (result);
; 85   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_1, work_buf_1_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_buf_1_code$5[rbp-121]
	mov	rcx, r13
	call	CheckBlockLight
	mov	edi, eax
	test	eax, eax
	jne	$LN49@ToStringDN

; 86   :             return (result);
; 87   :         *r_ptr++ = r_value;

	mov	eax, DWORD PTR r_value$9[rbp-121]
	mov	DWORD PTR [r14], eax

; 88   :         __UNIT_TYPE_DIV* temp = u_ptr;

	mov	rax, r15
	add	r14, 4

; 89   :         u_ptr = q_ptr;

	mov	r15, r12

; 90   :         q_ptr = temp;

	mov	r12, rax

; 91   :         while (work_u_count > 0 && u_ptr[work_u_count - 1] == 0)

	test	rsi, rsi
	je	SHORT $LN29@ToStringDN

; 86   :             return (result);
; 87   :         *r_ptr++ = r_value;

	lea	rax, QWORD PTR [rsi-1]
	lea	rax, QWORD PTR [r15+rax*4]
	npad	1
$LL30@ToStringDN:

; 91   :         while (work_u_count > 0 && u_ptr[work_u_count - 1] == 0)

	cmp	DWORD PTR [rax], 0
	jne	$LN31@ToStringDN

; 92   :             --work_u_count;

	sub	rax, 4
	sub	rsi, 1
	jne	SHORT $LL30@ToStringDN
$LN29@ToStringDN:

; 93   :     }
; 94   :     *r_buf_count = r_ptr - r_buf;

	mov	r15, QWORD PTR r_buf$1$[rbp-121]

; 95   :     DeallocateBlock((__UNIT_TYPE*)work_buf_2, work_buf_2_words);

	mov	rdx, QWORD PTR work_buf_2_words$6[rbp-121]
	sub	r14, r15
	mov	rcx, QWORD PTR work_buf_2$1$[rbp-121]
	sar	r14, 2
	call	DeallocateBlock

; 96   :     DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	mov	rdx, QWORD PTR work_buf_1_words$1[rbp-121]
	mov	rcx, r13
	call	DeallocateBlock

; 351  :         }
; 352  :         if ((result = CheckBlockLight((__UNIT_TYPE*)r_buf, r_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR r_buf_code$7[rbp-121]
	mov	rcx, r15
	call	CheckBlockLight
	test	eax, eax
	jne	$LN1@ToStringDN

; 353  :             return (result);
; 354  : 
; 355  :         __UNIT_TYPE rev_str_buf_code;
; 356  :         __UNIT_TYPE rev_str_buf_words;
; 357  :         // 獲得領域長の * 2 は、桁区切りのワーストケースにより文字列が膨らんだ場合を考慮したもの。
; 358  :         wchar_t* rev_str_buf = (wchar_t*)AllocateBlock((max(r_buf_count * word_digit_count, width) * 2 + width + 2) * sizeof(wchar_t) * 8, &rev_str_buf_words, &rev_str_buf_code);

	mov	edi, DWORD PTR width$[rbp-121]
	lea	rcx, QWORD PTR [r14+r14*8]
	cmp	rcx, rdi
	lea	r8, QWORD PTR rev_str_buf_code$8[rbp-121]
	lea	rdx, QWORD PTR rev_str_buf_words$3[rbp-121]
	cmovbe	rcx, rdi
	lea	rax, QWORD PTR [rdi+2]
	lea	rcx, QWORD PTR [rax+rcx*2]
	shl	rcx, 4
	call	AllocateBlock

; 359  :         if (r_buf == NULL)
; 360  :         {
; 361  :             DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);
; 362  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 363  :         }
; 364  :         __UNIT_TYPE rev_str_buf_count;
; 365  :         PrintDecimal(r_buf, r_buf_count, rev_str_buf, &rev_str_buf_count, format, width, format_option);

	mov	rcx, QWORD PTR format_option$[rbp-121]
	lea	r9, QWORD PTR rev_str_buf_count$10[rbp-121]
	mov	QWORD PTR [rsp+48], rcx
	mov	rsi, rax
	movzx	eax, BYTE PTR format$[rbp-121]
	mov	rcx, r15
	mov	DWORD PTR [rsp+40], edi
	mov	r8, rsi
	mov	rdx, r14
	mov	BYTE PTR [rsp+32], al
	call	PrintDecimal

; 366  :         if ((result = CheckBlockLight((__UNIT_TYPE*)rev_str_buf, rev_str_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR rev_str_buf_code$8[rbp-121]
	mov	rcx, rsi
	call	CheckBlockLight
	test	eax, eax
	jne	SHORT $LN1@ToStringDN

; 367  :             return (result);
; 368  :         DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	rdx, QWORD PTR r_buf_words$2[rbp-121]
	mov	rcx, r15
	call	DeallocateBlock

; 369  :         if (rev_str_buf_count + 1 > buffer_size)

	mov	rdx, QWORD PTR rev_str_buf_count$10[rbp-121]
	lea	rax, QWORD PTR [rdx+1]
	cmp	rax, QWORD PTR buffer_size$[rbp-121]
	jbe	SHORT $LN19@ToStringDN

; 370  :         {
; 371  :             DeallocateBlock((__UNIT_TYPE*)rev_str_buf, rev_str_buf_words);

	mov	rdx, QWORD PTR rev_str_buf_words$3[rbp-121]
	mov	rcx, rsi
	call	DeallocateBlock
$LN62@ToStringDN:

; 378  : }

	mov	eax, -4
	jmp	SHORT $LN1@ToStringDN
$LN31@ToStringDN:

; 78   :     while (work_u_count > 0)

	test	rsi, rsi
	jne	$LL28@ToStringDN
	jmp	$LN29@ToStringDN
$LN19@ToStringDN:

; 276  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	lea	rcx, QWORD PTR [rdx-1]
	lea	rcx, QWORD PTR [rsi+rcx*2]

; 277  :     wchar_t* out_ptr = out_buf;
; 278  :     __UNIT_TYPE count = in_buf_count;

	test	rdx, rdx

; 279  :     while (count > 0)

	je	SHORT $LN43@ToStringDN
	npad	12
$LL42@ToStringDN:

; 280  :     {
; 281  :         *out_ptr++ = *in_ptr--;

	movzx	eax, WORD PTR [rcx]
	lea	rcx, QWORD PTR [rcx-2]
	mov	WORD PTR [rbx], ax
	add	rbx, 2

; 282  :         --count;

	sub	rdx, 1
	jne	SHORT $LL42@ToStringDN
$LN43@ToStringDN:

; 372  :             return (PMC_STATUS_INSUFFICIENT_BUFFER);
; 373  :         }
; 374  :         ToStringDN_Finalize(rev_str_buf, rev_str_buf_count, buffer, buffer_size);
; 375  :         DeallocateBlock((__UNIT_TYPE*)rev_str_buf, rev_str_buf_words);

	mov	rdx, QWORD PTR rev_str_buf_words$3[rbp-121]

; 284  :     *out_ptr = L'\0';

	xor	eax, eax

; 372  :             return (PMC_STATUS_INSUFFICIENT_BUFFER);
; 373  :         }
; 374  :         ToStringDN_Finalize(rev_str_buf, rev_str_buf_count, buffer, buffer_size);
; 375  :         DeallocateBlock((__UNIT_TYPE*)rev_str_buf, rev_str_buf_words);

	mov	rcx, rsi

; 284  :     *out_ptr = L'\0';

	mov	WORD PTR [rbx], ax

; 372  :             return (PMC_STATUS_INSUFFICIENT_BUFFER);
; 373  :         }
; 374  :         ToStringDN_Finalize(rev_str_buf, rev_str_buf_count, buffer, buffer_size);
; 375  :         DeallocateBlock((__UNIT_TYPE*)rev_str_buf, rev_str_buf_words);

	call	DeallocateBlock
$LN7@ToStringDN:

; 376  :     }
; 377  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringDN:

; 378  : }

	mov	rbx, QWORD PTR [rsp+216]
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ToStringDN ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT ToStringDN_Finalize
_TEXT	SEGMENT
in_buf$ = 8
in_buf_count$ = 16
out_buf$ = 24
out_buf_count$ = 32
ToStringDN_Finalize PROC				; COMDAT

; 276  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	lea	r9, QWORD PTR [rdx-1]
	lea	r9, QWORD PTR [rcx+r9*2]

; 277  :     wchar_t* out_ptr = out_buf;
; 278  :     __UNIT_TYPE count = in_buf_count;
; 279  :     while (count > 0)

	test	rdx, rdx
	je	SHORT $LN9@ToStringDN
	npad	3
$LL2@ToStringDN:

; 280  :     {
; 281  :         *out_ptr++ = *in_ptr--;

	movzx	eax, WORD PTR [r9]
	lea	r9, QWORD PTR [r9-2]
	mov	WORD PTR [r8], ax
	lea	r8, QWORD PTR [r8+2]

; 282  :         --count;

	sub	rdx, 1
	jne	SHORT $LL2@ToStringDN
$LN9@ToStringDN:

; 283  :     }
; 284  :     *out_ptr = L'\0';
; 285  : }

	xor	eax, eax
	mov	WORD PTR [r8], ax
	ret	0
ToStringDN_Finalize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT PrintDecimal
_TEXT	SEGMENT
out_buf_count$GSCopy$1$ = 32
state$ = 40
__$ArrayPad$ = 96
in_buf$ = 160
in_buf_count$ = 168
out_buf$ = 176
out_buf_count$ = 184
format$ = 192
width$ = 200
format_option$ = 208
PrintDecimal PROC					; COMDAT

; 233  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-112], rax
	mov	rdi, QWORD PTR format_option$[rbp-112]
	mov	r15, rcx

; 102  :     state->FORMAT = format;

	movzx	r13d, BYTE PTR format$[rbp-112]

; 233  : {

	mov	r12, r8
	mov	QWORD PTR out_buf_count$GSCopy$1$[rbp-112], r9
	mov	rsi, rdx

; 102  :     state->FORMAT = format;

	mov	BYTE PTR state$[rbp-112], r13b

; 103  : 
; 104  :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(format_option->GroupSeparator);

	lea	rbx, QWORD PTR [rdi+4]
	mov	rcx, rbx
	call	QWORD PTR __imp_lstrlenW
	mov	DWORD PTR state$[rbp-88], eax

; 105  :     wchar_t* in_ptr = format_option->GroupSeparator;
; 106  :     wchar_t* out_ptr = state->GROUP_SEPARATOR + state->GROUP_SEPARATOR_LENGTH;
; 107  :     *out_ptr-- = '\0';

	xor	r14d, r14d
	cdqe
	lea	rcx, QWORD PTR state$[rbp-110]
	lea	rcx, QWORD PTR [rcx+rax*2]

; 108  :     while (*in_ptr != L'\0')

	movzx	eax, WORD PTR [rbx]
	mov	WORD PTR [rcx], r14w
	sub	rcx, 2
	test	ax, ax
	je	SHORT $LN14@PrintDecim
	npad	12
$LL13@PrintDecim:

; 109  :     {
; 110  :         *out_ptr = *in_ptr;

	mov	WORD PTR [rcx], ax

; 111  :         --out_ptr;
; 112  :         ++in_ptr;

	lea	rbx, QWORD PTR [rbx+2]
	movzx	eax, WORD PTR [rbx]
	lea	rcx, QWORD PTR [rcx-2]
	test	ax, ax
	jne	SHORT $LL13@PrintDecim
$LN14@PrintDecim:

; 113  :     }
; 114  : 
; 115  :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(format_option->DecimalSeparator);

	lea	rbx, QWORD PTR [rdi+10]
	mov	rcx, rbx
	call	QWORD PTR __imp_lstrlenW
	mov	DWORD PTR state$[rbp-84], eax

; 116  :     in_ptr = format_option->DecimalSeparator;
; 117  :     out_ptr = state->DECIMAL_SEPARATOR + state->DECIMAL_SEPARATOR_LENGTH;

	lea	rcx, QWORD PTR state$[rbp-100]
	cdqe
	lea	rcx, QWORD PTR [rcx+rax*2]

; 118  :     *out_ptr-- = '\0';
; 119  :     while (*in_ptr != L'\0')

	movzx	eax, WORD PTR [rbx]
	mov	WORD PTR [rcx], r14w
	sub	rcx, 2
	test	ax, ax
	je	SHORT $LN16@PrintDecim
	npad	3
$LL15@PrintDecim:

; 120  :     {
; 121  :         *out_ptr = *in_ptr;

	mov	WORD PTR [rcx], ax

; 122  :         --out_ptr;
; 123  :         ++in_ptr;

	lea	rbx, QWORD PTR [rbx+2]
	movzx	eax, WORD PTR [rbx]
	lea	rcx, QWORD PTR [rcx-2]
	test	ax, ax
	jne	SHORT $LL15@PrintDecim
$LN16@PrintDecim:

; 124  :     }
; 125  : 
; 126  :     state->CURRENT_GROUP = &format_option->GroupSizes[0];

	lea	rax, QWORD PTR [rdi+28]

; 128  :     state->CURRENT_GROUP_INDEX = 0;
; 129  :     state->OUT_PTR = out_buf;

	mov	r8, r12
	mov	QWORD PTR state$[rbp-80], rax
	movsx	ecx, BYTE PTR [rax]
	sub	ecx, 48					; 00000030H
	mov	DWORD PTR state$[rbp-68], r14d

; 234  :     struct TOSTRINGN_OUTPUT_STATE state;
; 235  :     InitializeOutputState(&state, out_buf, format, format_option);
; 236  :     if (format == 'N' && width > 0)

	mov	r14d, DWORD PTR width$[rbp-112]

; 127  :     state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	mov	DWORD PTR state$[rbp-72], ecx

; 128  :     state->CURRENT_GROUP_INDEX = 0;
; 129  :     state->OUT_PTR = out_buf;

	mov	QWORD PTR state$[rbp-64], r12

; 234  :     struct TOSTRINGN_OUTPUT_STATE state;
; 235  :     InitializeOutputState(&state, out_buf, format, format_option);
; 236  :     if (format == 'N' && width > 0)

	cmp	r13b, 78				; 0000004eH
	jne	SHORT $LN20@PrintDecim
	test	r14d, r14d
	je	SHORT $LN20@PrintDecim

; 237  :     {
; 238  :         _UINT32_T count = width;

	movzx	edx, WORD PTR decimal_digits
	mov	eax, r14d
	npad	8
$LL2@PrintDecim:

; 140  :     *state->OUT_PTR = decimal_digits[x];

	mov	WORD PTR [r8], dx

; 141  :     state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2
	mov	QWORD PTR state$[rbp-64], r8

; 239  :         while (count > 0)
; 240  :         {
; 241  :             OutputUngroupedOneChar(&state, 0);
; 242  :             --count;

	add	eax, -1					; ffffffffH
	jne	SHORT $LL2@PrintDecim

; 134  :     lstrcpyW(state->OUT_PTR, state->DECIMAL_SEPARATOR);

	lea	rdx, QWORD PTR state$[rbp-100]
	mov	rcx, r8
	call	QWORD PTR __imp_lstrcpyW

; 135  :     state->OUT_PTR += state->DECIMAL_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp-64]
	movsxd	rcx, DWORD PTR state$[rbp-84]
	lea	r8, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR state$[rbp-64], r8
$LN20@PrintDecim:

; 243  :         }
; 244  :         OutputDecimalSeparator(&state);
; 245  :     }
; 246  :     __UNIT_TYPE_DIV* in_ptr = in_buf;
; 247  :     __UNIT_TYPE in_count = in_buf_count - 1;
; 248  :     while (in_count != 0)

	lea	r10, OFFSET FLAT:decimal_digits
	sub	rsi, 1
	je	$LN5@PrintDecim
	mov	r13, -3689348814741910323		; cccccccccccccccdH
	npad	3
$LL4@PrintDecim:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	edi, DWORD PTR [r15]

; 602  :         return ((_UINT32_T)(t / v));

	mov	rax, r13
	mul	rdi
	mov	rbx, rdx
	shr	rbx, 3
	lea	eax, DWORD PTR [rbx+rbx*4]
	add	eax, eax
	sub	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 146  :     if (state->FORMAT == 'N')

	cmp	BYTE PTR state$[rbp-112], 78		; 0000004eH
	jne	$LN187@PrintDecim

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR state$[rbp-72]
	test	eax, eax
	jle	SHORT $LN189@PrintDecim
	cmp	DWORD PTR state$[rbp-68], eax
	jl	SHORT $LN189@PrintDecim

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	rdx, QWORD PTR state$[rbp-110]
	mov	rcx, r8
	call	QWORD PTR __imp_lstrcpyW

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp-64]

; 156  :             *state->OUT_PTR = decimal_digits[x];

	lea	r10, OFFSET FLAT:decimal_digits
	movsxd	rcx, DWORD PTR state$[rbp-88]

; 158  :             state->CURRENT_GROUP_INDEX = 1;

	mov	r9d, 1
	lea	rdx, QWORD PTR [rax+rcx*2]
	movzx	eax, WORD PTR [r10+rdi*2]
	mov	QWORD PTR state$[rbp-64], rdx
	mov	WORD PTR [rdx], ax
	mov	r8, QWORD PTR state$[rbp-64]

; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	rax, QWORD PTR state$[rbp-80]
	add	r8, 2
	inc	rax
	mov	QWORD PTR state$[rbp-64], r8
	mov	DWORD PTR state$[rbp-68], r9d
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN188@PrintDecim

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	QWORD PTR state$[rbp-80], rax

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR state$[rbp-72], eax

; 165  :             }
; 166  :         }

	jmp	SHORT $LN188@PrintDecim
$LN189@PrintDecim:

; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rdi*2]
	mov	WORD PTR [r8], ax

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	mov	r9d, DWORD PTR state$[rbp-68]
	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2
	inc	r9d
	mov	DWORD PTR state$[rbp-68], r9d

; 173  :         }
; 174  :     }

	jmp	SHORT $LN358@PrintDecim
$LN187@PrintDecim:

; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rdi*2]
	mov	WORD PTR [r8], ax

; 180  :         state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	mov	r9d, DWORD PTR state$[rbp-68]
	add	r8, 2
$LN358@PrintDecim:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	QWORD PTR state$[rbp-64], r8
$LN188@PrintDecim:
	mov	ecx, ebx

; 602  :         return ((_UINT32_T)(t / v));

	mov	rax, r13
	mul	rcx
	mov	rdi, rdx
	shr	rdi, 3
	lea	eax, DWORD PTR [rdi+rdi*4]
	add	eax, eax
	sub	ebx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 146  :     if (state->FORMAT == 'N')

	cmp	BYTE PTR state$[rbp-112], 78		; 0000004eH
	jne	$LN202@PrintDecim

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR state$[rbp-72]
	test	eax, eax
	jle	SHORT $LN204@PrintDecim
	cmp	r9d, eax
	jl	SHORT $LN204@PrintDecim

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	rdx, QWORD PTR state$[rbp-110]
	mov	rcx, r8
	call	QWORD PTR __imp_lstrcpyW

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp-64]

; 156  :             *state->OUT_PTR = decimal_digits[x];

	lea	r10, OFFSET FLAT:decimal_digits
	movsxd	rcx, DWORD PTR state$[rbp-88]

; 158  :             state->CURRENT_GROUP_INDEX = 1;

	mov	r9d, 1
	lea	rdx, QWORD PTR [rax+rcx*2]
	movzx	eax, WORD PTR [r10+rbx*2]
	mov	QWORD PTR state$[rbp-64], rdx
	mov	WORD PTR [rdx], ax
	mov	r8, QWORD PTR state$[rbp-64]

; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	rax, QWORD PTR state$[rbp-80]
	add	r8, 2
	inc	rax
	mov	QWORD PTR state$[rbp-64], r8
	mov	DWORD PTR state$[rbp-68], r9d
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN203@PrintDecim

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	QWORD PTR state$[rbp-80], rax

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR state$[rbp-72], eax

; 165  :             }
; 166  :         }

	jmp	SHORT $LN203@PrintDecim
$LN204@PrintDecim:

; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rbx*2]
	mov	WORD PTR [r8], ax

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	mov	r9d, DWORD PTR state$[rbp-68]
	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2
	inc	r9d
	mov	DWORD PTR state$[rbp-68], r9d

; 173  :         }
; 174  :     }

	jmp	SHORT $LN359@PrintDecim
$LN202@PrintDecim:

; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rbx*2]
	mov	WORD PTR [r8], ax

; 180  :         state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	mov	r9d, DWORD PTR state$[rbp-68]
	add	r8, 2
$LN359@PrintDecim:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	QWORD PTR state$[rbp-64], r8
$LN203@PrintDecim:
	mov	ecx, edi

; 602  :         return ((_UINT32_T)(t / v));

	mov	rax, r13
	mul	rcx
	mov	rbx, rdx
	shr	rbx, 3
	lea	eax, DWORD PTR [rbx+rbx*4]
	add	eax, eax
	sub	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 146  :     if (state->FORMAT == 'N')

	cmp	BYTE PTR state$[rbp-112], 78		; 0000004eH
	jne	$LN217@PrintDecim

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR state$[rbp-72]
	test	eax, eax
	jle	SHORT $LN219@PrintDecim
	cmp	r9d, eax
	jl	SHORT $LN219@PrintDecim

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	rdx, QWORD PTR state$[rbp-110]
	mov	rcx, r8
	call	QWORD PTR __imp_lstrcpyW

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp-64]

; 156  :             *state->OUT_PTR = decimal_digits[x];

	lea	r10, OFFSET FLAT:decimal_digits
	movsxd	rcx, DWORD PTR state$[rbp-88]

; 158  :             state->CURRENT_GROUP_INDEX = 1;

	mov	r9d, 1
	lea	rdx, QWORD PTR [rax+rcx*2]
	movzx	eax, WORD PTR [r10+rdi*2]
	mov	QWORD PTR state$[rbp-64], rdx
	mov	WORD PTR [rdx], ax
	mov	r8, QWORD PTR state$[rbp-64]

; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	rax, QWORD PTR state$[rbp-80]
	add	r8, 2
	inc	rax
	mov	QWORD PTR state$[rbp-64], r8
	mov	DWORD PTR state$[rbp-68], r9d
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN218@PrintDecim

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	QWORD PTR state$[rbp-80], rax

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR state$[rbp-72], eax

; 165  :             }
; 166  :         }

	jmp	SHORT $LN218@PrintDecim
$LN219@PrintDecim:

; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rdi*2]
	mov	WORD PTR [r8], ax

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	mov	r9d, DWORD PTR state$[rbp-68]
	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2
	inc	r9d
	mov	DWORD PTR state$[rbp-68], r9d

; 173  :         }
; 174  :     }

	jmp	SHORT $LN360@PrintDecim
$LN217@PrintDecim:

; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rdi*2]
	mov	WORD PTR [r8], ax

; 180  :         state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	mov	r9d, DWORD PTR state$[rbp-68]
	add	r8, 2
$LN360@PrintDecim:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	QWORD PTR state$[rbp-64], r8
$LN218@PrintDecim:
	mov	ecx, ebx

; 602  :         return ((_UINT32_T)(t / v));

	mov	rax, r13
	mul	rcx
	mov	rdi, rdx
	shr	rdi, 3
	lea	eax, DWORD PTR [rdi+rdi*4]
	add	eax, eax
	sub	ebx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 146  :     if (state->FORMAT == 'N')

	cmp	BYTE PTR state$[rbp-112], 78		; 0000004eH
	jne	$LN232@PrintDecim

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR state$[rbp-72]
	test	eax, eax
	jle	SHORT $LN234@PrintDecim
	cmp	r9d, eax
	jl	SHORT $LN234@PrintDecim

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	rdx, QWORD PTR state$[rbp-110]
	mov	rcx, r8
	call	QWORD PTR __imp_lstrcpyW

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp-64]

; 156  :             *state->OUT_PTR = decimal_digits[x];

	lea	r10, OFFSET FLAT:decimal_digits
	movsxd	rcx, DWORD PTR state$[rbp-88]

; 158  :             state->CURRENT_GROUP_INDEX = 1;

	mov	r9d, 1
	lea	rdx, QWORD PTR [rax+rcx*2]
	movzx	eax, WORD PTR [r10+rbx*2]
	mov	QWORD PTR state$[rbp-64], rdx
	mov	WORD PTR [rdx], ax
	mov	r8, QWORD PTR state$[rbp-64]

; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	rax, QWORD PTR state$[rbp-80]
	add	r8, 2
	inc	rax
	mov	QWORD PTR state$[rbp-64], r8
	mov	DWORD PTR state$[rbp-68], r9d
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN233@PrintDecim

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	QWORD PTR state$[rbp-80], rax

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR state$[rbp-72], eax

; 165  :             }
; 166  :         }

	jmp	SHORT $LN233@PrintDecim
$LN234@PrintDecim:

; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rbx*2]
	mov	WORD PTR [r8], ax

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	mov	r9d, DWORD PTR state$[rbp-68]
	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2
	inc	r9d
	mov	DWORD PTR state$[rbp-68], r9d

; 173  :         }
; 174  :     }

	jmp	SHORT $LN361@PrintDecim
$LN232@PrintDecim:

; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rbx*2]
	mov	WORD PTR [r8], ax

; 180  :         state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	mov	r9d, DWORD PTR state$[rbp-68]
	add	r8, 2
$LN361@PrintDecim:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	QWORD PTR state$[rbp-64], r8
$LN233@PrintDecim:
	mov	ecx, edi

; 602  :         return ((_UINT32_T)(t / v));

	mov	rax, r13
	mul	rcx
	mov	rbx, rdx
	shr	rbx, 3
	lea	eax, DWORD PTR [rbx+rbx*4]
	add	eax, eax
	sub	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 146  :     if (state->FORMAT == 'N')

	cmp	BYTE PTR state$[rbp-112], 78		; 0000004eH
	jne	$LN247@PrintDecim

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR state$[rbp-72]
	test	eax, eax
	jle	SHORT $LN249@PrintDecim
	cmp	r9d, eax
	jl	SHORT $LN249@PrintDecim

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	rdx, QWORD PTR state$[rbp-110]
	mov	rcx, r8
	call	QWORD PTR __imp_lstrcpyW

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp-64]

; 156  :             *state->OUT_PTR = decimal_digits[x];

	lea	r10, OFFSET FLAT:decimal_digits
	movsxd	rcx, DWORD PTR state$[rbp-88]

; 158  :             state->CURRENT_GROUP_INDEX = 1;

	mov	r9d, 1
	lea	rdx, QWORD PTR [rax+rcx*2]
	movzx	eax, WORD PTR [r10+rdi*2]
	mov	QWORD PTR state$[rbp-64], rdx
	mov	WORD PTR [rdx], ax
	mov	r8, QWORD PTR state$[rbp-64]

; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	rax, QWORD PTR state$[rbp-80]
	add	r8, 2
	inc	rax
	mov	QWORD PTR state$[rbp-64], r8
	mov	DWORD PTR state$[rbp-68], r9d
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN248@PrintDecim

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	QWORD PTR state$[rbp-80], rax

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR state$[rbp-72], eax

; 165  :             }
; 166  :         }

	jmp	SHORT $LN248@PrintDecim
$LN249@PrintDecim:

; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rdi*2]
	mov	WORD PTR [r8], ax

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	mov	r9d, DWORD PTR state$[rbp-68]
	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2
	inc	r9d
	mov	DWORD PTR state$[rbp-68], r9d

; 173  :         }
; 174  :     }

	jmp	SHORT $LN362@PrintDecim
$LN247@PrintDecim:

; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rdi*2]
	mov	WORD PTR [r8], ax

; 180  :         state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	mov	r9d, DWORD PTR state$[rbp-68]
	add	r8, 2
$LN362@PrintDecim:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	QWORD PTR state$[rbp-64], r8
$LN248@PrintDecim:
	mov	ecx, ebx

; 602  :         return ((_UINT32_T)(t / v));

	mov	rax, r13
	mul	rcx
	mov	rdi, rdx
	shr	rdi, 3
	lea	eax, DWORD PTR [rdi+rdi*4]
	add	eax, eax
	sub	ebx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 146  :     if (state->FORMAT == 'N')

	cmp	BYTE PTR state$[rbp-112], 78		; 0000004eH
	jne	$LN262@PrintDecim

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR state$[rbp-72]
	test	eax, eax
	jle	SHORT $LN264@PrintDecim
	cmp	r9d, eax
	jl	SHORT $LN264@PrintDecim

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	rdx, QWORD PTR state$[rbp-110]
	mov	rcx, r8
	call	QWORD PTR __imp_lstrcpyW

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp-64]

; 156  :             *state->OUT_PTR = decimal_digits[x];

	lea	r10, OFFSET FLAT:decimal_digits
	movsxd	rcx, DWORD PTR state$[rbp-88]

; 158  :             state->CURRENT_GROUP_INDEX = 1;

	mov	r9d, 1
	lea	rdx, QWORD PTR [rax+rcx*2]
	movzx	eax, WORD PTR [r10+rbx*2]
	mov	QWORD PTR state$[rbp-64], rdx
	mov	WORD PTR [rdx], ax
	mov	r8, QWORD PTR state$[rbp-64]

; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	rax, QWORD PTR state$[rbp-80]
	add	r8, 2
	inc	rax
	mov	QWORD PTR state$[rbp-64], r8
	mov	DWORD PTR state$[rbp-68], r9d
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN263@PrintDecim

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	QWORD PTR state$[rbp-80], rax

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR state$[rbp-72], eax

; 165  :             }
; 166  :         }

	jmp	SHORT $LN263@PrintDecim
$LN264@PrintDecim:

; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rbx*2]
	mov	WORD PTR [r8], ax

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	mov	r9d, DWORD PTR state$[rbp-68]
	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2
	inc	r9d
	mov	DWORD PTR state$[rbp-68], r9d

; 173  :         }
; 174  :     }

	jmp	SHORT $LN363@PrintDecim
$LN262@PrintDecim:

; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rbx*2]
	mov	WORD PTR [r8], ax

; 180  :         state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	mov	r9d, DWORD PTR state$[rbp-68]
	add	r8, 2
$LN363@PrintDecim:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	QWORD PTR state$[rbp-64], r8
$LN263@PrintDecim:
	mov	ecx, edi

; 602  :         return ((_UINT32_T)(t / v));

	mov	rax, r13
	mul	rcx
	mov	rbx, rdx
	shr	rbx, 3
	lea	eax, DWORD PTR [rbx+rbx*4]
	add	eax, eax
	sub	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 146  :     if (state->FORMAT == 'N')

	cmp	BYTE PTR state$[rbp-112], 78		; 0000004eH
	jne	$LN277@PrintDecim

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR state$[rbp-72]
	test	eax, eax
	jle	SHORT $LN279@PrintDecim
	cmp	r9d, eax
	jl	SHORT $LN279@PrintDecim

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	rdx, QWORD PTR state$[rbp-110]
	mov	rcx, r8
	call	QWORD PTR __imp_lstrcpyW

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp-64]

; 156  :             *state->OUT_PTR = decimal_digits[x];

	lea	r10, OFFSET FLAT:decimal_digits
	movsxd	rcx, DWORD PTR state$[rbp-88]

; 158  :             state->CURRENT_GROUP_INDEX = 1;

	mov	r9d, 1
	lea	rdx, QWORD PTR [rax+rcx*2]
	movzx	eax, WORD PTR [r10+rdi*2]
	mov	QWORD PTR state$[rbp-64], rdx
	mov	WORD PTR [rdx], ax
	mov	r8, QWORD PTR state$[rbp-64]

; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	rax, QWORD PTR state$[rbp-80]
	add	r8, 2
	inc	rax
	mov	QWORD PTR state$[rbp-64], r8
	mov	DWORD PTR state$[rbp-68], r9d
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN278@PrintDecim

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	QWORD PTR state$[rbp-80], rax

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR state$[rbp-72], eax

; 165  :             }
; 166  :         }

	jmp	SHORT $LN278@PrintDecim
$LN279@PrintDecim:

; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rdi*2]
	mov	WORD PTR [r8], ax

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	mov	r9d, DWORD PTR state$[rbp-68]
	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2
	inc	r9d
	mov	DWORD PTR state$[rbp-68], r9d

; 173  :         }
; 174  :     }

	jmp	SHORT $LN364@PrintDecim
$LN277@PrintDecim:

; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rdi*2]
	mov	WORD PTR [r8], ax

; 180  :         state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	mov	r9d, DWORD PTR state$[rbp-68]
	add	r8, 2
$LN364@PrintDecim:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	QWORD PTR state$[rbp-64], r8
$LN278@PrintDecim:
	mov	ecx, ebx

; 602  :         return ((_UINT32_T)(t / v));

	mov	rax, r13
	mul	rcx
	mov	rdi, rdx
	shr	rdi, 3
	lea	eax, DWORD PTR [rdi+rdi*4]
	add	eax, eax
	sub	ebx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 146  :     if (state->FORMAT == 'N')

	cmp	BYTE PTR state$[rbp-112], 78		; 0000004eH
	jne	$LN292@PrintDecim

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR state$[rbp-72]
	test	eax, eax
	jle	SHORT $LN294@PrintDecim
	cmp	r9d, eax
	jl	SHORT $LN294@PrintDecim

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	rdx, QWORD PTR state$[rbp-110]
	mov	rcx, r8
	call	QWORD PTR __imp_lstrcpyW

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp-64]

; 156  :             *state->OUT_PTR = decimal_digits[x];

	lea	r10, OFFSET FLAT:decimal_digits
	movsxd	rcx, DWORD PTR state$[rbp-88]
	lea	rdx, QWORD PTR [rax+rcx*2]
	movzx	eax, WORD PTR [r10+rbx*2]
	mov	QWORD PTR state$[rbp-64], rdx
	mov	WORD PTR [rdx], ax

; 158  :             state->CURRENT_GROUP_INDEX = 1;

	mov	edx, 1
	mov	rcx, QWORD PTR state$[rbp-64]

; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	rax, QWORD PTR state$[rbp-80]
	add	rcx, 2
	inc	rax
	mov	QWORD PTR state$[rbp-64], rcx
	mov	DWORD PTR state$[rbp-68], edx
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN293@PrintDecim

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	QWORD PTR state$[rbp-80], rax

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR state$[rbp-72], eax

; 165  :             }
; 166  :         }

	jmp	SHORT $LN293@PrintDecim
$LN294@PrintDecim:

; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rbx*2]
	mov	WORD PTR [r8], ax

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	mov	edx, DWORD PTR state$[rbp-68]
	mov	rcx, QWORD PTR state$[rbp-64]
	add	rcx, 2
	inc	edx
	mov	DWORD PTR state$[rbp-68], edx

; 173  :         }
; 174  :     }

	jmp	SHORT $LN365@PrintDecim
$LN292@PrintDecim:

; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rbx*2]
	mov	WORD PTR [r8], ax

; 180  :         state->OUT_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-64]
	mov	edx, DWORD PTR state$[rbp-68]
	add	rcx, 2
$LN365@PrintDecim:

; 146  :     if (state->FORMAT == 'N')

	mov	QWORD PTR state$[rbp-64], rcx
$LN293@PrintDecim:
	cmp	BYTE PTR state$[rbp-112], 78		; 0000004eH
	jne	SHORT $LN299@PrintDecim

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR state$[rbp-72]
	test	eax, eax
	jle	SHORT $LN301@PrintDecim
	cmp	edx, eax
	jl	SHORT $LN301@PrintDecim

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	rdx, QWORD PTR state$[rbp-110]
	call	QWORD PTR __imp_lstrcpyW

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp-64]

; 156  :             *state->OUT_PTR = decimal_digits[x];

	lea	r10, OFFSET FLAT:decimal_digits
	movsxd	rcx, DWORD PTR state$[rbp-88]
	lea	rdx, QWORD PTR [rax+rcx*2]
	mov	eax, edi
	mov	QWORD PTR state$[rbp-64], rdx
	movzx	eax, WORD PTR [r10+rax*2]
	mov	WORD PTR [rdx], ax

; 157  :             state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]

; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	rax, QWORD PTR state$[rbp-80]
	add	r8, 2
	inc	rax
	mov	QWORD PTR state$[rbp-64], r8
	mov	DWORD PTR state$[rbp-68], 1
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN300@PrintDecim

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	QWORD PTR state$[rbp-80], rax

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR state$[rbp-72], eax

; 165  :             }
; 166  :         }

	jmp	SHORT $LN300@PrintDecim
$LN301@PrintDecim:

; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	mov	eax, edi
	movzx	eax, WORD PTR [r10+rax*2]
	mov	WORD PTR [rcx], ax

; 171  :             state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	inc	DWORD PTR state$[rbp-68]

; 173  :         }
; 174  :     }

	jmp	SHORT $LN366@PrintDecim
$LN299@PrintDecim:

; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	mov	eax, edi
	movzx	eax, WORD PTR [r10+rax*2]
	mov	WORD PTR [rcx], ax

; 180  :         state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2
$LN366@PrintDecim:

; 249  :     {
; 250  :         ToStringDN_1WORD(&state, *in_ptr);
; 251  :         ++in_ptr;

	mov	QWORD PTR state$[rbp-64], r8
$LN300@PrintDecim:
	add	r15, 4

; 252  :         --in_count;

	sub	rsi, 1
	jne	$LL4@PrintDecim
	movzx	r13d, BYTE PTR format$[rbp-112]
$LN5@PrintDecim:

; 253  :     }
; 254  :     ToStringDN_LEADING_1WORD(&state, *in_ptr);

	mov	ebx, DWORD PTR [r15]
	mov	r14, -3689348814741910323		; cccccccccccccccdH
	npad	14
$LL308@PrintDecim:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	ecx, ebx

; 602  :         return ((_UINT32_T)(t / v));

	mov	rax, r14
	mul	rcx
	mov	rdi, rdx
	shr	rdi, 3
	lea	eax, DWORD PTR [rdi+rdi*4]
	add	eax, eax
	sub	ebx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 146  :     if (state->FORMAT == 'N')

	cmp	BYTE PTR state$[rbp-112], 78		; 0000004eH
	jne	SHORT $LN319@PrintDecim

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR state$[rbp-72]
	test	eax, eax
	jle	SHORT $LN321@PrintDecim
	cmp	DWORD PTR state$[rbp-68], eax
	jl	SHORT $LN321@PrintDecim

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	rdx, QWORD PTR state$[rbp-110]
	mov	rcx, r8
	call	QWORD PTR __imp_lstrcpyW

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp-64]

; 156  :             *state->OUT_PTR = decimal_digits[x];

	lea	r10, OFFSET FLAT:decimal_digits
	movsxd	rcx, DWORD PTR state$[rbp-88]
	lea	rdx, QWORD PTR [rax+rcx*2]
	movzx	eax, WORD PTR [r10+rbx*2]
	mov	QWORD PTR state$[rbp-64], rdx
	mov	WORD PTR [rdx], ax

; 157  :             state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]

; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	rax, QWORD PTR state$[rbp-80]
	add	r8, 2
	inc	rax
	mov	QWORD PTR state$[rbp-64], r8
	mov	DWORD PTR state$[rbp-68], 1
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN306@PrintDecim

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	QWORD PTR state$[rbp-80], rax

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR state$[rbp-72], eax

; 165  :             }
; 166  :         }

	jmp	SHORT $LN306@PrintDecim
$LN321@PrintDecim:

; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rbx*2]
	mov	WORD PTR [r8], ax

; 171  :             state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	inc	DWORD PTR state$[rbp-68]

; 173  :         }
; 174  :     }

	jmp	SHORT $LN367@PrintDecim
$LN319@PrintDecim:

; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	movzx	eax, WORD PTR [r10+rbx*2]
	mov	WORD PTR [r8], ax

; 180  :         state->OUT_PTR += 1;

	mov	r8, QWORD PTR state$[rbp-64]
	add	r8, 2
$LN367@PrintDecim:

; 192  :     } while (x != 0);

	mov	QWORD PTR state$[rbp-64], r8
$LN306@PrintDecim:
	mov	ebx, edi
	test	edi, edi
	jne	$LL308@PrintDecim

; 255  :     ++in_ptr;
; 256  :     --in_count;
; 257  :     if (format == 'D')

	mov	r14d, DWORD PTR width$[rbp-112]
	cmp	r13b, 68				; 00000044H
	jne	SHORT $LN7@PrintDecim

; 258  :     {
; 259  :         if (state.OUT_PTR < out_buf + width)

	lea	rcx, QWORD PTR [r12+r14*2]
	cmp	r8, rcx
	jae	SHORT $LN7@PrintDecim

; 260  :         {
; 261  :             int count = width - (int)(state.OUT_PTR - out_buf);

	mov	rax, r8
	sub	rax, r12
	sar	rax, 1
	sub	r14d, eax

; 262  :             while (count > 0)

	test	r14d, r14d
	jle	SHORT $LN7@PrintDecim
	npad	5
$LL6@PrintDecim:

; 263  :             {
; 264  :                 OutputOneChar(&state, 0);

	xor	edx, edx
	lea	rcx, QWORD PTR state$[rbp-112]
	call	OutputOneChar

; 265  :                 --count;

	dec	r14d
	test	r14d, r14d
	jg	SHORT $LL6@PrintDecim
	mov	r8, QWORD PTR state$[rbp-64]
$LN7@PrintDecim:

; 266  :             }
; 267  :         }
; 268  :     }
; 269  :     *out_buf_count = state.OUT_PTR - out_buf;

	mov	rcx, QWORD PTR out_buf_count$GSCopy$1$[rbp-112]
	mov	rax, r8
	sub	rax, r12
	sar	rax, 1
	mov	QWORD PTR [rcx], rax

; 270  :     *state.OUT_PTR = '\0';

	xor	eax, eax
	mov	WORD PTR [r8], ax

; 271  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-112]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
PrintDecimal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT ToStringDN_1WORD
_TEXT	SEGMENT
state$ = 48
x$ = 56
ToStringDN_1WORD PROC					; COMDAT

; 197  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	r9d, edx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 601  :         *r = (_UINT32_T)(t % v);

	mov	r14, -3689348814741910323		; cccccccccccccccdH
	mov	rax, r14
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 197  : {

	mov	rbp, rcx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 601  :         *r = (_UINT32_T)(t % v);

	mul	r9
	mov	rbx, rdx
	shr	rbx, 3
	lea	eax, DWORD PTR [rbx+rbx*4]
	add	eax, eax
	sub	r9d, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 214  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	edx, r9d
	call	OutputOneChar
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	ecx, ebx

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rax, r14
	mul	rcx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 215  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	rcx, rbp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rdi, rdx
	shr	rdi, 3
	lea	eax, DWORD PTR [rdi+rdi*4]
	add	eax, eax
	sub	ebx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 215  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	edx, ebx
	call	OutputOneChar
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	ecx, edi

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rax, r14
	mul	rcx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 216  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	rcx, rbp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rbx, rdx
	shr	rbx, 3
	lea	eax, DWORD PTR [rbx+rbx*4]
	add	eax, eax
	sub	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 216  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	edx, edi
	call	OutputOneChar
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	ecx, ebx

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rax, r14
	mul	rcx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 217  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	rcx, rbp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rdi, rdx
	shr	rdi, 3
	lea	eax, DWORD PTR [rdi+rdi*4]
	add	eax, eax
	sub	ebx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 217  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	edx, ebx
	call	OutputOneChar
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	ecx, edi

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rax, r14
	mul	rcx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 218  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	rcx, rbp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rbx, rdx
	shr	rbx, 3
	lea	eax, DWORD PTR [rbx+rbx*4]
	add	eax, eax
	sub	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 218  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	edx, edi
	call	OutputOneChar
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	ecx, ebx

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rax, r14
	mul	rcx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 222  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	rcx, rbp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rdi, rdx
	shr	rdi, 3
	lea	eax, DWORD PTR [rdi+rdi*4]
	add	eax, eax
	sub	ebx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 222  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	edx, ebx
	call	OutputOneChar
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	ecx, edi

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rax, r14
	mul	rcx
	mov	rsi, rdx
	shr	rsi, 3
	lea	ecx, DWORD PTR [rsi+rsi*4]
	add	ecx, ecx
	sub	edi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 223  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	rcx, rbp
	mov	edx, edi
	call	OutputOneChar
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	ecx, esi

; 601  :         *r = (_UINT32_T)(t % v);

	mov	rax, r14
	mul	rcx
	mov	rbx, rdx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 227  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	rcx, rbp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 601  :         *r = (_UINT32_T)(t % v);

	shr	rbx, 3
	lea	eax, DWORD PTR [rbx+rbx*4]
	add	eax, eax
	sub	esi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 227  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	mov	edx, esi
	call	OutputOneChar

; 228  :         OutputOneChar(state, x);

	mov	edx, ebx
	mov	rcx, rbp

; 229  :     }
; 230  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 228  :         OutputOneChar(state, x);

	jmp	OutputOneChar
ToStringDN_1WORD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT ToStringDN_LEADING_1WORD
_TEXT	SEGMENT
state$ = 48
x$ = 56
ToStringDN_LEADING_1WORD PROC				; COMDAT

; 186  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r8d, edx
	mov	rdi, rcx
	mov	rsi, -3689348814741910323		; cccccccccccccccdH
	npad	1
$LL4@ToStringDN:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	edx, r8d

; 602  :         return ((_UINT32_T)(t / v));

	mov	rax, rsi
	mul	rdx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 191  :         OutputOneChar(state, r);

	mov	rcx, rdi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 602  :         return ((_UINT32_T)(t / v));

	mov	rbx, rdx
	shr	rbx, 3
	lea	eax, DWORD PTR [rbx+rbx*4]
	add	eax, eax
	sub	r8d, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 191  :         OutputOneChar(state, r);

	mov	edx, r8d
	call	OutputOneChar
	mov	r8d, ebx

; 192  :     } while (x != 0);

	test	ebx, ebx
	jne	SHORT $LL4@ToStringDN

; 193  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ToStringDN_LEADING_1WORD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT OutputOneChar
_TEXT	SEGMENT
state$ = 48
x$ = 56
OutputOneChar PROC					; COMDAT

; 145  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 146  :     if (state->FORMAT == 'N')

	cmp	BYTE PTR [rcx], 78			; 0000004eH
	mov	rbx, rcx
	mov	edi, edx
	jne	$LN2@OutputOneC

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR [rcx+40]
	test	eax, eax
	jle	SHORT $LN9@OutputOneC
	cmp	DWORD PTR [rcx+44], eax
	jl	SHORT $LN9@OutputOneC

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	rdx, QWORD PTR [rcx+2]
	mov	rcx, QWORD PTR [rcx+48]
	call	QWORD PTR __imp_lstrcpyW

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR [rbx+24]

; 156  :             *state->OUT_PTR = decimal_digits[x];

	lea	rdx, OFFSET FLAT:decimal_digits
	add	rax, rax
	add	QWORD PTR [rbx+48], rax
	mov	rcx, QWORD PTR [rbx+48]
	movzx	eax, WORD PTR [rdx+rdi*2]
	mov	WORD PTR [rcx], ax

; 157  :             state->OUT_PTR += 1;

	add	QWORD PTR [rbx+48], 2

; 158  :             state->CURRENT_GROUP_INDEX = 1;
; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	rax, QWORD PTR [rbx+32]
	inc	rax
	mov	DWORD PTR [rbx+44], 1
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN3@OutputOneC

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	QWORD PTR [rbx+32], rax

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR [rbx+40], eax

; 181  :     }
; 182  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@OutputOneC:

; 165  :             }
; 166  :         }
; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	mov	rcx, QWORD PTR [rcx+48]
	lea	rdx, OFFSET FLAT:decimal_digits
	movzx	eax, WORD PTR [rdx+rdi*2]
	mov	WORD PTR [rcx], ax

; 171  :             state->OUT_PTR += 1;

	add	QWORD PTR [rbx+48], 2

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	inc	DWORD PTR [rbx+44]

; 181  :     }
; 182  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@OutputOneC:

; 173  :         }
; 174  :     }
; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	mov	rcx, QWORD PTR [rcx+48]
	lea	rdx, OFFSET FLAT:decimal_digits
	movzx	eax, WORD PTR [rdx+rdi*2]
	mov	WORD PTR [rcx], ax

; 180  :         state->OUT_PTR += 1;

	add	QWORD PTR [rbx+48], 2
$LN3@OutputOneC:

; 181  :     }
; 182  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
OutputOneChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT OutputUngroupedOneChar
_TEXT	SEGMENT
state$ = 8
x$ = 16
OutputUngroupedOneChar PROC				; COMDAT

; 140  :     *state->OUT_PTR = decimal_digits[x];

	mov	eax, edx
	lea	r8, OFFSET FLAT:decimal_digits
	mov	rdx, QWORD PTR [rcx+48]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx], ax

; 141  :     state->OUT_PTR += 1;

	add	QWORD PTR [rcx+48], 2

; 142  : }

	ret	0
OutputUngroupedOneChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT OutputDecimalSeparator
_TEXT	SEGMENT
state$ = 48
OutputDecimalSeparator PROC				; COMDAT

; 133  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 134  :     lstrcpyW(state->OUT_PTR, state->DECIMAL_SEPARATOR);

	lea	rdx, QWORD PTR [rcx+12]
	mov	rcx, QWORD PTR [rcx+48]
	call	QWORD PTR __imp_lstrcpyW

; 135  :     state->OUT_PTR += state->DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR [rbx+28]
	add	rax, rax
	add	QWORD PTR [rbx+48], rax

; 136  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
OutputDecimalSeparator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT InitializeOutputState
_TEXT	SEGMENT
state$ = 48
out_buf$ = 56
format$ = 64
format_option$ = 72
InitializeOutputState PROC				; COMDAT

; 101  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 102  :     state->FORMAT = format;
; 103  : 
; 104  :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(format_option->GroupSeparator);

	lea	rbx, QWORD PTR [r9+4]
	mov	BYTE PTR [rcx], r8b
	mov	rdi, rcx
	mov	rsi, r9
	mov	rcx, rbx
	mov	rbp, rdx
	call	QWORD PTR __imp_lstrlenW
	mov	DWORD PTR [rdi+24], eax

; 105  :     wchar_t* in_ptr = format_option->GroupSeparator;
; 106  :     wchar_t* out_ptr = state->GROUP_SEPARATOR + state->GROUP_SEPARATOR_LENGTH;
; 107  :     *out_ptr-- = '\0';

	xor	r14d, r14d
	cdqe
	lea	r8, QWORD PTR [rdi+rax*2]
	mov	WORD PTR [r8+2], r14w

; 108  :     while (*in_ptr != L'\0')

	movzx	eax, WORD PTR [rbx]
	test	ax, ax
	je	SHORT $LN3@Initialize
	npad	4
$LL2@Initialize:

; 109  :     {
; 110  :         *out_ptr = *in_ptr;

	mov	WORD PTR [r8], ax

; 111  :         --out_ptr;
; 112  :         ++in_ptr;

	lea	rbx, QWORD PTR [rbx+2]
	movzx	eax, WORD PTR [rbx]
	lea	r8, QWORD PTR [r8-2]
	test	ax, ax
	jne	SHORT $LL2@Initialize
$LN3@Initialize:

; 113  :     }
; 114  : 
; 115  :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(format_option->DecimalSeparator);

	lea	rbx, QWORD PTR [rsi+10]
	mov	rcx, rbx
	call	QWORD PTR __imp_lstrlenW
	mov	DWORD PTR [rdi+28], eax

; 116  :     in_ptr = format_option->DecimalSeparator;
; 117  :     out_ptr = state->DECIMAL_SEPARATOR + state->DECIMAL_SEPARATOR_LENGTH;

	cdqe
	lea	rax, QWORD PTR [rdi+rax*2]

; 118  :     *out_ptr-- = '\0';

	mov	WORD PTR [rax+12], r14w
	sub	rax, -10

; 119  :     while (*in_ptr != L'\0')

	movzx	ecx, WORD PTR [rbx]
	test	cx, cx
	je	SHORT $LN5@Initialize
	npad	5
$LL4@Initialize:

; 120  :     {
; 121  :         *out_ptr = *in_ptr;

	mov	WORD PTR [rax], cx

; 122  :         --out_ptr;
; 123  :         ++in_ptr;

	lea	rbx, QWORD PTR [rbx+2]
	movzx	ecx, WORD PTR [rbx]
	lea	rax, QWORD PTR [rax-2]
	test	cx, cx
	jne	SHORT $LL4@Initialize
$LN5@Initialize:

; 124  :     }
; 125  : 
; 126  :     state->CURRENT_GROUP = &format_option->GroupSizes[0];
; 127  :     state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';
; 128  :     state->CURRENT_GROUP_INDEX = 0;
; 129  :     state->OUT_PTR = out_buf;
; 130  : }

	mov	rbx, QWORD PTR [rsp+48]
	lea	rax, QWORD PTR [rsi+28]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rdi+32], rax
	movsx	ecx, BYTE PTR [rax]
	mov	QWORD PTR [rdi+48], rbp
	sub	ecx, 48					; 00000030H
	mov	rbp, QWORD PTR [rsp+56]
	mov	DWORD PTR [rdi+40], ecx
	mov	DWORD PTR [rdi+44], r14d
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
InitializeOutputState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT ConvertCardinalNumber
_TEXT	SEGMENT
work_buf_1_words$ = 48
work_buf_2_code$ = 56
work_buf_1_code$ = 64
work_buf_2_words$ = 72
x_buf$ = 128
x_buf_size$ = 136
r_value$1 = 144
x_bit_count$ = 144
base_value$ = 152
r_buf$ = 160
r_buf_count$ = 168
ConvertCardinalNumber PROC				; COMDAT

; 58   : {

	push	rbx
	push	rsi
	push	rdi
	push	r13
	push	r15
	sub	rsp, 80					; 00000050H

; 59   :     PMC_STATUS_CODE result;
; 60   :     __UNIT_TYPE work_buf_1_code;
; 61   :     __UNIT_TYPE work_buf_1_words;
; 62   :     __UNIT_TYPE_DIV* work_buf_1 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_1_words, &work_buf_1_code);

	lea	rdi, QWORD PTR [r8+64]
	mov	rsi, rdx
	mov	rbx, rcx
	lea	r8, QWORD PTR work_buf_1_code$[rsp]
	mov	rcx, rdi
	lea	rdx, QWORD PTR work_buf_1_words$[rsp]
	mov	r13d, r9d
	call	AllocateBlock
	mov	r15, rax

; 63   :     if (work_buf_1 == NULL)

	test	rax, rax
	jne	SHORT $LN6@ConvertCar

; 64   :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	lea	eax, QWORD PTR [r15-5]

; 98   : }

	add	rsp, 80					; 00000050H
	pop	r15
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN6@ConvertCar:

; 65   :     __UNIT_TYPE work_buf_2_code;
; 66   :     __UNIT_TYPE work_buf_2_words;
; 67   :     __UNIT_TYPE_DIV* work_buf_2 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_2_words, &work_buf_2_code);

	lea	r8, QWORD PTR work_buf_2_code$[rsp]
	mov	QWORD PTR [rsp+136], r12
	lea	rdx, QWORD PTR work_buf_2_words$[rsp]
	mov	rcx, rdi
	call	AllocateBlock
	mov	r12, rax

; 68   :     if (work_buf_2 == NULL)

	test	rax, rax
	jne	SHORT $LN7@ConvertCar

; 69   :     {
; 70   :         DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	mov	rdx, QWORD PTR work_buf_1_words$[rsp]
	mov	rcx, r15
	call	DeallocateBlock

; 71   :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	lea	eax, QWORD PTR [r12-5]
	jmp	$LN26@ConvertCar
$LN7@ConvertCar:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 293  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ecx, esi
	mov	rdi, r15
	mov	rsi, rbx
	mov	QWORD PTR [rsp+128], rbp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 76   :     __UNIT_TYPE_DIV* r_ptr = r_buf;

	mov	rbx, QWORD PTR r_buf$[rsp]
	mov	rbp, r15
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 293  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 77   :     __UNIT_TYPE work_u_count = work_buf_1_words * (sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV));

	mov	rsi, QWORD PTR work_buf_1_words$[rsp]
	mov	QWORD PTR [rsp+152], r14
	mov	r14, r12
	add	rsi, rsi

; 78   :     while (work_u_count > 0)

	je	$LN3@ConvertCar
$LL2@ConvertCar:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 343  :     __stosd((unsigned long*)d, 0, (unsigned long)count);

	xor	eax, eax
	mov	ecx, esi
	mov	rdi, r14
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 82   :         DivRem_X_1W(u_ptr, work_u_count, base_value, q_ptr, &r_value);

	mov	r9, r14
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 343  :     __stosd((unsigned long*)d, 0, (unsigned long)count);

	rep stosd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c

; 82   :         DivRem_X_1W(u_ptr, work_u_count, base_value, q_ptr, &r_value);

	lea	rax, QWORD PTR r_value$1[rsp]
	mov	rcx, rbp
	mov	r8d, r13d
	mov	QWORD PTR [rsp+32], rax
	mov	rdx, rsi
	call	DivRem_X_1W

; 83   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_2, work_buf_2_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_buf_2_code$[rsp]
	mov	rcx, r12
	call	CheckBlockLight
	test	eax, eax
	jne	$LN28@ConvertCar

; 84   :             return (result);
; 85   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_1, work_buf_1_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_buf_1_code$[rsp]
	mov	rcx, r15
	call	CheckBlockLight
	test	eax, eax
	jne	SHORT $LN28@ConvertCar

; 86   :             return (result);
; 87   :         *r_ptr++ = r_value;

	mov	eax, DWORD PTR r_value$1[rsp]
	mov	DWORD PTR [rbx], eax

; 88   :         __UNIT_TYPE_DIV* temp = u_ptr;

	mov	rax, rbp
	add	rbx, 4

; 89   :         u_ptr = q_ptr;

	mov	rbp, r14

; 90   :         q_ptr = temp;

	mov	r14, rax

; 91   :         while (work_u_count > 0 && u_ptr[work_u_count - 1] == 0)

	test	rsi, rsi
	je	SHORT $LN3@ConvertCar

; 86   :             return (result);
; 87   :         *r_ptr++ = r_value;

	lea	rax, QWORD PTR [rsi*4-4]
	add	rax, rbp
$LL4@ConvertCar:

; 91   :         while (work_u_count > 0 && u_ptr[work_u_count - 1] == 0)

	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN5@ConvertCar

; 92   :             --work_u_count;

	sub	rax, 4
	sub	rsi, 1
	jne	SHORT $LL4@ConvertCar

; 91   :         while (work_u_count > 0 && u_ptr[work_u_count - 1] == 0)

	jmp	SHORT $LN3@ConvertCar
$LN5@ConvertCar:

; 78   :     while (work_u_count > 0)

	test	rsi, rsi
	jne	$LL2@ConvertCar
$LN3@ConvertCar:

; 93   :     }
; 94   :     *r_buf_count = r_ptr - r_buf;

	mov	rax, QWORD PTR r_buf_count$[rsp]

; 95   :     DeallocateBlock((__UNIT_TYPE*)work_buf_2, work_buf_2_words);

	mov	rcx, r12
	sub	rbx, QWORD PTR r_buf$[rsp]
	mov	rdx, QWORD PTR work_buf_2_words$[rsp]
	sar	rbx, 2
	mov	QWORD PTR [rax], rbx
	call	DeallocateBlock

; 96   :     DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	mov	rdx, QWORD PTR work_buf_1_words$[rsp]
	mov	rcx, r15
	call	DeallocateBlock

; 97   :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN28@ConvertCar:
	mov	rbp, QWORD PTR [rsp+128]
	mov	r14, QWORD PTR [rsp+152]
$LN26@ConvertCar:
	mov	r12, QWORD PTR [rsp+136]

; 98   : }

	add	rsp, 80					; 00000050H
	pop	r15
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
ConvertCardinalNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _ROTATE_L_UNIT
_TEXT	SEGMENT
x$ = 8
count$ = 16
_ROTATE_L_UNIT PROC					; COMDAT

; 692  : {

	mov	rax, rcx

; 693  : #ifdef _M_IX86
; 694  :     return (_rotl(x, count));
; 695  : #elif defined(_M_X64)
; 696  :     return (_rotl64(x, count));

	mov	ecx, edx
	rol	rax, cl

; 697  : #else
; 698  : #error unknown platform
; 699  : #endif
; 700  : }

	ret	0
_ROTATE_L_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _DIVREM_UNIT
_TEXT	SEGMENT
u_high$ = 8
u_low$ = 16
v$ = 24
r$ = 32
_DIVREM_UNIT PROC					; COMDAT

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	eax, ecx
	mov	ecx, edx

; 596  : #ifdef _MSC_VER
; 597  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 598  :     {
; 599  :         // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 600  :         _UINT64_T t = _FROMWORDTODWORD(u_high, u_low);
; 601  :         *r = (_UINT32_T)(t % v);

	xor	edx, edx

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	shl	rax, 32					; 00000020H
	or	rax, rcx

; 596  : #ifdef _MSC_VER
; 597  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 598  :     {
; 599  :         // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 600  :         _UINT64_T t = _FROMWORDTODWORD(u_high, u_low);
; 601  :         *r = (_UINT32_T)(t % v);

	mov	ecx, r8d
	div	rcx
	mov	DWORD PTR [r9], edx

; 602  :         return ((_UINT32_T)(t / v));
; 603  :     }
; 604  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 605  :     {
; 606  :         // 以下の理由のため、MSVCでは 128bit/64bit の除算を実装できない。運用で回避すること。
; 607  :         // ・(x64 に限らず) 除算の組み込み関数が用意されていない。
; 608  :         // ・128bit 整数のデータ型が用意されていない。
; 609  :         // ・x64 ではインラインアセンブラがサポートされていない。
; 610  :         *r = 0;
; 611  :         return (0);
; 612  :     }
; 613  :     else
; 614  :     {
; 615  :         // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 616  :         *r = 0;
; 617  :         return (0);
; 618  :     }
; 619  : #elif defined(__GNUC__)
; 620  :     __UNIT_TYPE q;
; 621  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 622  :         __asm__("divl %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 623  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 624  :         __asm__("divq %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 625  :     else
; 626  :     {
; 627  :         // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 628  :         *r = 0;
; 629  :         q = 0;
; 630  :     }
; 631  :     return (q);
; 632  : #else
; 633  : #error unknown compiler
; 634  : #endif
; 635  : }

	ret	0
_DIVREM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _DIVIDE_CEILING_UNIT
_TEXT	SEGMENT
u$ = 8
v$ = 16
_DIVIDE_CEILING_UNIT PROC				; COMDAT

; 405  :     return ((u + v - 1) / v);

	lea	rax, QWORD PTR [rdx-1]
	mov	r8, rdx
	add	rax, rcx
	xor	edx, edx
	div	r8

; 406  : }

	ret	0
_DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _FROMWORDTODWORD
_TEXT	SEGMENT
value_high$ = 8
value_low$ = 16
_FROMWORDTODWORD PROC					; COMDAT

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	mov	eax, ecx
	shl	rax, 32					; 00000020H
	mov	ecx, edx
	or	rax, rcx

; 390  : }

	ret	0
_FROMWORDTODWORD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _FILL_MEMORY_16
_TEXT	SEGMENT
d$ = 8
x$ = 16
count$ = 24
_FILL_MEMORY_16 PROC					; COMDAT

; 360  : {

	mov	QWORD PTR [rsp+8], rdi

; 361  :     __stosw(d, x, count);

	mov	rdi, rcx
	movzx	eax, dx
	mov	rcx, r8
	rep stosw

; 362  : }

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
_FILL_MEMORY_16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _ZERO_MEMORY_UNIT_DIV
_TEXT	SEGMENT
d$ = 8
count$ = 16
_ZERO_MEMORY_UNIT_DIV PROC				; COMDAT

; 338  : {

	mov	QWORD PTR [rsp+8], rdi
	mov	rdi, rcx

; 339  : #ifdef _M_IX86
; 340  :     __stosd((unsigned long*)d, 0, (unsigned long)count);
; 341  : #elif defined(_M_X64)
; 342  : #ifdef _MSC_VER
; 343  :     __stosd((unsigned long*)d, 0, (unsigned long)count);

	xor	eax, eax
	mov	ecx, edx
	rep stosd

; 344  : #elif defined(__GNUC__)
; 345  :     __stosq(d, 0, count);
; 346  : #else
; 347  : #error unknown compiler
; 348  : #endif
; 349  : #else
; 350  : #error unknown platform
; 351  : #endif
; 352  : }

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
_ZERO_MEMORY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _COPY_MEMORY_UNIT_DIV
_TEXT	SEGMENT
d$ = 8
s$ = 16
count$ = 24
_COPY_MEMORY_UNIT_DIV PROC				; COMDAT

; 288  : {

	mov	QWORD PTR [rsp+8], rsi
	mov	QWORD PTR [rsp+16], rdi
	mov	rdi, rcx

; 289  : #ifdef _M_IX86
; 290  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 291  : #elif defined(_M_X64)
; 292  : #ifdef _MSC_VER
; 293  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	rsi, rdx
	mov	ecx, r8d
	rep movsd

; 294  : #elif defined(__GNUC__)
; 295  :     __movsq(d, s, count);
; 296  : #else
; 297  : #error unknown compiler
; 298  : #endif
; 299  : #else
; 300  : #error unknown platform
; 301  : #endif
; 302  : }

	mov	rsi, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
_COPY_MEMORY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT PMC_ToString
_TEXT	SEGMENT
x$ = 64
buffer$ = 72
buffer_size$ = 80
format$ = 88
width$ = 96
format_option$ = 104
PMC_ToString PROC					; COMDAT

; 502  : {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H
	movzx	r14d, r9b
	mov	rbp, r8
	mov	rsi, rdx
	mov	rdi, rcx

; 503  :     if (x == NULL)

	test	rcx, rcx
	je	$LN12@PMC_ToStri

; 504  :         return (PMC_STATUS_ARGUMENT_ERROR);
; 505  :     if (buffer == NULL)

	test	rdx, rdx
	je	$LN12@PMC_ToStri

; 506  :         return (PMC_STATUS_ARGUMENT_ERROR);
; 507  :     if (format_option == NULL)
; 508  :         format_option = &default_number_format_option;
; 509  :     NUMBER_HEADER* nx = (NUMBER_HEADER*)x;

	mov	rax, QWORD PTR format_option$[rsp]
	lea	rbx, OFFSET FLAT:default_number_format_option
	test	rax, rax
	cmovne	rbx, rax

; 510  :     PMC_STATUS_CODE result;
; 511  :     if ((result = CheckNumber(nx)) != PMC_STATUS_OK)

	call	CheckNumber
	test	eax, eax
	jne	$LN1@PMC_ToStri

; 512  :         return (result);
; 513  :     switch (format)

	movsx	eax, r14b
	add	eax, -68				; ffffffffffffffbcH
	cmp	eax, 52					; 00000034H
	ja	$LN12@PMC_ToStri
	lea	rdx, OFFSET FLAT:__ImageBase
	cdqe
	movzx	eax, BYTE PTR $LN16@PMC_ToStri[rdx+rax]
	mov	ecx, DWORD PTR $LN17@PMC_ToStri[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN8@PMC_ToStri:

; 514  :     {
; 515  :     case 'n':
; 516  :     case 'N':
; 517  :         return (ToStringDN(nx, buffer, buffer_size, 'N', width >= 0 ? width : format_option->DecimalDigits, format_option));

	mov	eax, DWORD PTR width$[rsp]
	test	eax, eax
	jns	SHORT $LN15@PMC_ToStri
	mov	eax, DWORD PTR [rbx]
$LN15@PMC_ToStri:
	mov	QWORD PTR [rsp+40], rbx
	mov	r9b, 78					; 0000004eH
	mov	r8, rbp
	mov	DWORD PTR [rsp+32], eax
	mov	rdx, rsi
	mov	rcx, rdi
	call	ToStringDN
	jmp	SHORT $LN1@PMC_ToStri
$LN9@PMC_ToStri:

; 518  :     case 'x':
; 519  :         return (ToStringX(nx, buffer, buffer_size, width >= 0 ? width : 0, format_option, 0));

	mov	eax, DWORD PTR width$[rsp]
	xor	ecx, ecx
	mov	r9d, ecx
	mov	DWORD PTR [rsp+40], ecx
	test	eax, eax
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rbp
	mov	rdx, rsi
	cmovns	r9d, eax
	mov	rcx, rdi
	call	ToStringX
	jmp	SHORT $LN1@PMC_ToStri
$LN10@PMC_ToStri:

; 520  :     case 'X':
; 521  :         return (ToStringX(nx, buffer, buffer_size, width >= 0 ? width : 0, format_option, 1));

	mov	eax, DWORD PTR width$[rsp]
	xor	ecx, ecx
	test	eax, eax
	mov	DWORD PTR [rsp+40], 1
	mov	r8, rbp
	mov	QWORD PTR [rsp+32], rbx
	cmovns	ecx, eax
	mov	rdx, rsi
	mov	r9d, ecx
	mov	rcx, rdi
	call	ToStringX
	jmp	SHORT $LN1@PMC_ToStri
$LN11@PMC_ToStri:

; 522  :     case 'd':
; 523  :     case 'D':
; 524  :         return (ToStringDN(nx, buffer, buffer_size, 'D', width >= 0 ? width : 0, format_option));

	mov	eax, DWORD PTR width$[rsp]
	xor	ecx, ecx
	test	eax, eax
	mov	QWORD PTR [rsp+40], rbx
	mov	r9b, 68					; 00000044H
	mov	r8, rbp
	cmovns	ecx, eax
	mov	rdx, rsi
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, rdi
	call	ToStringDN
	jmp	SHORT $LN1@PMC_ToStri
$LN12@PMC_ToStri:

; 525  :     default:
; 526  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
$LN1@PMC_ToStri:

; 527  :     }
; 528  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
	npad	2
$LN17@PMC_ToStri:
	DD	$LN11@PMC_ToStri
	DD	$LN8@PMC_ToStri
	DD	$LN10@PMC_ToStri
	DD	$LN9@PMC_ToStri
	DD	$LN12@PMC_ToStri
$LN16@PMC_ToStri:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
PMC_ToString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
;	COMDAT Initialize_ToString
_TEXT	SEGMENT
feature$ = 48
Initialize_ToString PROC				; COMDAT

; 531  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 532  :     default_number_format_option.DecimalDigits = 2;
; 533  :     lstrcpyW(default_number_format_option.GroupSeparator, L",");

	lea	rdx, OFFSET FLAT:??_C@_13DEFPDAGF@?$AA?0@
	mov	DWORD PTR default_number_format_option, 2
	lea	rcx, OFFSET FLAT:default_number_format_option+4
	call	QWORD PTR __imp_lstrcpyW

; 534  :     lstrcpyW(default_number_format_option.DecimalSeparator, L".");

	lea	rdx, OFFSET FLAT:??_C@_13JOFGPIOO@?$AA?4@
	lea	rcx, OFFSET FLAT:default_number_format_option+10
	call	QWORD PTR __imp_lstrcpyW

; 535  :     lstrcpy(default_number_format_option.GroupSizes, "3");

	lea	rdx, OFFSET FLAT:??_C@_01EKENIIDA@3@
	lea	rcx, OFFSET FLAT:default_number_format_option+28
	call	QWORD PTR __imp_lstrcpyA

; 536  :     lstrcpyW(default_number_format_option.PositiveSign, L"+");

	lea	rdx, OFFSET FLAT:??_C@_13KJIIAINM@?$AA?$CL@
	lea	rcx, OFFSET FLAT:default_number_format_option+16
	call	QWORD PTR __imp_lstrcpyW

; 537  :     lstrcpyW(default_number_format_option.NegativeSign, L"-");

	lea	rdx, OFFSET FLAT:??_C@_13IMODFHAA@?$AA?9@
	lea	rcx, OFFSET FLAT:default_number_format_option+22
	call	QWORD PTR __imp_lstrcpyW

; 538  : 
; 539  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 540  : }

	add	rsp, 40					; 00000028H
	ret	0
Initialize_ToString ENDP
_TEXT	ENDS
END
