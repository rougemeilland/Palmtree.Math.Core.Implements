; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

	TITLE	Z:\Sources\Lunor\Repos\rougemeilland\Palmtree.Math.Core.Implements\Palmtree.Math.Core.Implements\CALC_divrem_critical.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__4522B509_pmc_internal@h DB 01H
__1C66ECB2_pmc_debug@h DB 01H
__7646DD32_calc_divrem_critical@c DB 01H
msvcjmc	ENDS
PUBLIC	_CalculateCriticalDataOfDivision
PUBLIC	__JustMyCode_Default
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allshl:PROC
EXTRN	__aulldiv:PROC
EXTRN	__aullrem:PROC
EXTRN	__aullshr:PROC
EXTRN	_statistics_info:BYTE
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
_DATA	SEGMENT
$SG95797 DB	'found: u0=0x%08x, u1=0x%08x, u2=0x%08x, u3=0x%08x, v1=0x'
	DB	'%08x, v2=0x%08x, v3=0x%08x', 0aH, 00H
	ORG $+4
$SG95798 DB	'found: u0=0x%016llx, u1=0x%016llx, u2=0x%016llx, u3=0x%0'
	DB	'16llx, v1=0x%016llx, v2=0x%016llx, v3=0x%016llx', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
tv89 = -52						; size = 4
_rh_lo$ = -48						; size = 4
_rh_mi$ = -40						; size = 4
_rh_hi$ = -28						; size = 4
_lh_lo$ = -20						; size = 4
_lh_mi$ = -12						; size = 4
_lh_hi$ = -4						; size = 4
_q_$ = 8						; size = 4
_u0$ = 12						; size = 4
_u1$ = 16						; size = 4
_u2$ = 20						; size = 4
_v1$ = 24						; size = 4
_v2$ = 28						; size = 4
_CheckQ_ PROC

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 76   :     const __UNIT_TYPE_DIV lh_hi = 0;

	mov	DWORD PTR _lh_hi$[ebp], 0

; 77   :     __UNIT_TYPE_DIV lh_mi;
; 78   :     __UNIT_TYPE_DIV lh_lo = _MULTIPLY_UNIT_DIV(v2, q_, &lh_mi);

	lea	eax, DWORD PTR _lh_mi$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q_$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v2$[ebp]
	push	edx
	call	__MULTIPLY_UNIT_DIV
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lh_lo$[ebp], eax

; 79   :     __UNIT_TYPE_DIV rh_hi;
; 80   :     __UNIT_TYPE_DIV rh_mi = _MULTIPLY_UNIT_DIV(q_, v1, &rh_hi);

	lea	eax, DWORD PTR _rh_hi$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _q_$[ebp]
	push	edx
	call	__MULTIPLY_UNIT_DIV
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _rh_mi$[ebp], eax

; 81   :     __UNIT_TYPE_DIV rh_lo = u2;

	mov	eax, DWORD PTR _u2$[ebp]
	mov	DWORD PTR _rh_lo$[ebp], eax

; 82   :     _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, u1, rh_mi, &rh_mi), u0, rh_hi, &rh_hi);

	lea	ecx, DWORD PTR _rh_hi$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rh_hi$[ebp]
	push	edx
	mov	eax, DWORD PTR _u0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rh_mi$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rh_mi$[ebp]
	push	edx
	mov	eax, DWORD PTR _u1$[ebp]
	push	eax
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H

; 83   : #ifdef ENABLED_PERFORMANCE_COUNTER
; 84   :     if (sizeof(lh_hi) == sizeof(_UINT32_T))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@CheckQ_

; 85   :         AddToMULTI32Counter(2);

	push	2
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN3@CheckQ_
$LN2@CheckQ_:

; 86   :     else
; 87   :         AddToMULTI64Counter(2);

	push	2
	call	_AddToMULTI64Counter
	add	esp, 4
$LN3@CheckQ_:

; 88   : #endif
; 89   :     if (lh_hi > rh_hi)

	mov	eax, DWORD PTR _lh_hi$[ebp]
	cmp	eax, DWORD PTR _rh_hi$[ebp]
	jbe	SHORT $LN4@CheckQ_

; 90   :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN1@CheckQ_
$LN4@CheckQ_:

; 91   :     else if (lh_hi < rh_hi)

	mov	ecx, DWORD PTR _lh_hi$[ebp]
	cmp	ecx, DWORD PTR _rh_hi$[ebp]
	jae	SHORT $LN6@CheckQ_

; 92   :         return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN1@CheckQ_
$LN6@CheckQ_:

; 93   :     else if (lh_mi > rh_mi)

	mov	edx, DWORD PTR _lh_mi$[ebp]
	cmp	edx, DWORD PTR _rh_mi$[ebp]
	jbe	SHORT $LN8@CheckQ_

; 94   :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN1@CheckQ_
$LN8@CheckQ_:

; 95   :     else if (lh_mi < rh_mi)

	mov	eax, DWORD PTR _lh_mi$[ebp]
	cmp	eax, DWORD PTR _rh_mi$[ebp]
	jae	SHORT $LN10@CheckQ_

; 96   :         return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN1@CheckQ_
$LN10@CheckQ_:

; 97   :     else
; 98   :         return (lh_lo > rh_lo);

	mov	ecx, DWORD PTR _lh_lo$[ebp]
	cmp	ecx, DWORD PTR _rh_lo$[ebp]
	jbe	SHORT $LN13@CheckQ_
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN14@CheckQ_
$LN13@CheckQ_:
	mov	DWORD PTR tv89[ebp], 0
$LN14@CheckQ_:
	mov	eax, DWORD PTR tv89[ebp]
$LN1@CheckQ_:

; 99   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@CheckQ_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN19@CheckQ_:
	DD	3
	DD	$LN18@CheckQ_
$LN18@CheckQ_:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN15@CheckQ_
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN16@CheckQ_
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN17@CheckQ_
$LN17@CheckQ_:
	DB	114					; 00000072H
	DB	104					; 00000068H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	0
$LN16@CheckQ_:
	DB	114					; 00000072H
	DB	104					; 00000068H
	DB	95					; 0000005fH
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
$LN15@CheckQ_:
	DB	108					; 0000006cH
	DB	104					; 00000068H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	0
_CheckQ_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_q$ = -16						; size = 4
_r$ = -8						; size = 4
_u0$ = 8						; size = 4
_u1$ = 12						; size = 4
_v1$ = 16						; size = 4
_AsumeQ_ PROC

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 61   :     if (u0 == v1)

	mov	eax, DWORD PTR _u0$[ebp]
	cmp	eax, DWORD PTR _v1$[ebp]
	jne	SHORT $LN2@AsumeQ_

; 62   :         return ((__UNIT_TYPE_DIV)-1);

	or	eax, -1
	jmp	SHORT $LN1@AsumeQ_
$LN2@AsumeQ_:

; 63   :     __UNIT_TYPE_DIV r;
; 64   :     __UNIT_TYPE_DIV q = _DIVREM_UNIT(u0, u1, v1, &r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v1$[ebp]
	push	edx
	mov	eax, DWORD PTR _u1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u0$[ebp]
	push	ecx
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _q$[ebp], eax

; 65   : #ifdef ENABLED_PERFORMANCE_COUNTER
; 66   :     if (sizeof(r) == sizeof(_UINT64_T))

	xor	edx, edx
	je	SHORT $LN3@AsumeQ_

; 67   :         IncrementDIV64Counter();

	call	_IncrementDIV64Counter
	jmp	SHORT $LN4@AsumeQ_
$LN3@AsumeQ_:

; 68   :     else
; 69   :         IncrementDIV32Counter();

	call	_IncrementDIV32Counter
$LN4@AsumeQ_:

; 70   : #endif
; 71   :     return (q);

	mov	eax, DWORD PTR _q$[ebp]
$LN1@AsumeQ_:

; 72   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@AsumeQ_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN8@AsumeQ_:
	DD	1
	DD	$LN7@AsumeQ_
$LN7@AsumeQ_:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN6@AsumeQ_
$LN6@AsumeQ_:
	DB	114					; 00000072H
	DB	0
_AsumeQ_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_x2$ = 12						; size = 4
_x3$ = 16						; size = 4
_x4$ = 20						; size = 4
_y$ = 24						; size = 4
_SUBTRUCT_4W_UNIT PROC

; 55   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 56   :     return (_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, *x4, y, x4), *x3, 0, x3), *x2, 0, x2), *x1, 0, x1));

	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x3$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x3$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x4$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x4$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	eax, al
	push	eax
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H

; 57   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_SUBTRUCT_4W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_x2$ = 12						; size = 4
_x3$ = 16						; size = 4
_y$ = 20						; size = 4
_SUBTRUCT_3W_UNIT PROC

; 50   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 51   :     return (_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, *x3, y, x3), *x2, 0, x2), *x1, 0, x1));

	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x3$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H

; 52   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_SUBTRUCT_3W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_x2$ = 12						; size = 4
_x3$ = 16						; size = 4
_x4$ = 20						; size = 4
_y$ = 24						; size = 4
_ADD_4W_UNIT PROC

; 45   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 46   :     return (_ADD_UNIT_DIV(_ADD_UNIT_DIV(_ADD_UNIT_DIV(_ADD_UNIT_DIV(0, *x4, y, x4), *x3, 0, x3), *x2, 0, x2), *x1, 0, x1));

	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x3$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x3$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x4$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x4$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	eax, al
	push	eax
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H

; 47   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_ADD_4W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_x2$ = 12						; size = 4
_x3$ = 16						; size = 4
_y$ = 20						; size = 4
_ADD_3W_UNIT PROC

; 40   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 41   :     return (_ADD_UNIT_DIV(_ADD_UNIT_DIV(_ADD_UNIT_DIV(0, *x3, y, x3), *x2, 0, x2), *x1, 0, x1));

	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x3$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H

; 42   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_ADD_3W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_mv3_lo$1 = -296					; size = 4
_mv3_hi$2 = -288					; size = 4
_mv2_lo$3 = -280					; size = 4
_mv2_hi$4 = -272					; size = 4
_mv1_lo$5 = -264					; size = 4
_mv1_hi$6 = -256					; size = 4
_bu3$7 = -244						; size = 4
_bu2$8 = -232						; size = 4
_bu1$9 = -220						; size = 4
_bu0$10 = -208						; size = 4
_q_$11 = -200						; size = 4
_v3$12 = -192						; size = 4
_v2$13 = -180						; size = 4
_v1$14 = -168						; size = 4
_v_count_3$15 = -156					; size = 4
_v_count_2$16 = -144					; size = 4
_v_count_1$17 = -132					; size = 4
_u3$ = -120						; size = 4
_u2$ = -108						; size = 4
_u1$ = -96						; size = 4
_u0$ = -84						; size = 4
_u_count_3$ = -72					; size = 4
_u_count_2$ = -60					; size = 4
_u_count_1$ = -48					; size = 4
_u_count_0$ = -36					; size = 4
_u_min_3$ = -28						; size = 4
_u_min_2$ = -24						; size = 4
_u_min_1$ = -20						; size = 4
_u_min_0$ = -16						; size = 4
_v_min_3$ = -12						; size = 4
_v_min_2$ = -8						; size = 4
_v_min_1$ = -4						; size = 4
_env$ = 8						; size = 4
_CalculateCriticalDataOfDivision PROC

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-296]
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 103  :     const __UNIT_TYPE_DIV v_min_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);    // 0x80000000

	mov	DWORD PTR _v_min_1$[ebp], -2147483648	; 80000000H

; 104  :     const __UNIT_TYPE_DIV v_min_2 = 0;                              // 0x00000000

	mov	DWORD PTR _v_min_2$[ebp], 0

; 105  :     const __UNIT_TYPE_DIV v_min_3 = 0;

	mov	DWORD PTR _v_min_3$[ebp], 0

; 106  : 
; 107  :     const __UNIT_TYPE_DIV u_min_0 = 0;                              // 0x00000000

	mov	DWORD PTR _u_min_0$[ebp], 0

; 108  :     const __UNIT_TYPE_DIV u_min_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);    // 0x80000000

	mov	DWORD PTR _u_min_1$[ebp], -2147483648	; 80000000H

; 109  :     const __UNIT_TYPE_DIV u_min_2 = 0;                              // 0x00000000

	mov	DWORD PTR _u_min_2$[ebp], 0

; 110  :     const __UNIT_TYPE_DIV u_min_3 = 0;                              // 0x00000000

	mov	DWORD PTR _u_min_3$[ebp], 0

; 111  : 
; 112  :     __UNIT_TYPE_DIV u_count_0 = (__UNIT_TYPE_DIV)-1;                // 0xffffffff

	mov	DWORD PTR _u_count_0$[ebp], -1

; 113  :     __UNIT_TYPE_DIV u_count_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);        // 0x80000000

	mov	DWORD PTR _u_count_1$[ebp], -2147483648	; 80000000H

; 114  :     __UNIT_TYPE_DIV u_count_2 = 0;                                  // 0x00000000

	mov	DWORD PTR _u_count_2$[ebp], 0

; 115  :     __UNIT_TYPE_DIV u_count_3 = 0;                                  // 0x00000000

	mov	DWORD PTR _u_count_3$[ebp], 0

; 116  : 
; 117  :     __UNIT_TYPE_DIV u0 = u_min_0;

	mov	eax, DWORD PTR _u_min_0$[ebp]
	mov	DWORD PTR _u0$[ebp], eax

; 118  :     __UNIT_TYPE_DIV u1 = u_min_1;

	mov	ecx, DWORD PTR _u_min_1$[ebp]
	mov	DWORD PTR _u1$[ebp], ecx

; 119  :     __UNIT_TYPE_DIV u2 = u_min_2;

	mov	edx, DWORD PTR _u_min_2$[ebp]
	mov	DWORD PTR _u2$[ebp], edx

; 120  :     __UNIT_TYPE_DIV u3 = u_min_3;

	mov	eax, DWORD PTR _u_min_3$[ebp]
	mov	DWORD PTR _u3$[ebp], eax
$LN4@CalculateC:

; 121  : 
; 122  :     for (;;)
; 123  :     {
; 124  :         __UNIT_TYPE_DIV v_count_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);    // 0x80000000

	mov	DWORD PTR _v_count_1$17[ebp], -2147483648 ; 80000000H

; 125  :         __UNIT_TYPE_DIV v_count_2 = 0;                              // 0x00000000

	mov	DWORD PTR _v_count_2$16[ebp], 0

; 126  :         __UNIT_TYPE_DIV v_count_3 = 0;                              // 0x00000000

	mov	DWORD PTR _v_count_3$15[ebp], 0

; 127  :         __UNIT_TYPE_DIV v1 = v_min_1;

	mov	ecx, DWORD PTR _v_min_1$[ebp]
	mov	DWORD PTR _v1$14[ebp], ecx

; 128  :         __UNIT_TYPE_DIV v2 = v_min_2;

	mov	edx, DWORD PTR _v_min_2$[ebp]
	mov	DWORD PTR _v2$13[ebp], edx

; 129  :         __UNIT_TYPE_DIV v3 = v_min_3;

	mov	eax, DWORD PTR _v_min_3$[ebp]
	mov	DWORD PTR _v3$12[ebp], eax
$LN7@CalculateC:

; 130  :         for (;;)
; 131  :         {
; 132  :             __UNIT_TYPE_DIV q_ = AsumeQ_(u0, u1, v1);

	mov	ecx, DWORD PTR _v1$14[ebp]
	push	ecx
	mov	edx, DWORD PTR _u1$[ebp]
	push	edx
	mov	eax, DWORD PTR _u0$[ebp]
	push	eax
	call	_AsumeQ_
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _q_$11[ebp], eax

; 133  :             if (CheckQ_(q_, u0, u1, u2, v1, v2))

	mov	ecx, DWORD PTR _v2$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _v1$14[ebp]
	push	edx
	mov	eax, DWORD PTR _u2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u0$[ebp]
	push	edx
	mov	eax, DWORD PTR _q_$11[ebp]
	push	eax
	call	_CheckQ_
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN8@CalculateC

; 134  :             {
; 135  :                 --q_;

	mov	ecx, DWORD PTR _q_$11[ebp]
	sub	ecx, 1
	mov	DWORD PTR _q_$11[ebp], ecx

; 136  :                 if (CheckQ_(q_, u0, u1, u2, v1, v2))

	mov	edx, DWORD PTR _v2$13[ebp]
	push	edx
	mov	eax, DWORD PTR _v1$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _u2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u1$[ebp]
	push	edx
	mov	eax, DWORD PTR _u0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q_$11[ebp]
	push	ecx
	call	_CheckQ_
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN8@CalculateC

; 137  :                 {
; 138  :                     --q_;

	mov	edx, DWORD PTR _q_$11[ebp]
	sub	edx, 1
	mov	DWORD PTR _q_$11[ebp], edx
$LN8@CalculateC:

; 139  :                 }
; 140  :             }
; 141  :             __UNIT_TYPE_DIV bu0 = u0;

	mov	eax, DWORD PTR _u0$[ebp]
	mov	DWORD PTR _bu0$10[ebp], eax

; 142  :             __UNIT_TYPE_DIV bu1 = u1;

	mov	ecx, DWORD PTR _u1$[ebp]
	mov	DWORD PTR _bu1$9[ebp], ecx

; 143  :             __UNIT_TYPE_DIV bu2 = u2;

	mov	edx, DWORD PTR _u2$[ebp]
	mov	DWORD PTR _bu2$8[ebp], edx

; 144  :             __UNIT_TYPE_DIV bu3 = u3;

	mov	eax, DWORD PTR _u3$[ebp]
	mov	DWORD PTR _bu3$7[ebp], eax

; 145  :             __UNIT_TYPE_DIV mv1_hi;
; 146  :             __UNIT_TYPE_DIV mv1_lo = _MULTIPLY_UNIT_DIV(v1, q_, &mv1_hi);

	lea	ecx, DWORD PTR _mv1_hi$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _q_$11[ebp]
	push	edx
	mov	eax, DWORD PTR _v1$14[ebp]
	push	eax
	call	__MULTIPLY_UNIT_DIV
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _mv1_lo$5[ebp], eax

; 147  :             __UNIT_TYPE_DIV mv2_hi;
; 148  :             __UNIT_TYPE_DIV mv2_lo = _MULTIPLY_UNIT_DIV(v2, q_, &mv2_hi);

	lea	ecx, DWORD PTR _mv2_hi$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _q_$11[ebp]
	push	edx
	mov	eax, DWORD PTR _v2$13[ebp]
	push	eax
	call	__MULTIPLY_UNIT_DIV
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _mv2_lo$3[ebp], eax

; 149  :             __UNIT_TYPE_DIV mv3_hi;
; 150  :             __UNIT_TYPE_DIV mv3_lo = _MULTIPLY_UNIT_DIV(v3, q_, &mv3_hi);

	lea	ecx, DWORD PTR _mv3_hi$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _q_$11[ebp]
	push	edx
	mov	eax, DWORD PTR _v3$12[ebp]
	push	eax
	call	__MULTIPLY_UNIT_DIV
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _mv3_lo$1[ebp], eax

; 151  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 152  :             if (sizeof(mv1_hi) == sizeof(_UINT32_T))

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN10@CalculateC

; 153  :                 AddToMULTI32Counter(3);

	push	3
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN11@CalculateC
$LN10@CalculateC:

; 154  :             else
; 155  :                 AddToMULTI64Counter(3);

	push	3
	call	_AddToMULTI64Counter
	add	esp, 4
$LN11@CalculateC:

; 156  : #endif
; 157  : 
; 158  :             // [bu0, bu1, bu2, bu3] -= mv3_lo;
; 159  :             // [bu0, bu1, bu2] -= mv3_hi;
; 160  :             // [bu0, bu1, bu2] -= mv2_lo;
; 161  :             // [bu0, bu1] -= mv2_hi;
; 162  :             // [bu0, bu1] -= mv1_lo;
; 163  :             // [bu0] -= mv1_hi;
; 164  : 
; 165  :                 
; 166  :             if (_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, bu3, mv3_lo, &bu3), bu2, mv3_hi, &bu2), bu1, 0, &bu1), bu0, 0, &bu0) ||
; 167  :                 _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, bu2, mv2_lo, &bu2), bu1, mv2_hi, &bu1), bu0, 0, &bu0) ||

	lea	edx, DWORD PTR _bu0$10[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _bu0$10[ebp]
	push	eax
	lea	ecx, DWORD PTR _bu1$9[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _bu1$9[ebp]
	push	edx
	lea	eax, DWORD PTR _bu2$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _mv3_hi$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _bu2$8[ebp]
	push	edx
	lea	eax, DWORD PTR _bu3$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _mv3_lo$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _bu3$7[ebp]
	push	edx
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	eax, al
	push	eax
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movsx	eax, al
	test	eax, eax
	jne	$LN13@CalculateC
	lea	ecx, DWORD PTR _bu0$10[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _bu0$10[ebp]
	push	edx
	lea	eax, DWORD PTR _bu1$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _mv2_hi$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _bu1$9[ebp]
	push	edx
	lea	eax, DWORD PTR _bu2$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _mv2_lo$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _bu2$8[ebp]
	push	edx
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	eax, al
	push	eax
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movsx	edx, al
	test	edx, edx
	jne	SHORT $LN13@CalculateC
	lea	eax, DWORD PTR _bu0$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _mv1_hi$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _bu0$10[ebp]
	push	edx
	lea	eax, DWORD PTR _bu1$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _mv1_lo$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _bu1$9[ebp]
	push	edx
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	eax, al
	push	eax
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movsx	ecx, al
	test	ecx, ecx
	je	$LN12@CalculateC
$LN13@CalculateC:

; 168  :                 _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, bu1, mv1_lo, &bu1), bu0, mv1_hi, &bu0))
; 169  :             {
; 170  :                 if (sizeof(__UNIT_TYPE_DIV) <= 4)

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN14@CalculateC

; 171  :                     env->log("found: u0=0x%08x, u1=0x%08x, u2=0x%08x, u3=0x%08x, v1=0x%08x, v2=0x%08x, v3=0x%08x\n", u0, u1, u2, u3, v1, v2, v3);

	mov	esi, esp
	mov	eax, DWORD PTR _v3$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _v2$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _v1$14[ebp]
	push	edx
	mov	eax, DWORD PTR _u3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u1$[ebp]
	push	edx
	mov	eax, DWORD PTR _u0$[ebp]
	push	eax
	push	OFFSET $SG95797
	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx]
	call	edx
	add	esp, 32					; 00000020H
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN15@CalculateC
$LN14@CalculateC:

; 172  :                 else
; 173  :                     env->log("found: u0=0x%016llx, u1=0x%016llx, u2=0x%016llx, u3=0x%016llx, v1=0x%016llx, v2=0x%016llx, v3=0x%016llx\n", u0, u1, u2, u3, v1, v2, v3);

	mov	esi, esp
	mov	eax, DWORD PTR _v3$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _v2$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _v1$14[ebp]
	push	edx
	mov	eax, DWORD PTR _u3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u1$[ebp]
	push	edx
	mov	eax, DWORD PTR _u0$[ebp]
	push	eax
	push	OFFSET $SG95798
	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx]
	call	edx
	add	esp, 32					; 00000020H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@CalculateC:

; 174  :                 env->pause();

	mov	eax, DWORD PTR _env$[ebp]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+4]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@CalculateC:

; 175  :             }
; 176  : 
; 177  :             if (SUBTRUCT_3W_UNIT(&v_count_1, &v_count_2, &v_count_3, 1))

	push	1
	lea	edx, DWORD PTR _v_count_3$15[ebp]
	push	edx
	lea	eax, DWORD PTR _v_count_2$16[ebp]
	push	eax
	lea	ecx, DWORD PTR _v_count_1$17[ebp]
	push	ecx
	call	_SUBTRUCT_3W_UNIT
	add	esp, 16					; 00000010H
	movsx	edx, al
	test	edx, edx
	je	SHORT $LN16@CalculateC

; 178  :                 break;

	jmp	SHORT $LN6@CalculateC
$LN16@CalculateC:

; 179  :             ADD_3W_UNIT(&v1, &v2, &v3, 1);

	push	1
	lea	eax, DWORD PTR _v3$12[ebp]
	push	eax
	lea	ecx, DWORD PTR _v2$13[ebp]
	push	ecx
	lea	edx, DWORD PTR _v1$14[ebp]
	push	edx
	call	_ADD_3W_UNIT
	add	esp, 16					; 00000010H

; 180  :         }

	jmp	$LN7@CalculateC
$LN6@CalculateC:

; 181  :         if (SUBTRUCT_4W_UNIT(&u_count_0, &u_count_1, &u_count_2, &u_count_3, 1))

	push	1
	lea	eax, DWORD PTR _u_count_3$[ebp]
	push	eax
	lea	ecx, DWORD PTR _u_count_2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _u_count_1$[ebp]
	push	edx
	lea	eax, DWORD PTR _u_count_0$[ebp]
	push	eax
	call	_SUBTRUCT_4W_UNIT
	add	esp, 20					; 00000014H
	movsx	ecx, al
	test	ecx, ecx
	je	SHORT $LN17@CalculateC

; 182  :             break;

	jmp	SHORT $LN1@CalculateC
$LN17@CalculateC:

; 183  :         ADD_4W_UNIT(&u0, &u1, &u2, &u3, 1);

	push	1
	lea	edx, DWORD PTR _u3$[ebp]
	push	edx
	lea	eax, DWORD PTR _u2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _u1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _u0$[ebp]
	push	edx
	call	_ADD_4W_UNIT
	add	esp, 20					; 00000014H

; 184  :     }

	jmp	$LN4@CalculateC
$LN1@CalculateC:

; 185  : 
; 186  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN41@CalculateC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 296				; 00000128H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN41@CalculateC:
	DD	21					; 00000015H
	DD	$LN40@CalculateC
$LN40@CalculateC:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN19@CalculateC
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN20@CalculateC
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN21@CalculateC
	DD	-72					; ffffffb8H
	DD	4
	DD	$LN22@CalculateC
	DD	-84					; ffffffacH
	DD	4
	DD	$LN23@CalculateC
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN24@CalculateC
	DD	-108					; ffffff94H
	DD	4
	DD	$LN25@CalculateC
	DD	-120					; ffffff88H
	DD	4
	DD	$LN26@CalculateC
	DD	-132					; ffffff7cH
	DD	4
	DD	$LN27@CalculateC
	DD	-144					; ffffff70H
	DD	4
	DD	$LN28@CalculateC
	DD	-156					; ffffff64H
	DD	4
	DD	$LN29@CalculateC
	DD	-168					; ffffff58H
	DD	4
	DD	$LN30@CalculateC
	DD	-180					; ffffff4cH
	DD	4
	DD	$LN31@CalculateC
	DD	-192					; ffffff40H
	DD	4
	DD	$LN32@CalculateC
	DD	-208					; ffffff30H
	DD	4
	DD	$LN33@CalculateC
	DD	-220					; ffffff24H
	DD	4
	DD	$LN34@CalculateC
	DD	-232					; ffffff18H
	DD	4
	DD	$LN35@CalculateC
	DD	-244					; ffffff0cH
	DD	4
	DD	$LN36@CalculateC
	DD	-256					; ffffff00H
	DD	4
	DD	$LN37@CalculateC
	DD	-272					; fffffef0H
	DD	4
	DD	$LN38@CalculateC
	DD	-288					; fffffee0H
	DD	4
	DD	$LN39@CalculateC
$LN39@CalculateC:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	51					; 00000033H
	DB	95					; 0000005fH
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
$LN38@CalculateC:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	50					; 00000032H
	DB	95					; 0000005fH
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
$LN37@CalculateC:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
$LN36@CalculateC:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	51					; 00000033H
	DB	0
$LN35@CalculateC:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	50					; 00000032H
	DB	0
$LN34@CalculateC:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	49					; 00000031H
	DB	0
$LN33@CalculateC:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	48					; 00000030H
	DB	0
$LN32@CalculateC:
	DB	118					; 00000076H
	DB	51					; 00000033H
	DB	0
$LN31@CalculateC:
	DB	118					; 00000076H
	DB	50					; 00000032H
	DB	0
$LN30@CalculateC:
	DB	118					; 00000076H
	DB	49					; 00000031H
	DB	0
$LN29@CalculateC:
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	51					; 00000033H
	DB	0
$LN28@CalculateC:
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	50					; 00000032H
	DB	0
$LN27@CalculateC:
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	49					; 00000031H
	DB	0
$LN26@CalculateC:
	DB	117					; 00000075H
	DB	51					; 00000033H
	DB	0
$LN25@CalculateC:
	DB	117					; 00000075H
	DB	50					; 00000032H
	DB	0
$LN24@CalculateC:
	DB	117					; 00000075H
	DB	49					; 00000031H
	DB	0
$LN23@CalculateC:
	DB	117					; 00000075H
	DB	48					; 00000030H
	DB	0
$LN22@CalculateC:
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	51					; 00000033H
	DB	0
$LN21@CalculateC:
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	50					; 00000032H
	DB	0
$LN20@CalculateC:
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	49					; 00000031H
	DB	0
$LN19@CalculateC:
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	48					; 00000030H
	DB	0
_CalculateCriticalDataOfDivision ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToMULTI64Counter PROC

; 1102 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 1103 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info
	lock	 xadd	 DWORD PTR [ecx], eax

; 1104 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_AddToMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToMULTI32Counter PROC

; 1096 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 1097 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info+4
	lock	 xadd	 DWORD PTR [ecx], eax

; 1098 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_AddToMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_IncrementDIV64Counter PROC

; 1067 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 1068 :     _InterlockedIncrement(&statistics_info.COUNT_DIV64);

	lock	 inc	 (null) PTR _statistics_info+8

; 1069 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_IncrementDIV64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_IncrementDIV32Counter PROC

; 1061 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 1062 :     _InterlockedIncrement(&statistics_info.COUNT_DIV32);

	lock	 inc	 (null) PTR _statistics_info+12

; 1063 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_IncrementDIV32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_t$1 = -8						; size = 8
_u_high$ = 8						; size = 4
_u_low$ = 12						; size = 4
_v$ = 16						; size = 4
_r$ = 20						; size = 4
__DIVREM_UNIT PROC

; 660  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 661  : #ifdef _MSC_VER
; 662  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@DIVREM_UNI

; 663  :     {
; 664  :         // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 665  :         _UINT64_T t = _FROMWORDTODWORD(u_high, u_low);

	mov	ecx, DWORD PTR _u_low$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u_high$[ebp]
	push	edx
	call	__FROMWORDTODWORD
	add	esp, 8
	mov	DWORD PTR _t$1[ebp], eax
	mov	DWORD PTR _t$1[ebp+4], edx

; 666  :         *r = (_UINT32_T)(t % v);

	mov	eax, DWORD PTR _v$[ebp]
	xor	ecx, ecx
	push	ecx
	push	eax
	mov	edx, DWORD PTR _t$1[ebp+4]
	push	edx
	mov	eax, DWORD PTR _t$1[ebp]
	push	eax
	call	__aullrem
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx], eax

; 667  :         return ((_UINT32_T)(t / v));

	mov	edx, DWORD PTR _v$[ebp]
	xor	eax, eax
	push	eax
	push	edx
	mov	ecx, DWORD PTR _t$1[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _t$1[ebp]
	push	edx
	call	__aulldiv
	jmp	SHORT $LN1@DIVREM_UNI

; 668  :     }

	jmp	SHORT $LN1@DIVREM_UNI
$LN2@DIVREM_UNI:

; 669  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	eax, eax
	je	SHORT $LN4@DIVREM_UNI

; 670  :     {
; 671  :         // 以下の理由のため、MSVCでは 128bit/64bit の除算を実装できない。運用で回避すること。
; 672  :         // ・(x64 に限らず) 除算の組み込み関数が用意されていない。
; 673  :         // ・128bit 整数のデータ型が用意されていない。
; 674  :         // ・x64 ではインラインアセンブラがサポートされていない。
; 675  :         *r = 0;

	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx], 0

; 676  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@DIVREM_UNI

; 677  :     }

	jmp	SHORT $LN1@DIVREM_UNI
$LN4@DIVREM_UNI:

; 678  :     else
; 679  :     {
; 680  :         // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 681  :         *r = 0;

	mov	edx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx], 0

; 682  :         return (0);

	xor	eax, eax
$LN1@DIVREM_UNI:

; 683  :     }
; 684  : #elif defined(__GNUC__)
; 685  :     __UNIT_TYPE q;
; 686  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 687  :         __asm__("divl %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 688  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 689  :         __asm__("divq %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 690  :     else
; 691  :     {
; 692  :         // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 693  :         *r = 0;
; 694  :         q = 0;
; 695  :     }
; 696  :     return (q);
; 697  : #else
; 698  : #error unknown compiler
; 699  : #endif
; 700  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__DIVREM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_w_hi$ = 16						; size = 4
__MULTIPLY_UNIT_DIV PROC

; 592  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 593  : #ifdef _MSC_VER
; 594  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, DWORD PTR _w_hi$[ebp]
	push	eax
	mov	eax, DWORD PTR _u$[ebp]
	mul	DWORD PTR _v$[ebp]
	push	edx
	push	eax
	call	__FROMDWORDTOWORD
	add	esp, 12					; 0000000cH

; 595  : #elif defined(__GNUC__)
; 596  : #ifdef _M_IX86
; 597  :     _UINT32_T w_lo;
; 598  :     __asm__("mull %3": "=a"(w_lo), "=d"(*w_hi) : "0"(u), "rm"(v));
; 599  :     return (w_lo);
; 600  : #elif defined(_M_X64)
; 601  :     return (_umul128(u, v, w_hi));
; 602  : #else
; 603  : #error unknown platform
; 604  : #endif
; 605  : #else
; 606  : #error unknown compiler
; 607  : #endif
; 608  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__MULTIPLY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_borrow$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__SUBTRUCT_UNIT_DIV PROC

; 556  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 557  : #ifdef _MSC_VER
; 558  :     return (_subborrow_u32(borrow, u, v, w));

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _u$[ebp]
	mov	bl, BYTE PTR _borrow$[ebp]
	add	bl, 255					; 000000ffH
	sbb	edx, ecx
	setb	cl
	mov	DWORD PTR [eax], edx
	mov	al, cl

; 559  : #elif defined(__GNUC__)
; 560  : #ifdef _M_IX86
; 561  :     return (_subborrow_u32(borrow, u, v, w));
; 562  : #elif defined(_M_X64)
; 563  :     return (_subborrow_u64(borrow, u, v, w));
; 564  : #else
; 565  : #error unknown platform
; 566  : #endif
; 567  : #else
; 568  : #error unknown compiler
; 569  : #endif
; 570  : }

	pop	ebx
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__SUBTRUCT_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_carry$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__ADD_UNIT_DIV PROC

; 500  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 501  : #ifdef _MSC_VER
; 502  :     return (_addcarry_u32(carry, u, v, w));

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _u$[ebp]
	mov	bl, BYTE PTR _carry$[ebp]
	add	bl, 255					; 000000ffH
	adc	edx, ecx
	setb	cl
	mov	DWORD PTR [eax], edx
	mov	al, cl

; 503  : #elif defined(__GNUC__)
; 504  : #ifdef _M_IX86
; 505  :     return (_addcarry_u32(carry, u, v, w));
; 506  : #elif defined(_M_X64)
; 507  :     return (_addcarry_u64(carry, u, v, w));
; 508  : #else
; 509  : #error unknown platform
; 510  : #endif
; 511  : #else
; 512  : #error unknown compiler
; 513  : #endif
; 514  : }

	pop	ebx
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__ADD_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_value$ = 8						; size = 8
_result_high$ = 16					; size = 4
__FROMDWORDTOWORD PROC

; 458  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 459  :     *result_high = (_UINT32_T)(value >> 32);

	mov	eax, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR _value$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__aullshr
	mov	ecx, DWORD PTR _result_high$[ebp]
	mov	DWORD PTR [ecx], eax

; 460  :     return ((_UINT32_T)value);

	mov	eax, DWORD PTR _value$[ebp]

; 461  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__FROMDWORDTOWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_value_high$ = 8					; size = 4
_value_low$ = 12					; size = 4
__FROMWORDTODWORD PROC

; 453  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 454  :     return (((_UINT64_T)value_high << 32) | value_low);

	xor	edx, edx
	mov	eax, DWORD PTR _value_high$[ebp]
	mov	cl, 32					; 00000020H
	call	__allshl
	xor	ecx, ecx
	or	eax, DWORD PTR _value_low$[ebp]
	or	edx, ecx

; 455  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__FROMWORDTODWORD ENDP
_TEXT	ENDS
END
