; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

	TITLE	Z:\Sources\Lunor\Repos\rougemeilland\Palmtree.Math.Core.Implements\Palmtree.Math.Core.Implements\CALC_divrem_critical.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__4522B509_pmc_internal@h DB 01H
__1C66ECB2_pmc_debug@h DB 01H
__7646DD32_calc_divrem_critical@c DB 01H
msvcjmc	ENDS
PUBLIC	_CalculateCriticalDataOfDivision
PUBLIC	__JustMyCode_Default
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allshl:PROC
EXTRN	__aulldiv:PROC
EXTRN	__aullrem:PROC
EXTRN	__aullshr:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
_DATA	SEGMENT
$SG94817 DB	'found: u0=0x%08x, u1=0x%08x, u2=0x%08x, u3=0x%08x, v1=0x'
	DB	'%08x, v2=0x%08x, v3=0x%08x', 0aH, 00H
	ORG $+4
$SG94818 DB	'found: u0=0x%016llx, u1=0x%016llx, u2=0x%016llx, u3=0x%0'
	DB	'16llx, v1=0x%016llx, v2=0x%016llx, v3=0x%016llx', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
tv86 = -52						; size = 4
_rh_lo$ = -48						; size = 4
_rh_mi$ = -40						; size = 4
_rh_hi$ = -28						; size = 4
_lh_lo$ = -20						; size = 4
_lh_mi$ = -12						; size = 4
_lh_hi$ = -4						; size = 4
_q_$ = 8						; size = 4
_u0$ = 12						; size = 4
_u1$ = 16						; size = 4
_u2$ = 20						; size = 4
_v1$ = 24						; size = 4
_v2$ = 28						; size = 4
_CheckQ_ PROC

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 70   :     const __UNIT_TYPE_DIV lh_hi = 0;

	mov	DWORD PTR _lh_hi$[ebp], 0

; 71   :     __UNIT_TYPE_DIV lh_mi;
; 72   :     __UNIT_TYPE_DIV lh_lo = _MULTIPLY_UNIT_DIV(v2, q_, &lh_mi);

	lea	eax, DWORD PTR _lh_mi$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q_$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v2$[ebp]
	push	edx
	call	__MULTIPLY_UNIT_DIV
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lh_lo$[ebp], eax

; 73   :     __UNIT_TYPE_DIV rh_hi;
; 74   :     __UNIT_TYPE_DIV rh_mi = _MULTIPLY_UNIT_DIV(q_, v1, &rh_hi);

	lea	eax, DWORD PTR _rh_hi$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _q_$[ebp]
	push	edx
	call	__MULTIPLY_UNIT_DIV
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _rh_mi$[ebp], eax

; 75   :     __UNIT_TYPE_DIV rh_lo = u2;

	mov	eax, DWORD PTR _u2$[ebp]
	mov	DWORD PTR _rh_lo$[ebp], eax

; 76   :     _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, u1, rh_mi, &rh_mi), u0, rh_hi, &rh_hi);

	lea	ecx, DWORD PTR _rh_hi$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rh_hi$[ebp]
	push	edx
	mov	eax, DWORD PTR _u0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rh_mi$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rh_mi$[ebp]
	push	edx
	mov	eax, DWORD PTR _u1$[ebp]
	push	eax
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H

; 77   :     if (lh_hi > rh_hi)

	mov	edx, DWORD PTR _lh_hi$[ebp]
	cmp	edx, DWORD PTR _rh_hi$[ebp]
	jbe	SHORT $LN2@CheckQ_

; 78   :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN1@CheckQ_
$LN2@CheckQ_:

; 79   :     else if (lh_hi < rh_hi)

	mov	eax, DWORD PTR _lh_hi$[ebp]
	cmp	eax, DWORD PTR _rh_hi$[ebp]
	jae	SHORT $LN4@CheckQ_

; 80   :         return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN1@CheckQ_
$LN4@CheckQ_:

; 81   :     else if (lh_mi > rh_mi)

	mov	ecx, DWORD PTR _lh_mi$[ebp]
	cmp	ecx, DWORD PTR _rh_mi$[ebp]
	jbe	SHORT $LN6@CheckQ_

; 82   :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN1@CheckQ_
$LN6@CheckQ_:

; 83   :     else if (lh_mi < rh_mi)

	mov	edx, DWORD PTR _lh_mi$[ebp]
	cmp	edx, DWORD PTR _rh_mi$[ebp]
	jae	SHORT $LN8@CheckQ_

; 84   :         return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN1@CheckQ_
$LN8@CheckQ_:

; 85   :     else
; 86   :         return (lh_lo > rh_lo);

	mov	eax, DWORD PTR _lh_lo$[ebp]
	cmp	eax, DWORD PTR _rh_lo$[ebp]
	jbe	SHORT $LN11@CheckQ_
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN12@CheckQ_
$LN11@CheckQ_:
	mov	DWORD PTR tv86[ebp], 0
$LN12@CheckQ_:
	mov	eax, DWORD PTR tv86[ebp]
$LN1@CheckQ_:

; 87   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@CheckQ_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN17@CheckQ_:
	DD	3
	DD	$LN16@CheckQ_
$LN16@CheckQ_:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN13@CheckQ_
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN14@CheckQ_
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN15@CheckQ_
$LN15@CheckQ_:
	DB	114					; 00000072H
	DB	104					; 00000068H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	0
$LN14@CheckQ_:
	DB	114					; 00000072H
	DB	104					; 00000068H
	DB	95					; 0000005fH
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
$LN13@CheckQ_:
	DB	108					; 0000006cH
	DB	104					; 00000068H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	0
_CheckQ_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_q$ = -16						; size = 4
_r$ = -8						; size = 4
_u0$ = 8						; size = 4
_u1$ = 12						; size = 4
_v1$ = 16						; size = 4
_AsumeQ_ PROC

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 61   :     if (u0 == v1)

	mov	eax, DWORD PTR _u0$[ebp]
	cmp	eax, DWORD PTR _v1$[ebp]
	jne	SHORT $LN2@AsumeQ_

; 62   :         return ((__UNIT_TYPE_DIV)-1);

	or	eax, -1
	jmp	SHORT $LN1@AsumeQ_
$LN2@AsumeQ_:

; 63   :     __UNIT_TYPE_DIV r;
; 64   :     __UNIT_TYPE_DIV q = _DIVREM_UNIT(u0, u1, v1, &r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v1$[ebp]
	push	edx
	mov	eax, DWORD PTR _u1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u0$[ebp]
	push	ecx
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _q$[ebp], eax

; 65   :     return (q);

	mov	eax, DWORD PTR _q$[ebp]
$LN1@AsumeQ_:

; 66   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@AsumeQ_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@AsumeQ_:
	DD	1
	DD	$LN5@AsumeQ_
$LN5@AsumeQ_:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN4@AsumeQ_
$LN4@AsumeQ_:
	DB	114					; 00000072H
	DB	0
_AsumeQ_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_x2$ = 12						; size = 4
_x3$ = 16						; size = 4
_x4$ = 20						; size = 4
_y$ = 24						; size = 4
_SUBTRUCT_4W_UNIT PROC

; 55   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 56   :     return (_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, *x4, y, x4), *x3, 0, x3), *x2, 0, x2), *x1, 0, x1));

	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x3$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x3$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x4$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x4$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	eax, al
	push	eax
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H

; 57   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_SUBTRUCT_4W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_x2$ = 12						; size = 4
_x3$ = 16						; size = 4
_y$ = 20						; size = 4
_SUBTRUCT_3W_UNIT PROC

; 50   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 51   :     return (_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, *x3, y, x3), *x2, 0, x2), *x1, 0, x1));

	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x3$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H

; 52   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_SUBTRUCT_3W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_x2$ = 12						; size = 4
_x3$ = 16						; size = 4
_x4$ = 20						; size = 4
_y$ = 24						; size = 4
_ADD_4W_UNIT PROC

; 45   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 46   :     return (_ADD_UNIT_DIV(_ADD_UNIT_DIV(_ADD_UNIT_DIV(_ADD_UNIT_DIV(0, *x4, y, x4), *x3, 0, x3), *x2, 0, x2), *x1, 0, x1));

	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x3$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x3$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x4$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x4$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	eax, al
	push	eax
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H

; 47   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_ADD_4W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_x2$ = 12						; size = 4
_x3$ = 16						; size = 4
_y$ = 20						; size = 4
_ADD_3W_UNIT PROC

; 40   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 41   :     return (_ADD_UNIT_DIV(_ADD_UNIT_DIV(_ADD_UNIT_DIV(0, *x3, y, x3), *x2, 0, x2), *x1, 0, x1));

	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x3$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__ADD_UNIT_DIV
	add	esp, 16					; 00000010H

; 42   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_ADD_3W_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\calc_divrem_critical.c
_TEXT	SEGMENT
_mv3_lo$1 = -296					; size = 4
_mv3_hi$2 = -288					; size = 4
_mv2_lo$3 = -280					; size = 4
_mv2_hi$4 = -272					; size = 4
_mv1_lo$5 = -264					; size = 4
_mv1_hi$6 = -256					; size = 4
_bu3$7 = -244						; size = 4
_bu2$8 = -232						; size = 4
_bu1$9 = -220						; size = 4
_bu0$10 = -208						; size = 4
_q_$11 = -200						; size = 4
_v3$12 = -192						; size = 4
_v2$13 = -180						; size = 4
_v1$14 = -168						; size = 4
_v_count_3$15 = -156					; size = 4
_v_count_2$16 = -144					; size = 4
_v_count_1$17 = -132					; size = 4
_u3$ = -120						; size = 4
_u2$ = -108						; size = 4
_u1$ = -96						; size = 4
_u0$ = -84						; size = 4
_u_count_3$ = -72					; size = 4
_u_count_2$ = -60					; size = 4
_u_count_1$ = -48					; size = 4
_u_count_0$ = -36					; size = 4
_u_min_3$ = -28						; size = 4
_u_min_2$ = -24						; size = 4
_u_min_1$ = -20						; size = 4
_u_min_0$ = -16						; size = 4
_v_min_3$ = -12						; size = 4
_v_min_2$ = -8						; size = 4
_v_min_1$ = -4						; size = 4
_env$ = 8						; size = 4
_CalculateCriticalDataOfDivision PROC

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-296]
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7646DD32_calc_divrem_critical@c
	call	@__CheckForDebuggerJustMyCode@4

; 91   :     const __UNIT_TYPE_DIV v_min_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);    // 0x80000000

	mov	DWORD PTR _v_min_1$[ebp], -2147483648	; 80000000H

; 92   :     const __UNIT_TYPE_DIV v_min_2 = 0;                              // 0x00000000

	mov	DWORD PTR _v_min_2$[ebp], 0

; 93   :     const __UNIT_TYPE_DIV v_min_3 = 0;

	mov	DWORD PTR _v_min_3$[ebp], 0

; 94   : 
; 95   :     const __UNIT_TYPE_DIV u_min_0 = 0;                              // 0x00000000

	mov	DWORD PTR _u_min_0$[ebp], 0

; 96   :     const __UNIT_TYPE_DIV u_min_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);    // 0x80000000

	mov	DWORD PTR _u_min_1$[ebp], -2147483648	; 80000000H

; 97   :     const __UNIT_TYPE_DIV u_min_2 = 0;                              // 0x00000000

	mov	DWORD PTR _u_min_2$[ebp], 0

; 98   :     const __UNIT_TYPE_DIV u_min_3 = 0;                              // 0x00000000

	mov	DWORD PTR _u_min_3$[ebp], 0

; 99   : 
; 100  :     __UNIT_TYPE_DIV u_count_0 = (__UNIT_TYPE_DIV)-1;                // 0xffffffff

	mov	DWORD PTR _u_count_0$[ebp], -1

; 101  :     __UNIT_TYPE_DIV u_count_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);        // 0x80000000

	mov	DWORD PTR _u_count_1$[ebp], -2147483648	; 80000000H

; 102  :     __UNIT_TYPE_DIV u_count_2 = 0;                                  // 0x00000000

	mov	DWORD PTR _u_count_2$[ebp], 0

; 103  :     __UNIT_TYPE_DIV u_count_3 = 0;                                  // 0x00000000

	mov	DWORD PTR _u_count_3$[ebp], 0

; 104  : 
; 105  :     __UNIT_TYPE_DIV u0 = u_min_0;

	mov	eax, DWORD PTR _u_min_0$[ebp]
	mov	DWORD PTR _u0$[ebp], eax

; 106  :     __UNIT_TYPE_DIV u1 = u_min_1;

	mov	ecx, DWORD PTR _u_min_1$[ebp]
	mov	DWORD PTR _u1$[ebp], ecx

; 107  :     __UNIT_TYPE_DIV u2 = u_min_2;

	mov	edx, DWORD PTR _u_min_2$[ebp]
	mov	DWORD PTR _u2$[ebp], edx

; 108  :     __UNIT_TYPE_DIV u3 = u_min_3;

	mov	eax, DWORD PTR _u_min_3$[ebp]
	mov	DWORD PTR _u3$[ebp], eax
$LN4@CalculateC:

; 109  : 
; 110  :     for (;;)
; 111  :     {
; 112  :         __UNIT_TYPE_DIV v_count_1 = ~((__UNIT_TYPE_DIV)-1 >> 1);    // 0x80000000

	mov	DWORD PTR _v_count_1$17[ebp], -2147483648 ; 80000000H

; 113  :         __UNIT_TYPE_DIV v_count_2 = 0;                              // 0x00000000

	mov	DWORD PTR _v_count_2$16[ebp], 0

; 114  :         __UNIT_TYPE_DIV v_count_3 = 0;                              // 0x00000000

	mov	DWORD PTR _v_count_3$15[ebp], 0

; 115  :         __UNIT_TYPE_DIV v1 = v_min_1;

	mov	ecx, DWORD PTR _v_min_1$[ebp]
	mov	DWORD PTR _v1$14[ebp], ecx

; 116  :         __UNIT_TYPE_DIV v2 = v_min_2;

	mov	edx, DWORD PTR _v_min_2$[ebp]
	mov	DWORD PTR _v2$13[ebp], edx

; 117  :         __UNIT_TYPE_DIV v3 = v_min_3;

	mov	eax, DWORD PTR _v_min_3$[ebp]
	mov	DWORD PTR _v3$12[ebp], eax
$LN7@CalculateC:

; 118  :         for (;;)
; 119  :         {
; 120  :             __UNIT_TYPE_DIV q_ = AsumeQ_(u0, u1, v1);

	mov	ecx, DWORD PTR _v1$14[ebp]
	push	ecx
	mov	edx, DWORD PTR _u1$[ebp]
	push	edx
	mov	eax, DWORD PTR _u0$[ebp]
	push	eax
	call	_AsumeQ_
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _q_$11[ebp], eax

; 121  :             if (CheckQ_(q_, u0, u1, u2, v1, v2))

	mov	ecx, DWORD PTR _v2$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _v1$14[ebp]
	push	edx
	mov	eax, DWORD PTR _u2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u0$[ebp]
	push	edx
	mov	eax, DWORD PTR _q_$11[ebp]
	push	eax
	call	_CheckQ_
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN8@CalculateC

; 122  :             {
; 123  :                 --q_;

	mov	ecx, DWORD PTR _q_$11[ebp]
	sub	ecx, 1
	mov	DWORD PTR _q_$11[ebp], ecx

; 124  :                 if (CheckQ_(q_, u0, u1, u2, v1, v2))

	mov	edx, DWORD PTR _v2$13[ebp]
	push	edx
	mov	eax, DWORD PTR _v1$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _u2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u1$[ebp]
	push	edx
	mov	eax, DWORD PTR _u0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q_$11[ebp]
	push	ecx
	call	_CheckQ_
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN8@CalculateC

; 125  :                 {
; 126  :                     --q_;

	mov	edx, DWORD PTR _q_$11[ebp]
	sub	edx, 1
	mov	DWORD PTR _q_$11[ebp], edx
$LN8@CalculateC:

; 127  :                 }
; 128  :             }
; 129  :             __UNIT_TYPE_DIV bu0 = u0;

	mov	eax, DWORD PTR _u0$[ebp]
	mov	DWORD PTR _bu0$10[ebp], eax

; 130  :             __UNIT_TYPE_DIV bu1 = u1;

	mov	ecx, DWORD PTR _u1$[ebp]
	mov	DWORD PTR _bu1$9[ebp], ecx

; 131  :             __UNIT_TYPE_DIV bu2 = u2;

	mov	edx, DWORD PTR _u2$[ebp]
	mov	DWORD PTR _bu2$8[ebp], edx

; 132  :             __UNIT_TYPE_DIV bu3 = u3;

	mov	eax, DWORD PTR _u3$[ebp]
	mov	DWORD PTR _bu3$7[ebp], eax

; 133  :             __UNIT_TYPE_DIV mv1_hi;
; 134  :             __UNIT_TYPE_DIV mv1_lo = _MULTIPLY_UNIT_DIV(v1, q_, &mv1_hi);

	lea	ecx, DWORD PTR _mv1_hi$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _q_$11[ebp]
	push	edx
	mov	eax, DWORD PTR _v1$14[ebp]
	push	eax
	call	__MULTIPLY_UNIT_DIV
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _mv1_lo$5[ebp], eax

; 135  :             __UNIT_TYPE_DIV mv2_hi;
; 136  :             __UNIT_TYPE_DIV mv2_lo = _MULTIPLY_UNIT_DIV(v2, q_, &mv2_hi);

	lea	ecx, DWORD PTR _mv2_hi$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _q_$11[ebp]
	push	edx
	mov	eax, DWORD PTR _v2$13[ebp]
	push	eax
	call	__MULTIPLY_UNIT_DIV
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _mv2_lo$3[ebp], eax

; 137  :             __UNIT_TYPE_DIV mv3_hi;
; 138  :             __UNIT_TYPE_DIV mv3_lo = _MULTIPLY_UNIT_DIV(v3, q_, &mv3_hi);

	lea	ecx, DWORD PTR _mv3_hi$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _q_$11[ebp]
	push	edx
	mov	eax, DWORD PTR _v3$12[ebp]
	push	eax
	call	__MULTIPLY_UNIT_DIV
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _mv3_lo$1[ebp], eax

; 139  : 
; 140  :             // [bu0, bu1, bu2, bu3] -= mv3_lo;
; 141  :             // [bu0, bu1, bu2] -= mv3_hi;
; 142  :             // [bu0, bu1, bu2] -= mv2_lo;
; 143  :             // [bu0, bu1] -= mv2_hi;
; 144  :             // [bu0, bu1] -= mv1_lo;
; 145  :             // [bu0] -= mv1_hi;
; 146  : 
; 147  :                 
; 148  :             if (_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, bu3, mv3_lo, &bu3), bu2, mv3_hi, &bu2), bu1, 0, &bu1), bu0, 0, &bu0) ||
; 149  :                 _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, bu2, mv2_lo, &bu2), bu1, mv2_hi, &bu1), bu0, 0, &bu0) ||

	lea	ecx, DWORD PTR _bu0$10[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _bu0$10[ebp]
	push	edx
	lea	eax, DWORD PTR _bu1$9[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _bu1$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _bu2$8[ebp]
	push	edx
	mov	eax, DWORD PTR _mv3_hi$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _bu2$8[ebp]
	push	ecx
	lea	edx, DWORD PTR _bu3$7[ebp]
	push	edx
	mov	eax, DWORD PTR _mv3_lo$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _bu3$7[ebp]
	push	ecx
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	eax, al
	push	eax
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	ecx, al
	push	ecx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movsx	edx, al
	test	edx, edx
	jne	$LN11@CalculateC
	lea	eax, DWORD PTR _bu0$10[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _bu0$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _bu1$9[ebp]
	push	edx
	mov	eax, DWORD PTR _mv2_hi$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _bu1$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _bu2$8[ebp]
	push	edx
	mov	eax, DWORD PTR _mv2_lo$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _bu2$8[ebp]
	push	ecx
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	eax, al
	push	eax
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movsx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@CalculateC
	lea	edx, DWORD PTR _bu0$10[ebp]
	push	edx
	mov	eax, DWORD PTR _mv1_hi$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _bu0$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _bu1$9[ebp]
	push	edx
	mov	eax, DWORD PTR _mv1_lo$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _bu1$9[ebp]
	push	ecx
	push	0
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__SUBTRUCT_UNIT_DIV
	add	esp, 16					; 00000010H
	movsx	eax, al
	test	eax, eax
	je	$LN10@CalculateC
$LN11@CalculateC:

; 150  :                 _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, bu1, mv1_lo, &bu1), bu0, mv1_hi, &bu0))
; 151  :             {
; 152  :                 if (sizeof(__UNIT_TYPE_DIV) <= 4)

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN12@CalculateC

; 153  :                     env->log("found: u0=0x%08x, u1=0x%08x, u2=0x%08x, u3=0x%08x, v1=0x%08x, v2=0x%08x, v3=0x%08x\n", u0, u1, u2, u3, v1, v2, v3);

	mov	esi, esp
	mov	edx, DWORD PTR _v3$12[ebp]
	push	edx
	mov	eax, DWORD PTR _v2$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _v1$14[ebp]
	push	ecx
	mov	edx, DWORD PTR _u3$[ebp]
	push	edx
	mov	eax, DWORD PTR _u2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u0$[ebp]
	push	edx
	push	OFFSET $SG94817
	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 32					; 00000020H
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN13@CalculateC
$LN12@CalculateC:

; 154  :                 else
; 155  :                     env->log("found: u0=0x%016llx, u1=0x%016llx, u2=0x%016llx, u3=0x%016llx, v1=0x%016llx, v2=0x%016llx, v3=0x%016llx\n", u0, u1, u2, u3, v1, v2, v3);

	mov	esi, esp
	mov	edx, DWORD PTR _v3$12[ebp]
	push	edx
	mov	eax, DWORD PTR _v2$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _v1$14[ebp]
	push	ecx
	mov	edx, DWORD PTR _u3$[ebp]
	push	edx
	mov	eax, DWORD PTR _u2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u0$[ebp]
	push	edx
	push	OFFSET $SG94818
	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 32					; 00000020H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@CalculateC:

; 156  :                 env->pause();

	mov	edx, DWORD PTR _env$[ebp]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@CalculateC:

; 157  :             }
; 158  : 
; 159  :             if (SUBTRUCT_3W_UNIT(&v_count_1, &v_count_2, &v_count_3, 1))

	push	1
	lea	ecx, DWORD PTR _v_count_3$15[ebp]
	push	ecx
	lea	edx, DWORD PTR _v_count_2$16[ebp]
	push	edx
	lea	eax, DWORD PTR _v_count_1$17[ebp]
	push	eax
	call	_SUBTRUCT_3W_UNIT
	add	esp, 16					; 00000010H
	movsx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@CalculateC

; 160  :                 break;

	jmp	SHORT $LN6@CalculateC
$LN14@CalculateC:

; 161  :             ADD_3W_UNIT(&v1, &v2, &v3, 1);

	push	1
	lea	edx, DWORD PTR _v3$12[ebp]
	push	edx
	lea	eax, DWORD PTR _v2$13[ebp]
	push	eax
	lea	ecx, DWORD PTR _v1$14[ebp]
	push	ecx
	call	_ADD_3W_UNIT
	add	esp, 16					; 00000010H

; 162  :         }

	jmp	$LN7@CalculateC
$LN6@CalculateC:

; 163  :         if (SUBTRUCT_4W_UNIT(&u_count_0, &u_count_1, &u_count_2, &u_count_3, 1))

	push	1
	lea	edx, DWORD PTR _u_count_3$[ebp]
	push	edx
	lea	eax, DWORD PTR _u_count_2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _u_count_1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _u_count_0$[ebp]
	push	edx
	call	_SUBTRUCT_4W_UNIT
	add	esp, 20					; 00000014H
	movsx	eax, al
	test	eax, eax
	je	SHORT $LN15@CalculateC

; 164  :             break;

	jmp	SHORT $LN1@CalculateC
$LN15@CalculateC:

; 165  :         ADD_4W_UNIT(&u0, &u1, &u2, &u3, 1);

	push	1
	lea	ecx, DWORD PTR _u3$[ebp]
	push	ecx
	lea	edx, DWORD PTR _u2$[ebp]
	push	edx
	lea	eax, DWORD PTR _u1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _u0$[ebp]
	push	ecx
	call	_ADD_4W_UNIT
	add	esp, 20					; 00000014H

; 166  :     }

	jmp	$LN4@CalculateC
$LN1@CalculateC:

; 167  : 
; 168  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN39@CalculateC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 296				; 00000128H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@CalculateC:
	DD	21					; 00000015H
	DD	$LN38@CalculateC
$LN38@CalculateC:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN17@CalculateC
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN18@CalculateC
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN19@CalculateC
	DD	-72					; ffffffb8H
	DD	4
	DD	$LN20@CalculateC
	DD	-84					; ffffffacH
	DD	4
	DD	$LN21@CalculateC
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN22@CalculateC
	DD	-108					; ffffff94H
	DD	4
	DD	$LN23@CalculateC
	DD	-120					; ffffff88H
	DD	4
	DD	$LN24@CalculateC
	DD	-132					; ffffff7cH
	DD	4
	DD	$LN25@CalculateC
	DD	-144					; ffffff70H
	DD	4
	DD	$LN26@CalculateC
	DD	-156					; ffffff64H
	DD	4
	DD	$LN27@CalculateC
	DD	-168					; ffffff58H
	DD	4
	DD	$LN28@CalculateC
	DD	-180					; ffffff4cH
	DD	4
	DD	$LN29@CalculateC
	DD	-192					; ffffff40H
	DD	4
	DD	$LN30@CalculateC
	DD	-208					; ffffff30H
	DD	4
	DD	$LN31@CalculateC
	DD	-220					; ffffff24H
	DD	4
	DD	$LN32@CalculateC
	DD	-232					; ffffff18H
	DD	4
	DD	$LN33@CalculateC
	DD	-244					; ffffff0cH
	DD	4
	DD	$LN34@CalculateC
	DD	-256					; ffffff00H
	DD	4
	DD	$LN35@CalculateC
	DD	-272					; fffffef0H
	DD	4
	DD	$LN36@CalculateC
	DD	-288					; fffffee0H
	DD	4
	DD	$LN37@CalculateC
$LN37@CalculateC:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	51					; 00000033H
	DB	95					; 0000005fH
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
$LN36@CalculateC:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	50					; 00000032H
	DB	95					; 0000005fH
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
$LN35@CalculateC:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
$LN34@CalculateC:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	51					; 00000033H
	DB	0
$LN33@CalculateC:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	50					; 00000032H
	DB	0
$LN32@CalculateC:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	49					; 00000031H
	DB	0
$LN31@CalculateC:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	48					; 00000030H
	DB	0
$LN30@CalculateC:
	DB	118					; 00000076H
	DB	51					; 00000033H
	DB	0
$LN29@CalculateC:
	DB	118					; 00000076H
	DB	50					; 00000032H
	DB	0
$LN28@CalculateC:
	DB	118					; 00000076H
	DB	49					; 00000031H
	DB	0
$LN27@CalculateC:
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	51					; 00000033H
	DB	0
$LN26@CalculateC:
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	50					; 00000032H
	DB	0
$LN25@CalculateC:
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	49					; 00000031H
	DB	0
$LN24@CalculateC:
	DB	117					; 00000075H
	DB	51					; 00000033H
	DB	0
$LN23@CalculateC:
	DB	117					; 00000075H
	DB	50					; 00000032H
	DB	0
$LN22@CalculateC:
	DB	117					; 00000075H
	DB	49					; 00000031H
	DB	0
$LN21@CalculateC:
	DB	117					; 00000075H
	DB	48					; 00000030H
	DB	0
$LN20@CalculateC:
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	51					; 00000033H
	DB	0
$LN19@CalculateC:
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	50					; 00000032H
	DB	0
$LN18@CalculateC:
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	49					; 00000031H
	DB	0
$LN17@CalculateC:
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	48					; 00000030H
	DB	0
_CalculateCriticalDataOfDivision ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_t$1 = -8						; size = 8
_u_high$ = 8						; size = 4
_u_low$ = 12						; size = 4
_v$ = 16						; size = 4
_r$ = 20						; size = 4
__DIVREM_UNIT PROC

; 595  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 596  : #ifdef _MSC_VER
; 597  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@DIVREM_UNI

; 598  :     {
; 599  :         // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 600  :         _UINT64_T t = _FROMWORDTODWORD(u_high, u_low);

	mov	ecx, DWORD PTR _u_low$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u_high$[ebp]
	push	edx
	call	__FROMWORDTODWORD
	add	esp, 8
	mov	DWORD PTR _t$1[ebp], eax
	mov	DWORD PTR _t$1[ebp+4], edx

; 601  :         *r = (_UINT32_T)(t % v);

	mov	eax, DWORD PTR _v$[ebp]
	xor	ecx, ecx
	push	ecx
	push	eax
	mov	edx, DWORD PTR _t$1[ebp+4]
	push	edx
	mov	eax, DWORD PTR _t$1[ebp]
	push	eax
	call	__aullrem
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx], eax

; 602  :         return ((_UINT32_T)(t / v));

	mov	edx, DWORD PTR _v$[ebp]
	xor	eax, eax
	push	eax
	push	edx
	mov	ecx, DWORD PTR _t$1[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _t$1[ebp]
	push	edx
	call	__aulldiv
	jmp	SHORT $LN1@DIVREM_UNI

; 603  :     }

	jmp	SHORT $LN1@DIVREM_UNI
$LN2@DIVREM_UNI:

; 604  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	eax, eax
	je	SHORT $LN4@DIVREM_UNI

; 605  :     {
; 606  :         // 以下の理由のため、MSVCでは 128bit/64bit の除算を実装できない。運用で回避すること。
; 607  :         // ・(x64 に限らず) 除算の組み込み関数が用意されていない。
; 608  :         // ・128bit 整数のデータ型が用意されていない。
; 609  :         // ・x64 ではインラインアセンブラがサポートされていない。
; 610  :         *r = 0;

	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx], 0

; 611  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@DIVREM_UNI

; 612  :     }

	jmp	SHORT $LN1@DIVREM_UNI
$LN4@DIVREM_UNI:

; 613  :     else
; 614  :     {
; 615  :         // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 616  :         *r = 0;

	mov	edx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx], 0

; 617  :         return (0);

	xor	eax, eax
$LN1@DIVREM_UNI:

; 618  :     }
; 619  : #elif defined(__GNUC__)
; 620  :     __UNIT_TYPE q;
; 621  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 622  :         __asm__("divl %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 623  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 624  :         __asm__("divq %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 625  :     else
; 626  :     {
; 627  :         // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 628  :         *r = 0;
; 629  :         q = 0;
; 630  :     }
; 631  :     return (q);
; 632  : #else
; 633  : #error unknown compiler
; 634  : #endif
; 635  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__DIVREM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_w_hi$ = 16						; size = 4
__MULTIPLY_UNIT_DIV PROC

; 527  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 528  : #ifdef _MSC_VER
; 529  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, DWORD PTR _w_hi$[ebp]
	push	eax
	mov	eax, DWORD PTR _u$[ebp]
	mul	DWORD PTR _v$[ebp]
	push	edx
	push	eax
	call	__FROMDWORDTOWORD
	add	esp, 12					; 0000000cH

; 530  : #elif defined(__GNUC__)
; 531  : #ifdef _M_IX86
; 532  :     _UINT32_T w_lo;
; 533  :     __asm__("mull %3": "=a"(w_lo), "=d"(*w_hi) : "0"(u), "rm"(v));
; 534  :     return (w_lo);
; 535  : #elif defined(_M_X64)
; 536  :     return (_umul128(u, v, w_hi));
; 537  : #else
; 538  : #error unknown platform
; 539  : #endif
; 540  : #else
; 541  : #error unknown compiler
; 542  : #endif
; 543  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__MULTIPLY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_borrow$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__SUBTRUCT_UNIT_DIV PROC

; 491  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 492  : #ifdef _MSC_VER
; 493  :     return (_subborrow_u32(borrow, u, v, w));

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _u$[ebp]
	mov	bl, BYTE PTR _borrow$[ebp]
	add	bl, 255					; 000000ffH
	sbb	edx, ecx
	setb	cl
	mov	DWORD PTR [eax], edx
	mov	al, cl

; 494  : #elif defined(__GNUC__)
; 495  : #ifdef _M_IX86
; 496  :     return (_subborrow_u32(borrow, u, v, w));
; 497  : #elif defined(_M_X64)
; 498  :     return (_subborrow_u64(borrow, u, v, w));
; 499  : #else
; 500  : #error unknown platform
; 501  : #endif
; 502  : #else
; 503  : #error unknown compiler
; 504  : #endif
; 505  : }

	pop	ebx
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__SUBTRUCT_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_carry$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__ADD_UNIT_DIV PROC

; 435  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 436  : #ifdef _MSC_VER
; 437  :     return (_addcarry_u32(carry, u, v, w));

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _u$[ebp]
	mov	bl, BYTE PTR _carry$[ebp]
	add	bl, 255					; 000000ffH
	adc	edx, ecx
	setb	cl
	mov	DWORD PTR [eax], edx
	mov	al, cl

; 438  : #elif defined(__GNUC__)
; 439  : #ifdef _M_IX86
; 440  :     return (_addcarry_u32(carry, u, v, w));
; 441  : #elif defined(_M_X64)
; 442  :     return (_addcarry_u64(carry, u, v, w));
; 443  : #else
; 444  : #error unknown platform
; 445  : #endif
; 446  : #else
; 447  : #error unknown compiler
; 448  : #endif
; 449  : }

	pop	ebx
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__ADD_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_value$ = 8						; size = 8
_result_high$ = 16					; size = 4
__FROMDWORDTOWORD PROC

; 393  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 394  :     *result_high = (_UINT32_T)(value >> 32);

	mov	eax, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR _value$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__aullshr
	mov	ecx, DWORD PTR _result_high$[ebp]
	mov	DWORD PTR [ecx], eax

; 395  :     return ((_UINT32_T)value);

	mov	eax, DWORD PTR _value$[ebp]

; 396  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__FROMDWORDTOWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_value_high$ = 8					; size = 4
_value_low$ = 12					; size = 4
__FROMWORDTODWORD PROC

; 388  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 389  :     return (((_UINT64_T)value_high << 32) | value_low);

	xor	edx, edx
	mov	eax, DWORD PTR _value_high$[ebp]
	mov	cl, 32					; 00000020H
	call	__allshl
	xor	ecx, ecx
	or	eax, DWORD PTR _value_low$[ebp]
	or	edx, ecx

; 390  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__FROMWORDTODWORD ENDP
_TEXT	ENDS
END
