; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

	TITLE	Z:\Sources\Lunor\Repos\rougemeilland\Palmtree.Math.Core.Implements\Palmtree.Math.Core.Implements\pmc_tostring.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__4522B509_pmc_internal@h DB 01H
__3AA1CF5E_pmc_tostring@c DB 01H
msvcjmc	ENDS
PUBLIC	_Initialize_ToString
PUBLIC	_PMC_ToString@24
PUBLIC	__JustMyCode_Default
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrcpyW@8:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	_AllocateBlock:PROC
EXTRN	_DeallocateBlock:PROC
EXTRN	_CheckBlockLight:PROC
EXTRN	_CheckNumber:PROC
EXTRN	_DivRem_X_1W:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allshl:PROC
EXTRN	__aulldiv:PROC
EXTRN	__aullrem:PROC
EXTRN	_statistics_info:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_default_number_format_option DB 028H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
_DATA	SEGMENT
_decimal_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H, '5', 00H
	DB	'6', 00H, '7', 00H, '8', 00H, '9', 00H, 00H, 00H
	ORG $+2
_hexadecimal_lower_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H
	DB	'5', 00H, '6', 00H, '7', 00H, '8', 00H, '9', 00H, 'a', 00H, 'b'
	DB	00H, 'c', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 00H, 00H
	ORG $+2
_hexadecimal_upper_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H
	DB	'5', 00H, '6', 00H, '7', 00H, '8', 00H, '9', 00H, 'A', 00H, 'B'
	DB	00H, 'C', 00H, 'D', 00H, 'E', 00H, 'F', 00H, 00H, 00H
	ORG $+2
$SG94661 DB	',', 00H, 00H, 00H
$SG94662 DB	'.', 00H, 00H, 00H
$SG94663 DB	'3', 00H
	ORG $+2
$SG94664 DB	'+', 00H, 00H, 00H
$SG94665 DB	'-', 00H, 00H, 00H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
tv128 = -36						; size = 4
_w_count$1 = -32					; size = 4
_digit_table$2 = -28					; size = 4
_d_ptr$3 = -24						; size = 4
_s_ptr$4 = -20						; size = 4
_filling_digit_count$5 = -16				; size = 4
_total_length$6 = -12					; size = 4
_filling_digit_len$7 = -8				; size = 4
_output_len$8 = -4					; size = 4
_x$ = 8							; size = 4
_buffer$ = 12						; size = 4
_buffer_size$ = 16					; size = 4
_width$ = 20						; size = 4
_format_option$ = 24					; size = 4
_using_upper_letter$ = 28				; size = 4
_ToStringX PROC

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 480  :     if (x->IS_ZERO)

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN4@ToStringX

; 481  :     {
; 482  :         // x が 0 である場合
; 483  :         // 最低で 1 桁、最高で format_option->MinimumWidth 桁だけ '0' を出力する。
; 484  : 
; 485  :         if (width < 1)

	cmp	DWORD PTR _width$[ebp], 1
	jae	SHORT $LN6@ToStringX

; 486  :             width = 1;

	mov	DWORD PTR _width$[ebp], 1
$LN6@ToStringX:

; 487  :         if (buffer_size < width + 1)

	mov	edx, DWORD PTR _width$[ebp]
	add	edx, 1
	cmp	DWORD PTR _buffer_size$[ebp], edx
	jae	SHORT $LN7@ToStringX

; 488  :             return (PMC_STATUS_INSUFFICIENT_BUFFER);

	mov	eax, -4					; fffffffcH
	jmp	$LN1@ToStringX
$LN7@ToStringX:

; 489  :         _FILL_MEMORY_16(buffer, L'0', width);

	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 490  :         buffer[width] = L'\0';

	xor	edx, edx
	mov	eax, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 491  :     }

	jmp	$LN5@ToStringX
$LN4@ToStringX:

; 492  :     else
; 493  :     {
; 494  :         // x が 0 ではない場合
; 495  :         __UNIT_TYPE output_len = _DIVIDE_CEILING_UNIT(x->UNIT_BIT_COUNT, 4);

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	__DIVIDE_CEILING_UNIT
	add	esp, 8
	mov	DWORD PTR _output_len$8[ebp], eax

; 496  :         __UNIT_TYPE filling_digit_len;;
; 497  :         __UNIT_TYPE total_length;
; 498  :         if (output_len < width)

	mov	ecx, DWORD PTR _output_len$8[ebp]
	cmp	ecx, DWORD PTR _width$[ebp]
	jae	SHORT $LN8@ToStringX

; 499  :         {
; 500  :             filling_digit_len = width - output_len;

	mov	edx, DWORD PTR _width$[ebp]
	sub	edx, DWORD PTR _output_len$8[ebp]
	mov	DWORD PTR _filling_digit_len$7[ebp], edx

; 501  :             total_length = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _total_length$6[ebp], eax

; 502  :         }

	jmp	SHORT $LN9@ToStringX
$LN8@ToStringX:

; 503  :         else
; 504  :         {
; 505  :             filling_digit_len = 0;

	mov	DWORD PTR _filling_digit_len$7[ebp], 0

; 506  :             total_length = output_len;

	mov	ecx, DWORD PTR _output_len$8[ebp]
	mov	DWORD PTR _total_length$6[ebp], ecx
$LN9@ToStringX:

; 507  :         }
; 508  :         if (buffer_size < total_length + 1)

	mov	edx, DWORD PTR _total_length$6[ebp]
	add	edx, 1
	cmp	DWORD PTR _buffer_size$[ebp], edx
	jae	SHORT $LN10@ToStringX

; 509  :             return (PMC_STATUS_INSUFFICIENT_BUFFER);

	mov	eax, -4					; fffffffcH
	jmp	$LN1@ToStringX
$LN10@ToStringX:

; 510  :         __UNIT_TYPE filling_digit_count = filling_digit_len;

	mov	eax, DWORD PTR _filling_digit_len$7[ebp]
	mov	DWORD PTR _filling_digit_count$5[ebp], eax

; 511  :         if (filling_digit_len > 0)

	cmp	DWORD PTR _filling_digit_len$7[ebp], 0
	jbe	SHORT $LN11@ToStringX

; 512  :             _FILL_MEMORY_16(buffer, L'0', filling_digit_len);

	mov	ecx, DWORD PTR _filling_digit_len$7[ebp]
	push	ecx
	push	48					; 00000030H
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH
$LN11@ToStringX:

; 513  :         __UNIT_TYPE* s_ptr = x->BLOCK + x->UNIT_WORD_COUNT - 1;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+24]
	lea	ecx, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR _s_ptr$4[ebp], ecx

; 514  :         wchar_t* d_ptr = buffer + filling_digit_len;

	mov	edx, DWORD PTR _filling_digit_len$7[ebp]
	mov	eax, DWORD PTR _buffer$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _d_ptr$3[ebp], ecx

; 515  :         wchar_t* digit_table = using_upper_letter ? hexadecimal_upper_digits : hexadecimal_lower_digits;

	cmp	DWORD PTR _using_upper_letter$[ebp], 0
	je	SHORT $LN13@ToStringX
	mov	DWORD PTR tv128[ebp], OFFSET _hexadecimal_upper_digits
	jmp	SHORT $LN14@ToStringX
$LN13@ToStringX:
	mov	DWORD PTR tv128[ebp], OFFSET _hexadecimal_lower_digits
$LN14@ToStringX:
	mov	edx, DWORD PTR tv128[ebp]
	mov	DWORD PTR _digit_table$2[ebp], edx

; 516  :         __UNIT_TYPE w_count = x->UNIT_WORD_COUNT;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _w_count$1[ebp], ecx

; 517  :         d_ptr = ToStringX_1WORD(*s_ptr, (int)(x->UNIT_WORD_COUNT * (__UNIT_TYPE_BIT_COUNT / 4) - output_len), digit_table, d_ptr);

	mov	edx, DWORD PTR _d_ptr$3[ebp]
	push	edx
	mov	eax, DWORD PTR _digit_table$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 3
	sub	edx, DWORD PTR _output_len$8[ebp]
	push	edx
	mov	eax, DWORD PTR _s_ptr$4[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_ToStringX_1WORD
	add	esp, 16					; 00000010H
	mov	DWORD PTR _d_ptr$3[ebp], eax

; 518  :         --s_ptr;

	mov	edx, DWORD PTR _s_ptr$4[ebp]
	sub	edx, 4
	mov	DWORD PTR _s_ptr$4[ebp], edx

; 519  :         --w_count;

	mov	eax, DWORD PTR _w_count$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _w_count$1[ebp], eax
$LN2@ToStringX:

; 520  :         while (w_count > 0)

	cmp	DWORD PTR _w_count$1[ebp], 0
	jbe	SHORT $LN3@ToStringX

; 521  :         {
; 522  :             d_ptr = ToStringX_1WORD(*s_ptr, 0, digit_table, d_ptr);

	mov	ecx, DWORD PTR _d_ptr$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _digit_table$2[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _s_ptr$4[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_ToStringX_1WORD
	add	esp, 16					; 00000010H
	mov	DWORD PTR _d_ptr$3[ebp], eax

; 523  :             --s_ptr;

	mov	edx, DWORD PTR _s_ptr$4[ebp]
	sub	edx, 4
	mov	DWORD PTR _s_ptr$4[ebp], edx

; 524  :             --w_count;

	mov	eax, DWORD PTR _w_count$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _w_count$1[ebp], eax

; 525  :         }

	jmp	SHORT $LN2@ToStringX
$LN3@ToStringX:

; 526  :         *d_ptr = '\0';

	xor	ecx, ecx
	mov	edx, DWORD PTR _d_ptr$3[ebp]
	mov	WORD PTR [edx], cx
$LN5@ToStringX:

; 527  :     }
; 528  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringX:

; 529  : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ToStringX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_skip_digit_len$ = 12					; size = 4
_digit_table$ = 16					; size = 4
_ptr$ = 20						; size = 4
_ToStringX_1WORD PROC

; 411  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 412  :     if (sizeof(__UNIT_TYPE) > sizeof(_UINT64_T))

	xor	eax, eax
	je	SHORT $LN2@ToStringX_

; 413  :     {
; 414  :         // 64bit を超える __UNIT_TYPE には未対応
; 415  :         // 対応するには以降のコーディングを見直す必要がある
; 416  :         return (NULL);

	xor	eax, eax
	jmp	$LN1@ToStringX_
$LN2@ToStringX_:

; 417  :     }
; 418  :     int count = __UNIT_TYPE_BIT_COUNT / 4;

	mov	DWORD PTR _count$[ebp], 8

; 419  :     if (skip_digit_len > 0)

	cmp	DWORD PTR _skip_digit_len$[ebp], 0
	jle	SHORT $LN3@ToStringX_

; 420  :     {
; 421  :         x = _ROTATE_L_UNIT(x, 4 * skip_digit_len);

	mov	ecx, DWORD PTR _skip_digit_len$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax

; 422  :         count -= skip_digit_len;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, DWORD PTR _skip_digit_len$[ebp]
	mov	DWORD PTR _count$[ebp], eax
$LN3@ToStringX_:

; 423  :     }
; 424  :     if (count & 0x10)

	mov	ecx, DWORD PTR _count$[ebp]
	and	ecx, 16					; 00000010H
	je	$LN4@ToStringX_

; 425  :     {
; 426  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 427  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [ecx+eax], dx

; 428  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [eax+edx], cx

; 429  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 430  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [ecx+eax], dx

; 431  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 5
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 432  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 433  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 7
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 434  :         x = _ROTATE_L_UNIT(x, 4); ptr[8] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	shl	edx, 3
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [eax+edx], cx

; 435  :         x = _ROTATE_L_UNIT(x, 4); ptr[9] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 9
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 436  :         x = _ROTATE_L_UNIT(x, 4); ptr[10] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 10
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 437  :         x = _ROTATE_L_UNIT(x, 4); ptr[11] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 11
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 438  :         x = _ROTATE_L_UNIT(x, 4); ptr[12] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 12
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 439  :         x = _ROTATE_L_UNIT(x, 4); ptr[13] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 13
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 440  :         x = _ROTATE_L_UNIT(x, 4); ptr[14] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 14
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 441  :         x = _ROTATE_L_UNIT(x, 4); ptr[15] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 15
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 442  :         ptr += 16;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR _ptr$[ebp], ecx
$LN4@ToStringX_:

; 443  :     }
; 444  :     if (count & 0x8)

	mov	edx, DWORD PTR _count$[ebp]
	and	edx, 8
	je	$LN5@ToStringX_

; 445  :     {
; 446  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 447  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [edx+ecx], ax

; 448  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [ecx+eax], dx

; 449  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 3
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 450  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	shl	ecx, 2
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [edx+ecx], ax

; 451  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 5
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 452  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 6
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 453  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 454  :         ptr+=8;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _ptr$[ebp], ecx
$LN5@ToStringX_:

; 455  :     }
; 456  :     if (count & 0x4)

	mov	edx, DWORD PTR _count$[ebp]
	and	edx, 4
	je	$LN6@ToStringX_

; 457  :     {
; 458  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 459  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [edx+ecx], ax

; 460  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [ecx+eax], dx

; 461  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 3
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 462  :         ptr += 4;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 8
	mov	DWORD PTR _ptr$[ebp], edx
$LN6@ToStringX_:

; 463  :     }
; 464  :     if (count & 0x2)

	mov	eax, DWORD PTR _count$[ebp]
	and	eax, 2
	je	SHORT $LN7@ToStringX_

; 465  :     {
; 466  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 467  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [eax+edx], cx

; 468  :         ptr += 2;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _ptr$[ebp], edx
$LN7@ToStringX_:

; 469  :     }
; 470  :     if (count & 0x1)

	mov	eax, DWORD PTR _count$[ebp]
	and	eax, 1
	je	SHORT $LN8@ToStringX_

; 471  :     {
; 472  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 473  :         ptr += 1;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _ptr$[ebp], eax
$LN8@ToStringX_:

; 474  :     }
; 475  :     return (ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
$LN1@ToStringX_:

; 476  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ToStringX_1WORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
tv170 = -100						; size = 4
_rev_str_buf_count$1 = -92				; size = 4
_rev_str_buf$2 = -84					; size = 4
_rev_str_buf_words$3 = -76				; size = 4
_rev_str_buf_code$4 = -64				; size = 4
_r_buf_count$5 = -52					; size = 4
_r_buf$6 = -44						; size = 4
_r_buf_words$7 = -36					; size = 4
_r_buf_code$8 = -24					; size = 4
_result$9 = -16						; size = 4
_decimal_separator_len$10 = -12				; size = 4
_word_digit_count$ = -8					; size = 4
_base_value$ = -4					; size = 4
_x$ = 8							; size = 4
_buffer$ = 12						; size = 4
_buffer_size$ = 16					; size = 4
_format$ = 20						; size = 1
_width$ = 24						; size = 4
_format_option$ = 28					; size = 4
_ToStringDN PROC

; 318  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 25					; 00000019H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 319  :     __UNIT_TYPE_DIV base_value;
; 320  :     int word_digit_count;
; 321  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@ToStringDN

; 322  :     {
; 323  :         base_value = 1000000000U; // 10^9

	mov	DWORD PTR _base_value$[ebp], 1000000000	; 3b9aca00H

; 324  :         word_digit_count = 9;

	mov	DWORD PTR _word_digit_count$[ebp], 9

; 325  :     }

	jmp	SHORT $LN3@ToStringDN
$LN2@ToStringDN:

; 326  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	ecx, ecx
	je	SHORT $LN4@ToStringDN

; 327  :     {
; 328  :         base_value = (__UNIT_TYPE_DIV)10000000000000000000UL; // 10^19

	mov	DWORD PTR _base_value$[ebp], -1981284352 ; 89e80000H

; 329  :         word_digit_count = 19;

	mov	DWORD PTR _word_digit_count$[ebp], 19	; 00000013H

; 330  :     }

	jmp	SHORT $LN3@ToStringDN
$LN4@ToStringDN:

; 331  :     else
; 332  :         return (PMC_STATUS_NOT_SUPPORTED);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@ToStringDN
$LN3@ToStringDN:

; 333  : 
; 334  :     if (x->IS_ZERO)

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+16]
	shr	eax, 1
	and	eax, 1
	je	$LN6@ToStringDN

; 335  :     {
; 336  :         // x が 0 である場合
; 337  :         if (format == 'N')

	movsx	ecx, BYTE PTR _format$[ebp]
	cmp	ecx, 78					; 0000004eH
	jne	$LN8@ToStringDN

; 338  :         {
; 339  :             // format が 'N' である場合
; 340  : 
; 341  :             // 整数部が 1 桁の 0、小数部が width 桁の 0 である文字列を出力する。
; 342  :             buffer[0] = '0';

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [edx+eax], cx

; 343  :             if (width == 0)

	cmp	DWORD PTR _width$[ebp], 0
	jne	SHORT $LN10@ToStringDN

; 344  :                 buffer[1] = L'\0';

	mov	eax, 2
	shl	eax, 0
	xor	ecx, ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [edx+eax], cx
	jmp	SHORT $LN11@ToStringDN
$LN10@ToStringDN:

; 345  :             else
; 346  :             {
; 347  :                 lstrcpyW(&buffer[1], format_option->DecimalSeparator);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 10					; 0000000aH
	mov	esi, esp
	push	eax
	mov	ecx, 2
	shl	ecx, 0
	add	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 348  :                 int decimal_separator_len = lstrlenW(format_option->DecimalSeparator);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 10					; 0000000aH
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _decimal_separator_len$10[ebp], eax

; 349  :                 _FILL_MEMORY_16(buffer + 1 + decimal_separator_len, L'0', width);

	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _decimal_separator_len$10[ebp]
	mov	edx, DWORD PTR _buffer$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2+2]
	push	eax
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 350  :                 buffer[1 + decimal_separator_len + width] = L'\0';

	mov	ecx, DWORD PTR _width$[ebp]
	mov	edx, DWORD PTR _decimal_separator_len$10[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	xor	ecx, ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [edx+eax*2], cx
$LN11@ToStringDN:

; 351  :             }
; 352  :         }

	jmp	SHORT $LN9@ToStringDN
$LN8@ToStringDN:

; 353  :         else
; 354  :         {
; 355  :             // format が 'D' である場合
; 356  : 
; 357  :             // 最低で 1 桁、最高で width 桁だけ '0' を出力する。
; 358  :             if (width < 1)

	cmp	DWORD PTR _width$[ebp], 1
	jae	SHORT $LN12@ToStringDN

; 359  :                 width = 1;

	mov	DWORD PTR _width$[ebp], 1
$LN12@ToStringDN:

; 360  :             if (buffer_size < width + 1)

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 1
	cmp	DWORD PTR _buffer_size$[ebp], eax
	jae	SHORT $LN13@ToStringDN

; 361  :                 return (PMC_STATUS_INSUFFICIENT_BUFFER);

	mov	eax, -4					; fffffffcH
	jmp	$LN1@ToStringDN
$LN13@ToStringDN:

; 362  :             _FILL_MEMORY_16(buffer, L'0', width);

	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	push	48					; 00000030H
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 363  :             buffer[width] = L'\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _width$[ebp]
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$LN9@ToStringDN:

; 364  :         }
; 365  :     }

	jmp	$LN7@ToStringDN
$LN6@ToStringDN:

; 366  :     else
; 367  :     {
; 368  :         // x が 0 ではない場合
; 369  :         PMC_STATUS_CODE result;
; 370  :         __UNIT_TYPE r_buf_code;
; 371  :         __UNIT_TYPE r_buf_words;
; 372  :         // xを base_value 基数として変換した数値が r に格納される。約 7% ほど余分に領域が必要な計算になるが、余裕を見て 12.5% 程度の領域を獲得している。
; 373  :         __UNIT_TYPE_DIV* r_buf = (__UNIT_TYPE_DIV*)AllocateBlock(x->UNIT_BIT_COUNT + (x->UNIT_BIT_COUNT >> 3) + __UNIT_TYPE_BIT_COUNT, &r_buf_words, &r_buf_code);

	lea	eax, DWORD PTR _r_buf_code$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _r_buf_words$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 3
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+32]
	push	eax
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _r_buf$6[ebp], eax

; 374  :         if (r_buf == NULL)

	cmp	DWORD PTR _r_buf$6[ebp], 0
	jne	SHORT $LN14@ToStringDN

; 375  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ToStringDN
$LN14@ToStringDN:

; 376  :         __UNIT_TYPE r_buf_count;
; 377  :         if ((result = ConvertCardinalNumber((__UNIT_TYPE_DIV*)x->BLOCK, x->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), x->UNIT_BIT_COUNT, base_value, r_buf, &r_buf_count)) != PMC_STATUS_OK)

	lea	ecx, DWORD PTR _r_buf_count$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _r_buf$6[ebp]
	push	edx
	mov	eax, DWORD PTR _base_value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 2
	shr	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_ConvertCardinalNumber
	add	esp, 24					; 00000018H
	mov	DWORD PTR _result$9[ebp], eax
	cmp	DWORD PTR _result$9[ebp], 0
	je	SHORT $LN15@ToStringDN

; 378  :         {
; 379  :             DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	ecx, DWORD PTR _r_buf_words$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _r_buf$6[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8

; 380  :             return (result);

	mov	eax, DWORD PTR _result$9[ebp]
	jmp	$LN1@ToStringDN
$LN15@ToStringDN:

; 381  :         }
; 382  :         if ((result = CheckBlockLight((__UNIT_TYPE*)r_buf, r_buf_code)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _r_buf_code$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _r_buf$6[ebp]
	push	ecx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$9[ebp], eax
	cmp	DWORD PTR _result$9[ebp], 0
	je	SHORT $LN16@ToStringDN

; 383  :             return (result);

	mov	eax, DWORD PTR _result$9[ebp]
	jmp	$LN1@ToStringDN
$LN16@ToStringDN:

; 384  : 
; 385  :         __UNIT_TYPE rev_str_buf_code;
; 386  :         __UNIT_TYPE rev_str_buf_words;
; 387  :         // 獲得領域長の * 2 は、桁区切りのワーストケースにより文字列が膨らんだ場合を考慮したもの。
; 388  :         wchar_t* rev_str_buf = (wchar_t*)AllocateBlock((max(r_buf_count * word_digit_count, width) * 2 + width + 2) * sizeof(wchar_t) * 8, &rev_str_buf_words, &rev_str_buf_code);

	mov	edx, DWORD PTR _r_buf_count$5[ebp]
	imul	edx, DWORD PTR _word_digit_count$[ebp]
	cmp	edx, DWORD PTR _width$[ebp]
	jbe	SHORT $LN21@ToStringDN
	mov	eax, DWORD PTR _r_buf_count$5[ebp]
	imul	eax, DWORD PTR _word_digit_count$[ebp]
	mov	DWORD PTR tv170[ebp], eax
	jmp	SHORT $LN22@ToStringDN
$LN21@ToStringDN:
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv170[ebp], ecx
$LN22@ToStringDN:
	lea	edx, DWORD PTR _rev_str_buf_code$4[ebp]
	push	edx
	lea	eax, DWORD PTR _rev_str_buf_words$3[ebp]
	push	eax
	mov	ecx, DWORD PTR tv170[ebp]
	mov	edx, DWORD PTR _width$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	lea	ecx, DWORD PTR [eax+eax+4]
	shl	ecx, 3
	push	ecx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _rev_str_buf$2[ebp], eax

; 389  :         if (r_buf == NULL)

	cmp	DWORD PTR _r_buf$6[ebp], 0
	jne	SHORT $LN17@ToStringDN

; 390  :         {
; 391  :             DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	edx, DWORD PTR _r_buf_words$7[ebp]
	push	edx
	mov	eax, DWORD PTR _r_buf$6[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 392  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ToStringDN
$LN17@ToStringDN:

; 393  :         }
; 394  :         __UNIT_TYPE rev_str_buf_count;
; 395  :         PrintDecimal(r_buf, r_buf_count, rev_str_buf, &rev_str_buf_count, format, width, format_option);

	mov	ecx, DWORD PTR _format_option$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	movzx	eax, BYTE PTR _format$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rev_str_buf_count$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf$2[ebp]
	push	edx
	mov	eax, DWORD PTR _r_buf_count$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _r_buf$6[ebp]
	push	ecx
	call	_PrintDecimal
	add	esp, 28					; 0000001cH

; 396  :         if ((result = CheckBlockLight((__UNIT_TYPE*)rev_str_buf, rev_str_buf_code)) != PMC_STATUS_OK)

	mov	edx, DWORD PTR _rev_str_buf_code$4[ebp]
	push	edx
	mov	eax, DWORD PTR _rev_str_buf$2[ebp]
	push	eax
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$9[ebp], eax
	cmp	DWORD PTR _result$9[ebp], 0
	je	SHORT $LN18@ToStringDN

; 397  :             return (result);

	mov	eax, DWORD PTR _result$9[ebp]
	jmp	SHORT $LN1@ToStringDN
$LN18@ToStringDN:

; 398  :         DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	ecx, DWORD PTR _r_buf_words$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _r_buf$6[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8

; 399  :         if (rev_str_buf_count + 1 > buffer_size)

	mov	eax, DWORD PTR _rev_str_buf_count$1[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _buffer_size$[ebp]
	jbe	SHORT $LN19@ToStringDN

; 400  :         {
; 401  :             DeallocateBlock((__UNIT_TYPE*)rev_str_buf, rev_str_buf_words);

	mov	ecx, DWORD PTR _rev_str_buf_words$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf$2[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8

; 402  :             return (PMC_STATUS_INSUFFICIENT_BUFFER);

	mov	eax, -4					; fffffffcH
	jmp	SHORT $LN1@ToStringDN
$LN19@ToStringDN:

; 403  :         }
; 404  :         ToStringDN_Finalize(rev_str_buf, rev_str_buf_count, buffer, buffer_size);

	mov	eax, DWORD PTR _buffer_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf_count$1[ebp]
	push	edx
	mov	eax, DWORD PTR _rev_str_buf$2[ebp]
	push	eax
	call	_ToStringDN_Finalize
	add	esp, 16					; 00000010H

; 405  :         DeallocateBlock((__UNIT_TYPE*)rev_str_buf, rev_str_buf_words);

	mov	ecx, DWORD PTR _rev_str_buf_words$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf$2[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8
$LN7@ToStringDN:

; 406  :     }
; 407  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringDN:

; 408  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@ToStringDN
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 100				; 00000064H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN30@ToStringDN:
	DD	6
	DD	$LN29@ToStringDN
$LN29@ToStringDN:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN23@ToStringDN
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN24@ToStringDN
	DD	-52					; ffffffccH
	DD	4
	DD	$LN25@ToStringDN
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN26@ToStringDN
	DD	-76					; ffffffb4H
	DD	4
	DD	$LN27@ToStringDN
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN28@ToStringDN
$LN28@ToStringDN:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN27@ToStringDN:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN26@ToStringDN:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN25@ToStringDN:
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN24@ToStringDN:
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN23@ToStringDN:
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_ToStringDN ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
_count$ = -12						; size = 4
_out_ptr$ = -8						; size = 4
_in_ptr$ = -4						; size = 4
_in_buf$ = 8						; size = 4
_in_buf_count$ = 12					; size = 4
_out_buf$ = 16						; size = 4
_out_buf_count$ = 20					; size = 4
_ToStringDN_Finalize PROC

; 305  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 306  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	eax, DWORD PTR _in_buf_count$[ebp]
	mov	ecx, DWORD PTR _in_buf$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2-2]
	mov	DWORD PTR _in_ptr$[ebp], edx

; 307  :     wchar_t* out_ptr = out_buf;

	mov	eax, DWORD PTR _out_buf$[ebp]
	mov	DWORD PTR _out_ptr$[ebp], eax

; 308  :     __UNIT_TYPE count = in_buf_count;

	mov	ecx, DWORD PTR _in_buf_count$[ebp]
	mov	DWORD PTR _count$[ebp], ecx
$LN2@ToStringDN:

; 309  :     while (count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jbe	SHORT $LN3@ToStringDN

; 310  :     {
; 311  :         *out_ptr++ = *in_ptr--;

	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _out_ptr$[ebp], edx
	mov	eax, DWORD PTR _in_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _in_ptr$[ebp], eax

; 312  :         --count;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 313  :     }

	jmp	SHORT $LN2@ToStringDN
$LN3@ToStringDN:

; 314  :     *out_ptr = L'\0';

	xor	edx, edx
	mov	eax, DWORD PTR _out_ptr$[ebp]
	mov	WORD PTR [eax], dx

; 315  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ToStringDN_Finalize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
_count$1 = -76						; size = 4
_in_count$ = -72					; size = 4
_in_ptr$ = -68						; size = 4
_count$2 = -64						; size = 4
_state$ = -56						; size = 48
__$ArrayPad$ = -4					; size = 4
_in_buf$ = 8						; size = 4
_in_buf_count$ = 12					; size = 4
_out_buf$ = 16						; size = 4
_out_buf_count$ = 20					; size = 4
_format$ = 24						; size = 1
_width$ = 28						; size = 4
_format_option$ = 32					; size = 4
_PrintDecimal PROC

; 263  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	edi
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 264  :     struct TOSTRINGN_OUTPUT_STATE state;
; 265  :     InitializeOutputState(&state, out_buf, format, format_option);

	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out_buf$[ebp]
	push	edx
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_InitializeOutputState
	add	esp, 16					; 00000010H

; 266  :     if (format == 'N' && width > 0)

	movsx	ecx, BYTE PTR _format$[ebp]
	cmp	ecx, 78					; 0000004eH
	jne	SHORT $LN8@PrintDecim
	cmp	DWORD PTR _width$[ebp], 0
	jbe	SHORT $LN8@PrintDecim

; 267  :     {
; 268  :         _UINT32_T count = width;

	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _count$2[ebp], edx
$LN2@PrintDecim:

; 269  :         while (count > 0)

	cmp	DWORD PTR _count$2[ebp], 0
	jbe	SHORT $LN3@PrintDecim

; 270  :         {
; 271  :             OutputUngroupedOneChar(&state, 0);

	push	0
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputUngroupedOneChar
	add	esp, 8

; 272  :             --count;

	mov	ecx, DWORD PTR _count$2[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$2[ebp], ecx

; 273  :         }

	jmp	SHORT $LN2@PrintDecim
$LN3@PrintDecim:

; 274  :         OutputDecimalSeparator(&state);

	lea	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputDecimalSeparator
	add	esp, 4
$LN8@PrintDecim:

; 275  :     }
; 276  :     __UNIT_TYPE_DIV* in_ptr = in_buf;

	mov	eax, DWORD PTR _in_buf$[ebp]
	mov	DWORD PTR _in_ptr$[ebp], eax

; 277  :     __UNIT_TYPE in_count = in_buf_count - 1;

	mov	ecx, DWORD PTR _in_buf_count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _in_count$[ebp], ecx
$LN4@PrintDecim:

; 278  :     while (in_count != 0)

	cmp	DWORD PTR _in_count$[ebp], 0
	je	SHORT $LN5@PrintDecim

; 279  :     {
; 280  :         ToStringDN_1WORD(&state, *in_ptr);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_ToStringDN_1WORD
	add	esp, 8

; 281  :         ++in_ptr;

	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _in_ptr$[ebp], edx

; 282  :         --in_count;

	mov	eax, DWORD PTR _in_count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _in_count$[ebp], eax

; 283  :     }

	jmp	SHORT $LN4@PrintDecim
$LN5@PrintDecim:

; 284  :     ToStringDN_LEADING_1WORD(&state, *in_ptr);

	mov	ecx, DWORD PTR _in_ptr$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ToStringDN_LEADING_1WORD
	add	esp, 8

; 285  :     ++in_ptr;

	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 4
	mov	DWORD PTR _in_ptr$[ebp], ecx

; 286  :     --in_count;

	mov	edx, DWORD PTR _in_count$[ebp]
	sub	edx, 1
	mov	DWORD PTR _in_count$[ebp], edx

; 287  :     if (format == 'D')

	movsx	eax, BYTE PTR _format$[ebp]
	cmp	eax, 68					; 00000044H
	jne	SHORT $LN9@PrintDecim

; 288  :     {
; 289  :         if (state.OUT_PTR < out_buf + width)

	mov	ecx, DWORD PTR _width$[ebp]
	mov	edx, DWORD PTR _out_buf$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	cmp	DWORD PTR _state$[ebp+44], eax
	jae	SHORT $LN9@PrintDecim

; 290  :         {
; 291  :             int count = width - (int)(state.OUT_PTR - out_buf);

	mov	ecx, DWORD PTR _state$[ebp+44]
	sub	ecx, DWORD PTR _out_buf$[ebp]
	sar	ecx, 1
	mov	edx, DWORD PTR _width$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _count$1[ebp], edx
$LN6@PrintDecim:

; 292  :             while (count > 0)

	cmp	DWORD PTR _count$1[ebp], 0
	jle	SHORT $LN9@PrintDecim

; 293  :             {
; 294  :                 OutputOneChar(&state, 0);

	push	0
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputOneChar
	add	esp, 8

; 295  :                 --count;

	mov	ecx, DWORD PTR _count$1[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$1[ebp], ecx

; 296  :             }

	jmp	SHORT $LN6@PrintDecim
$LN9@PrintDecim:

; 297  :         }
; 298  :     }
; 299  :     *out_buf_count = state.OUT_PTR - out_buf;

	mov	edx, DWORD PTR _state$[ebp+44]
	sub	edx, DWORD PTR _out_buf$[ebp]
	sar	edx, 1
	mov	eax, DWORD PTR _out_buf_count$[ebp]
	mov	DWORD PTR [eax], edx

; 300  :     *state.OUT_PTR = '\0';

	xor	ecx, ecx
	mov	edx, DWORD PTR _state$[ebp+44]
	mov	WORD PTR [edx], cx

; 301  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@PrintDecim
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN14@PrintDecim:
	DD	1
	DD	$LN13@PrintDecim
$LN13@PrintDecim:
	DD	-56					; ffffffc8H
	DD	48					; 00000030H
	DD	$LN12@PrintDecim
$LN12@PrintDecim:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
_PrintDecimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
_r$ = -8						; size = 4
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_ToStringDN_1WORD PROC

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 204  :     __UNIT_TYPE_DIV r;
; 205  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_UINT64_T))

	xor	eax, eax
	je	$LN2@ToStringDN

; 206  :     {
; 207  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputOneChar
	add	esp, 8

; 208  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputOneChar
	add	esp, 8

; 209  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputOneChar
	add	esp, 8

; 210  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputOneChar
	add	esp, 8

; 211  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputOneChar
	add	esp, 8

; 212  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputOneChar
	add	esp, 8

; 213  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputOneChar
	add	esp, 8

; 214  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputOneChar
	add	esp, 8

; 215  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputOneChar
	add	esp, 8

; 216  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputOneChar
	add	esp, 8

; 217  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 218  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	edx, edx
	je	SHORT $LN3@ToStringDN

; 219  :             AddToDIV64Counter(10);

	push	10					; 0000000aH
	call	_AddToDIV64Counter
	add	esp, 4
	jmp	SHORT $LN2@ToStringDN
$LN3@ToStringDN:

; 220  :         else
; 221  :             AddToDIV32Counter(10);

	push	10					; 0000000aH
	call	_AddToDIV32Counter
	add	esp, 4
$LN2@ToStringDN:

; 222  : #endif
; 223  :     }
; 224  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	$LN5@ToStringDN

; 225  :     {
; 226  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputOneChar
	add	esp, 8

; 227  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputOneChar
	add	esp, 8

; 228  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputOneChar
	add	esp, 8

; 229  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputOneChar
	add	esp, 8

; 230  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputOneChar
	add	esp, 8

; 231  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 232  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	je	SHORT $LN6@ToStringDN

; 233  :             AddToDIV64Counter(5);

	push	5
	call	_AddToDIV64Counter
	add	esp, 4
	jmp	SHORT $LN5@ToStringDN
$LN6@ToStringDN:

; 234  :         else
; 235  :             AddToDIV32Counter(5);

	push	5
	call	_AddToDIV32Counter
	add	esp, 4
$LN5@ToStringDN:

; 236  : #endif
; 237  :     }
; 238  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_UINT16_T))

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN8@ToStringDN

; 239  :     {
; 240  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputOneChar
	add	esp, 8

; 241  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputOneChar
	add	esp, 8

; 242  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 243  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	ecx, ecx
	je	SHORT $LN9@ToStringDN

; 244  :             AddToDIV64Counter(2);

	push	2
	call	_AddToDIV64Counter
	add	esp, 4
	jmp	SHORT $LN8@ToStringDN
$LN9@ToStringDN:

; 245  :         else
; 246  :             AddToDIV32Counter(2);

	push	2
	call	_AddToDIV32Counter
	add	esp, 4
$LN8@ToStringDN:

; 247  : #endif
; 248  :     }
; 249  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_BYTE_T))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN1@ToStringDN

; 250  :     {
; 251  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputOneChar
	add	esp, 8

; 252  :         OutputOneChar(state, x);

	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputOneChar
	add	esp, 8

; 253  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 254  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	je	SHORT $LN12@ToStringDN

; 255  :             IncrementDIV64Counter();

	call	_IncrementDIV64Counter
	jmp	SHORT $LN1@ToStringDN
$LN12@ToStringDN:

; 256  :         else
; 257  :             IncrementDIV32Counter();

	call	_IncrementDIV32Counter
$LN1@ToStringDN:

; 258  : #endif
; 259  :     }
; 260  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@ToStringDN
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@ToStringDN:
	DD	1
	DD	$LN16@ToStringDN
$LN16@ToStringDN:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN15@ToStringDN
$LN15@ToStringDN:
	DB	114					; 00000072H
	DB	0
_ToStringDN_1WORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
_r$ = -8						; size = 4
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_ToStringDN_LEADING_1WORD PROC

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4
$LN4@ToStringDN:

; 187  :     __UNIT_TYPE_DIV r;
; 188  :     do
; 189  :     {
; 190  :         x = _DIVREM_UNIT(0, x, 10, &r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax

; 191  :         OutputOneChar(state, r);

	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputOneChar
	add	esp, 8

; 192  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 193  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	ecx, ecx
	je	SHORT $LN5@ToStringDN

; 194  :             IncrementDIV64Counter();

	call	_IncrementDIV64Counter
	jmp	SHORT $LN2@ToStringDN
$LN5@ToStringDN:

; 195  :         else
; 196  :             IncrementDIV32Counter();

	call	_IncrementDIV32Counter
$LN2@ToStringDN:

; 197  : #endif
; 198  :     } while (x != 0);

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN4@ToStringDN

; 199  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@ToStringDN
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@ToStringDN:
	DD	1
	DD	$LN9@ToStringDN
$LN9@ToStringDN:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN8@ToStringDN
$LN8@ToStringDN:
	DB	114					; 00000072H
	DB	0
_ToStringDN_LEADING_1WORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_OutputOneChar PROC

; 145  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 146  :     if (state->FORMAT == 'N')

	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 78					; 0000004eH
	jne	$LN2@OutputOneC

; 147  :     {
; 148  :         // 書式が N である場合
; 149  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jle	$LN4@OutputOneC
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [eax+40]
	cmp	edx, DWORD PTR [ecx+36]
	jl	$LN4@OutputOneC

; 150  :         {
; 151  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 152  : 
; 153  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 154  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 155  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+44]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+44], ecx

; 156  :             *state->OUT_PTR = decimal_digits[x];

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _x$[ebp]
	mov	ax, WORD PTR _decimal_digits[edx*2]
	mov	WORD PTR [ecx], ax

; 157  :             state->OUT_PTR += 1;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	add	edx, 2
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+44], edx

; 158  :             state->CURRENT_GROUP_INDEX = 1;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+40], 1

; 159  : 
; 160  :             // 次のグループが存在すればそのグループに移行する
; 161  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	movsx	edx, BYTE PTR [ecx+edx]
	test	edx, edx
	je	SHORT $LN6@OutputOneC

; 162  :             {
; 163  :                 state->CURRENT_GROUP += 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 164  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	movsx	edx, BYTE PTR [ecx]
	sub	edx, 48					; 00000030H
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN6@OutputOneC:

; 165  :             }
; 166  :         }

	jmp	SHORT $LN5@OutputOneC
$LN4@OutputOneC:

; 167  :         else
; 168  :         {
; 169  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 170  :             *state->OUT_PTR = decimal_digits[x];

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _x$[ebp]
	mov	cx, WORD PTR _decimal_digits[eax*2]
	mov	WORD PTR [edx], cx

; 171  :             state->OUT_PTR += 1;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+44]
	add	eax, 2
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 172  :             state->CURRENT_GROUP_INDEX += 1;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+40]
	add	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+40], eax
$LN5@OutputOneC:

; 173  :         }
; 174  :     }

	jmp	SHORT $LN1@OutputOneC
$LN2@OutputOneC:

; 175  :     else
; 176  :     {
; 177  :         // 書式が N ではない (つまり D である) 場合
; 178  :         
; 179  :         *state->OUT_PTR = decimal_digits[x];

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _x$[ebp]
	mov	dx, WORD PTR _decimal_digits[ecx*2]
	mov	WORD PTR [eax], dx

; 180  :         state->OUT_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	add	ecx, 2
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+44], ecx
$LN1@OutputOneC:

; 181  :     }
; 182  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_OutputOneChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_OutputUngroupedOneChar PROC

; 139  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 140  :     *state->OUT_PTR = decimal_digits[x];

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _x$[ebp]
	mov	ax, WORD PTR _decimal_digits[edx*2]
	mov	WORD PTR [ecx], ax

; 141  :     state->OUT_PTR += 1;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	add	edx, 2
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+44], edx

; 142  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_OutputUngroupedOneChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
_state$ = 8						; size = 4
_OutputDecimalSeparator PROC

; 133  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 134  :     lstrcpyW(state->OUT_PTR, state->DECIMAL_SEPARATOR);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 12					; 0000000cH
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 135  :     state->OUT_PTR += state->DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+44]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+44], ecx

; 136  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_OutputDecimalSeparator ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
_out_ptr$ = -8						; size = 4
_in_ptr$ = -4						; size = 4
_state$ = 8						; size = 4
_out_buf$ = 12						; size = 4
_format$ = 16						; size = 1
_format_option$ = 20					; size = 4
_InitializeOutputState PROC

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 102  :     state->FORMAT = format;

	mov	eax, DWORD PTR _state$[ebp]
	mov	cl, BYTE PTR _format$[ebp]
	mov	BYTE PTR [eax], cl

; 103  : 
; 104  :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(format_option->GroupSeparator);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 4
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 105  :     wchar_t* in_ptr = format_option->GroupSeparator;

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 4
	mov	DWORD PTR _in_ptr$[ebp], edx

; 106  :     wchar_t* out_ptr = state->GROUP_SEPARATOR + state->GROUP_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2+2]
	mov	DWORD PTR _out_ptr$[ebp], eax

; 107  :     *out_ptr-- = '\0';

	xor	ecx, ecx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _out_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN2@Initialize:

; 108  :     while (*in_ptr != L'\0')

	mov	ecx, DWORD PTR _in_ptr$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@Initialize

; 109  :     {
; 110  :         *out_ptr = *in_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx

; 111  :         --out_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax

; 112  :         ++in_ptr;

	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx

; 113  :     }

	jmp	SHORT $LN2@Initialize
$LN3@Initialize:

; 114  : 
; 115  :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(format_option->DecimalSeparator);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 10					; 0000000aH
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 116  :     in_ptr = format_option->DecimalSeparator;

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 10					; 0000000aH
	mov	DWORD PTR _in_ptr$[ebp], edx

; 117  :     out_ptr = state->DECIMAL_SEPARATOR + state->DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2+12]
	mov	DWORD PTR _out_ptr$[ebp], eax

; 118  :     *out_ptr-- = '\0';

	xor	ecx, ecx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _out_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN4@Initialize:

; 119  :     while (*in_ptr != L'\0')

	mov	ecx, DWORD PTR _in_ptr$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN5@Initialize

; 120  :     {
; 121  :         *out_ptr = *in_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx

; 122  :         --out_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax

; 123  :         ++in_ptr;

	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx

; 124  :     }

	jmp	SHORT $LN4@Initialize
$LN5@Initialize:

; 125  : 
; 126  :     state->CURRENT_GROUP = &format_option->GroupSizes[0];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _format_option$[ebp]
	lea	edx, DWORD PTR [ecx+eax+28]
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+32], edx

; 127  :     state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	movsx	eax, BYTE PTR [edx]
	sub	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 128  :     state->CURRENT_GROUP_INDEX = 0;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+40], 0

; 129  :     state->OUT_PTR = out_buf;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _out_buf$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 130  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_InitializeOutputState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
_temp$1 = -92						; size = 4
_r_value$2 = -84					; size = 4
_work_u_count$ = -76					; size = 4
_r_ptr$ = -72						; size = 4
_q_ptr$ = -68						; size = 4
_u_ptr$ = -64						; size = 4
_work_buf_2$ = -60					; size = 4
_work_buf_2_words$ = -52				; size = 4
_work_buf_2_code$ = -40					; size = 4
_work_buf_1$ = -32					; size = 4
_work_buf_1_words$ = -24				; size = 4
_work_buf_1_code$ = -12					; size = 4
_result$ = -4						; size = 4
_x_buf$ = 8						; size = 4
_x_buf_size$ = 12					; size = 4
_x_bit_count$ = 16					; size = 4
_base_value$ = 20					; size = 4
_r_buf$ = 24						; size = 4
_r_buf_count$ = 28					; size = 4
_ConvertCardinalNumber PROC

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	edi
	lea	edi, DWORD PTR [ebp-92]
	mov	ecx, 23					; 00000017H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 59   :     PMC_STATUS_CODE result;
; 60   :     __UNIT_TYPE work_buf_1_code;
; 61   :     __UNIT_TYPE work_buf_1_words;
; 62   :     __UNIT_TYPE_DIV* work_buf_1 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_1_words, &work_buf_1_code);

	lea	eax, DWORD PTR _work_buf_1_code$[ebp]
	push	eax
	lea	ecx, DWORD PTR _work_buf_1_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x_bit_count$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf_1$[ebp], eax

; 63   :     if (work_buf_1 == NULL)

	cmp	DWORD PTR _work_buf_1$[ebp], 0
	jne	SHORT $LN6@ConvertCar

; 64   :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ConvertCar
$LN6@ConvertCar:

; 65   :     __UNIT_TYPE work_buf_2_code;
; 66   :     __UNIT_TYPE work_buf_2_words;
; 67   :     __UNIT_TYPE_DIV* work_buf_2 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_2_words, &work_buf_2_code);

	lea	eax, DWORD PTR _work_buf_2_code$[ebp]
	push	eax
	lea	ecx, DWORD PTR _work_buf_2_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x_bit_count$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf_2$[ebp], eax

; 68   :     if (work_buf_2 == NULL)

	cmp	DWORD PTR _work_buf_2$[ebp], 0
	jne	SHORT $LN7@ConvertCar

; 69   :     {
; 70   :         DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	mov	eax, DWORD PTR _work_buf_1_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _work_buf_1$[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 71   :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ConvertCar
$LN7@ConvertCar:

; 72   :     }
; 73   :     __UNIT_TYPE_DIV* u_ptr = work_buf_1;

	mov	edx, DWORD PTR _work_buf_1$[ebp]
	mov	DWORD PTR _u_ptr$[ebp], edx

; 74   :     __UNIT_TYPE_DIV* q_ptr = work_buf_2;

	mov	eax, DWORD PTR _work_buf_2$[ebp]
	mov	DWORD PTR _q_ptr$[ebp], eax

; 75   :     _COPY_MEMORY_UNIT_DIV(u_ptr, x_buf, x_buf_size);

	mov	ecx, DWORD PTR _x_buf_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x_buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _u_ptr$[ebp]
	push	eax
	call	__COPY_MEMORY_UNIT_DIV
	add	esp, 12					; 0000000cH

; 76   :     __UNIT_TYPE_DIV* r_ptr = r_buf;

	mov	ecx, DWORD PTR _r_buf$[ebp]
	mov	DWORD PTR _r_ptr$[ebp], ecx

; 77   :     __UNIT_TYPE work_u_count = work_buf_1_words * (sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV));

	mov	edx, DWORD PTR _work_buf_1_words$[ebp]
	mov	DWORD PTR _work_u_count$[ebp], edx
$LN2@ConvertCar:

; 78   :     while (work_u_count > 0)

	cmp	DWORD PTR _work_u_count$[ebp], 0
	jbe	$LN3@ConvertCar

; 79   :     {
; 80   :         _ZERO_MEMORY_UNIT_DIV(q_ptr, work_u_count);

	mov	eax, DWORD PTR _work_u_count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q_ptr$[ebp]
	push	ecx
	call	__ZERO_MEMORY_UNIT_DIV
	add	esp, 8

; 81   :         __UNIT_TYPE_DIV r_value;
; 82   :         DivRem_X_1W(u_ptr, work_u_count, base_value, q_ptr, &r_value);

	lea	edx, DWORD PTR _r_value$2[ebp]
	push	edx
	mov	eax, DWORD PTR _q_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _base_value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _work_u_count$[ebp]
	push	edx
	mov	eax, DWORD PTR _u_ptr$[ebp]
	push	eax
	call	_DivRem_X_1W
	add	esp, 20					; 00000014H

; 83   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_2, work_buf_2_code)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _work_buf_2_code$[ebp]
	push	ecx
	mov	edx, DWORD PTR _work_buf_2$[ebp]
	push	edx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN8@ConvertCar

; 84   :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ConvertCar
$LN8@ConvertCar:

; 85   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_1, work_buf_1_code)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _work_buf_1_code$[ebp]
	push	eax
	mov	ecx, DWORD PTR _work_buf_1$[ebp]
	push	ecx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN9@ConvertCar

; 86   :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@ConvertCar
$LN9@ConvertCar:

; 87   :         *r_ptr++ = r_value;

	mov	edx, DWORD PTR _r_ptr$[ebp]
	mov	eax, DWORD PTR _r_value$2[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _r_ptr$[ebp]
	add	ecx, 4
	mov	DWORD PTR _r_ptr$[ebp], ecx

; 88   :         __UNIT_TYPE_DIV* temp = u_ptr;

	mov	edx, DWORD PTR _u_ptr$[ebp]
	mov	DWORD PTR _temp$1[ebp], edx

; 89   :         u_ptr = q_ptr;

	mov	eax, DWORD PTR _q_ptr$[ebp]
	mov	DWORD PTR _u_ptr$[ebp], eax

; 90   :         q_ptr = temp;

	mov	ecx, DWORD PTR _temp$1[ebp]
	mov	DWORD PTR _q_ptr$[ebp], ecx
$LN4@ConvertCar:

; 91   :         while (work_u_count > 0 && u_ptr[work_u_count - 1] == 0)

	cmp	DWORD PTR _work_u_count$[ebp], 0
	jbe	SHORT $LN5@ConvertCar
	mov	edx, DWORD PTR _work_u_count$[ebp]
	mov	eax, DWORD PTR _u_ptr$[ebp]
	cmp	DWORD PTR [eax+edx*4-4], 0
	jne	SHORT $LN5@ConvertCar

; 92   :             --work_u_count;

	mov	ecx, DWORD PTR _work_u_count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _work_u_count$[ebp], ecx
	jmp	SHORT $LN4@ConvertCar
$LN5@ConvertCar:

; 93   :     }

	jmp	$LN2@ConvertCar
$LN3@ConvertCar:

; 94   :     *r_buf_count = r_ptr - r_buf;

	mov	edx, DWORD PTR _r_ptr$[ebp]
	sub	edx, DWORD PTR _r_buf$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR _r_buf_count$[ebp]
	mov	DWORD PTR [eax], edx

; 95   :     DeallocateBlock((__UNIT_TYPE*)work_buf_2, work_buf_2_words);

	mov	ecx, DWORD PTR _work_buf_2_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _work_buf_2$[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8

; 96   :     DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	mov	eax, DWORD PTR _work_buf_1_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _work_buf_1$[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 97   :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ConvertCar:

; 98   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@ConvertCar
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 92					; 0000005cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@ConvertCar:
	DD	5
	DD	$LN16@ConvertCar
$LN16@ConvertCar:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN11@ConvertCar
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN12@ConvertCar
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN13@ConvertCar
	DD	-52					; ffffffccH
	DD	4
	DD	$LN14@ConvertCar
	DD	-84					; ffffffacH
	DD	4
	DD	$LN15@ConvertCar
$LN15@ConvertCar:
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN14@ConvertCar:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	50					; 00000032H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN13@ConvertCar:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	50					; 00000032H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN12@ConvertCar:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN11@ConvertCar:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_ConvertCardinalNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToDIV64Counter PROC

; 1073 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 1074 :     _InterlockedExchangeAdd(&statistics_info.COUNT_DIV64, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info+8
	lock	 xadd	 DWORD PTR [ecx], eax

; 1075 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_AddToDIV64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToDIV32Counter PROC

; 1067 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 1068 :     _InterlockedExchangeAdd(&statistics_info.COUNT_DIV32, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info+12
	lock	 xadd	 DWORD PTR [ecx], eax

; 1069 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_AddToDIV32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_IncrementDIV64Counter PROC

; 1050 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 1051 :     _InterlockedIncrement(&statistics_info.COUNT_DIV64);

	lock	 inc	 (null) PTR _statistics_info+8

; 1052 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_IncrementDIV64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_IncrementDIV32Counter PROC

; 1044 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 1045 :     _InterlockedIncrement(&statistics_info.COUNT_DIV32);

	lock	 inc	 (null) PTR _statistics_info+12

; 1046 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_IncrementDIV32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
_count$ = 12						; size = 4
__ROTATE_L_UNIT PROC

; 740  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 741  : #ifdef _M_IX86
; 742  :     return (_rotl(x, count));

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	rol	eax, cl

; 743  : #elif defined(_M_X64)
; 744  :     return (_rotl64(x, count));
; 745  : #else
; 746  : #error unknown platform
; 747  : #endif
; 748  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__ROTATE_L_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_t$1 = -8						; size = 8
_u_high$ = 8						; size = 4
_u_low$ = 12						; size = 4
_v$ = 16						; size = 4
_r$ = 20						; size = 4
__DIVREM_UNIT PROC

; 643  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 644  : #ifdef _MSC_VER
; 645  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@DIVREM_UNI

; 646  :     {
; 647  :         // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 648  :         _UINT64_T t = _FROMWORDTODWORD(u_high, u_low);

	mov	ecx, DWORD PTR _u_low$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u_high$[ebp]
	push	edx
	call	__FROMWORDTODWORD
	add	esp, 8
	mov	DWORD PTR _t$1[ebp], eax
	mov	DWORD PTR _t$1[ebp+4], edx

; 649  :         *r = (_UINT32_T)(t % v);

	mov	eax, DWORD PTR _v$[ebp]
	xor	ecx, ecx
	push	ecx
	push	eax
	mov	edx, DWORD PTR _t$1[ebp+4]
	push	edx
	mov	eax, DWORD PTR _t$1[ebp]
	push	eax
	call	__aullrem
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx], eax

; 650  :         return ((_UINT32_T)(t / v));

	mov	edx, DWORD PTR _v$[ebp]
	xor	eax, eax
	push	eax
	push	edx
	mov	ecx, DWORD PTR _t$1[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _t$1[ebp]
	push	edx
	call	__aulldiv
	jmp	SHORT $LN1@DIVREM_UNI

; 651  :     }

	jmp	SHORT $LN1@DIVREM_UNI
$LN2@DIVREM_UNI:

; 652  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	eax, eax
	je	SHORT $LN4@DIVREM_UNI

; 653  :     {
; 654  :         // 以下の理由のため、MSVCでは 128bit/64bit の除算を実装できない。運用で回避すること。
; 655  :         // ・(x64 に限らず) 除算の組み込み関数が用意されていない。
; 656  :         // ・128bit 整数のデータ型が用意されていない。
; 657  :         // ・x64 ではインラインアセンブラがサポートされていない。
; 658  :         *r = 0;

	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx], 0

; 659  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@DIVREM_UNI

; 660  :     }

	jmp	SHORT $LN1@DIVREM_UNI
$LN4@DIVREM_UNI:

; 661  :     else
; 662  :     {
; 663  :         // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 664  :         *r = 0;

	mov	edx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx], 0

; 665  :         return (0);

	xor	eax, eax
$LN1@DIVREM_UNI:

; 666  :     }
; 667  : #elif defined(__GNUC__)
; 668  :     __UNIT_TYPE q;
; 669  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 670  :         __asm__("divl %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 671  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 672  :         __asm__("divq %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 673  :     else
; 674  :     {
; 675  :         // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 676  :         *r = 0;
; 677  :         q = 0;
; 678  :     }
; 679  :     return (q);
; 680  : #else
; 681  : #error unknown compiler
; 682  : #endif
; 683  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__DIVREM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
__DIVIDE_CEILING_UNIT PROC

; 452  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 453  :     return ((u + v - 1) / v);

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _u$[ebp]
	lea	eax, DWORD PTR [ecx+eax-1]
	xor	edx, edx
	div	DWORD PTR _v$[ebp]

; 454  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_value_high$ = 8					; size = 4
_value_low$ = 12					; size = 4
__FROMWORDTODWORD PROC

; 436  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 437  :     return (((_UINT64_T)value_high << 32) | value_low);

	xor	edx, edx
	mov	eax, DWORD PTR _value_high$[ebp]
	mov	cl, 32					; 00000020H
	call	__allshl
	xor	ecx, ecx
	or	eax, DWORD PTR _value_low$[ebp]
	or	edx, ecx

; 438  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__FROMWORDTODWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_d$ = 8							; size = 4
_x$ = 12						; size = 2
_count$ = 16						; size = 4
__FILL_MEMORY_16 PROC

; 408  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 409  :     __stosw(d, x, count);

	mov	edi, DWORD PTR _d$[ebp]
	mov	ax, WORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	rep stosw

; 410  : }

	pop	edi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__FILL_MEMORY_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_d$ = 8							; size = 4
_count$ = 12						; size = 4
__ZERO_MEMORY_UNIT_DIV PROC

; 386  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 387  : #ifdef _M_IX86
; 388  :     __stosd((unsigned long*)d, 0, (unsigned long)count);

	mov	edi, DWORD PTR _d$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR _count$[ebp]
	rep stosd

; 389  : #elif defined(_M_X64)
; 390  : #ifdef _MSC_VER
; 391  :     __stosd((unsigned long*)d, 0, (unsigned long)count);
; 392  : #elif defined(__GNUC__)
; 393  :     __stosq(d, 0, count);
; 394  : #else
; 395  : #error unknown compiler
; 396  : #endif
; 397  : #else
; 398  : #error unknown platform
; 399  : #endif
; 400  : }

	pop	edi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__ZERO_MEMORY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
_TEXT	SEGMENT
_d$ = 8							; size = 4
_s$ = 12						; size = 4
_count$ = 16						; size = 4
__COPY_MEMORY_UNIT_DIV PROC

; 336  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __4522B509_pmc_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 337  : #ifdef _M_IX86
; 338  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, DWORD PTR _d$[ebp]
	mov	esi, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	rep movsd

; 339  : #elif defined(_M_X64)
; 340  : #ifdef _MSC_VER
; 341  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 342  : #elif defined(__GNUC__)
; 343  :     __movsq(d, s, count);
; 344  : #else
; 345  : #error unknown compiler
; 346  : #endif
; 347  : #else
; 348  : #error unknown platform
; 349  : #endif
; 350  : }

	pop	edi
	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__COPY_MEMORY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
tv135 = -28						; size = 4
tv95 = -24						; size = 4
tv86 = -20						; size = 4
tv76 = -16						; size = 4
tv71 = -12						; size = 4
_result$ = -8						; size = 4
_nx$ = -4						; size = 4
_x$ = 8							; size = 4
_buffer$ = 12						; size = 4
_buffer_size$ = 16					; size = 4
_format$ = 20						; size = 1
_width$ = 24						; size = 4
_format_option$ = 28					; size = 4
_PMC_ToString@24 PROC

; 532  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 533  :     if (x == NULL)

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN4@PMC_ToStri

; 534  :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
	jmp	$LN1@PMC_ToStri
$LN4@PMC_ToStri:

; 535  :     if (buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN5@PMC_ToStri

; 536  :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
	jmp	$LN1@PMC_ToStri
$LN5@PMC_ToStri:

; 537  :     if (format_option == NULL)

	cmp	DWORD PTR _format_option$[ebp], 0
	jne	SHORT $LN6@PMC_ToStri

; 538  :         format_option = &default_number_format_option;

	mov	DWORD PTR _format_option$[ebp], OFFSET _default_number_format_option
$LN6@PMC_ToStri:

; 539  :     NUMBER_HEADER* nx = (NUMBER_HEADER*)x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _nx$[ebp], eax

; 540  :     PMC_STATUS_CODE result;
; 541  :     if ((result = CheckNumber(nx)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	call	_CheckNumber
	add	esp, 4
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN7@PMC_ToStri

; 542  :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@PMC_ToStri
$LN7@PMC_ToStri:

; 543  :     switch (format)

	movsx	edx, BYTE PTR _format$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	mov	eax, DWORD PTR tv71[ebp]
	sub	eax, 68					; 00000044H
	mov	DWORD PTR tv71[ebp], eax
	cmp	DWORD PTR tv71[ebp], 52			; 00000034H
	ja	$LN12@PMC_ToStri
	mov	ecx, DWORD PTR tv71[ebp]
	movzx	edx, BYTE PTR $LN22@PMC_ToStri[ecx]
	jmp	DWORD PTR $LN23@PMC_ToStri[edx*4]
$LN8@PMC_ToStri:

; 544  :     {
; 545  :     case 'n':
; 546  :     case 'N':
; 547  :         return (ToStringDN(nx, buffer, buffer_size, 'N', width >= 0 ? width : format_option->DecimalDigits, format_option));

	cmp	DWORD PTR _width$[ebp], 0
	jl	SHORT $LN14@PMC_ToStri
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN15@PMC_ToStri
$LN14@PMC_ToStri:
	mov	ecx, DWORD PTR _format_option$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv76[ebp], edx
$LN15@PMC_ToStri:
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv76[ebp]
	push	ecx
	push	78					; 0000004eH
	mov	edx, DWORD PTR _buffer_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	call	_ToStringDN
	add	esp, 24					; 00000018H
	jmp	$LN1@PMC_ToStri
$LN9@PMC_ToStri:

; 548  :     case 'x':
; 549  :         return (ToStringX(nx, buffer, buffer_size, width >= 0 ? width : 0, format_option, 0));

	cmp	DWORD PTR _width$[ebp], 0
	jl	SHORT $LN16@PMC_ToStri
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv86[ebp], edx
	jmp	SHORT $LN17@PMC_ToStri
$LN16@PMC_ToStri:
	mov	DWORD PTR tv86[ebp], 0
$LN17@PMC_ToStri:
	push	0
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv86[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	call	_ToStringX
	add	esp, 24					; 00000018H
	jmp	SHORT $LN1@PMC_ToStri
$LN10@PMC_ToStri:

; 550  :     case 'X':
; 551  :         return (ToStringX(nx, buffer, buffer_size, width >= 0 ? width : 0, format_option, 1));

	cmp	DWORD PTR _width$[ebp], 0
	jl	SHORT $LN18@PMC_ToStri
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv95[ebp], edx
	jmp	SHORT $LN19@PMC_ToStri
$LN18@PMC_ToStri:
	mov	DWORD PTR tv95[ebp], 0
$LN19@PMC_ToStri:
	push	1
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv95[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	call	_ToStringX
	add	esp, 24					; 00000018H
	jmp	SHORT $LN1@PMC_ToStri
$LN11@PMC_ToStri:

; 552  :     case 'd':
; 553  :     case 'D':
; 554  :         return (ToStringDN(nx, buffer, buffer_size, 'D', width >= 0 ? width : 0, format_option));

	cmp	DWORD PTR _width$[ebp], 0
	jl	SHORT $LN20@PMC_ToStri
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN21@PMC_ToStri
$LN20@PMC_ToStri:
	mov	DWORD PTR tv135[ebp], 0
$LN21@PMC_ToStri:
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv135[ebp]
	push	ecx
	push	68					; 00000044H
	mov	edx, DWORD PTR _buffer_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	call	_ToStringDN
	add	esp, 24					; 00000018H
	jmp	SHORT $LN1@PMC_ToStri
$LN12@PMC_ToStri:

; 555  :     default:
; 556  :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
$LN1@PMC_ToStri:

; 557  :     }
; 558  : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN23@PMC_ToStri:
	DD	$LN11@PMC_ToStri
	DD	$LN8@PMC_ToStri
	DD	$LN10@PMC_ToStri
	DD	$LN9@PMC_ToStri
	DD	$LN12@PMC_ToStri
$LN22@PMC_ToStri:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_PMC_ToString@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_tostring.c
_TEXT	SEGMENT
_feature$ = 8						; size = 4
_Initialize_ToString PROC

; 561  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3AA1CF5E_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 562  :     default_number_format_option.DecimalDigits = 2;

	mov	DWORD PTR _default_number_format_option, 2

; 563  :     lstrcpyW(default_number_format_option.GroupSeparator, L",");

	mov	esi, esp
	push	OFFSET $SG94661
	push	OFFSET _default_number_format_option+4
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 564  :     lstrcpyW(default_number_format_option.DecimalSeparator, L".");

	mov	esi, esp
	push	OFFSET $SG94662
	push	OFFSET _default_number_format_option+10
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 565  :     lstrcpy(default_number_format_option.GroupSizes, "3");

	mov	esi, esp
	push	OFFSET $SG94663
	push	OFFSET _default_number_format_option+28
	call	DWORD PTR __imp__lstrcpyA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 566  :     lstrcpyW(default_number_format_option.PositiveSign, L"+");

	mov	esi, esp
	push	OFFSET $SG94664
	push	OFFSET _default_number_format_option+16
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 567  :     lstrcpyW(default_number_format_option.NegativeSign, L"-");

	mov	esi, esp
	push	OFFSET $SG94665
	push	OFFSET _default_number_format_option+22
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 568  : 
; 569  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 570  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_Initialize_ToString ENDP
_TEXT	ENDS
END
