; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

	TITLE	Z:\Sources\Lunor\Repos\rougemeilland\Palmtree.Math.Core.Implements\Palmtree.Math.Core.Implements\TEST_op_DivRem.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_TEST_PMC_DivRem_X_I
PUBLIC	_TEST_PMC_DivRem_X_L
PUBLIC	_TEST_PMC_DivRem_X_X
PUBLIC	??_C@_0CN@LDAEIIBE@PMC_From_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@ ; `string'
PUBLIC	??_C@_0BH@DDBBPKKG@PMC_DivRem_X_I?5?$CI?$CFd?4?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0DB@CJJOGBJJ@PMC_DivRem_X_I?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@ ; `string'
PUBLIC	??_C@_0CN@JELPCGPD@PMC_To_X_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@ ; `string'
PUBLIC	??_C@_0BD@NJDOJIFK@?$IP?$KE?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@ ; `string'
PUBLIC	??_C@_0BF@GAFJKMBL@?$IP?h?$JH?$FN?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@ ; `string'
PUBLIC	??_C@_0BH@NFDIDBOC@PMC_DivRem_X_L?5?$CI?$CFd?4?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0DB@IELOONJL@PMC_DivRem_X_L?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@ ; `string'
PUBLIC	??_C@_0BH@PLHNBAHA@PMC_DivRem_X_X?5?$CI?$CFd?4?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0DB@FNKPNHFA@PMC_DivRem_X_X?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@ ; `string'
EXTRN	_TEST_Assert:PROC
EXTRN	_FormatTestLabel:PROC
EXTRN	_FormatTestMesssage:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0DB@FNKPNHFA@PMC_DivRem_X_X?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@
CONST	SEGMENT
??_C@_0DB@FNKPNHFA@PMC_DivRem_X_X?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@ DB 'P'
	DB	'MC_DivRem_X_X', 082H, 0ccH, 095H, 09cH, 08bH, 'A', 083H, 'R', 081H
	DB	'[', 083H, 'h', 082H, 0aaH, 08aH, 0faH, 091H, 0d2H, 092H, 0caH
	DB	082H, 0e8H, 082H, 0c5H, 082H, 0cdH, 082H, 0c8H, 082H, 0a2H, '('
	DB	'%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PLHNBAHA@PMC_DivRem_X_X?5?$CI?$CFd?4?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BH@PLHNBAHA@PMC_DivRem_X_X?5?$CI?$CFd?4?$CFd?$CJ@ DB 'PMC_DivRem_X'
	DB	'_X (%d.%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IELOONJL@PMC_DivRem_X_L?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@
CONST	SEGMENT
??_C@_0DB@IELOONJL@PMC_DivRem_X_L?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@ DB 'P'
	DB	'MC_DivRem_X_L', 082H, 0ccH, 095H, 09cH, 08bH, 'A', 083H, 'R', 081H
	DB	'[', 083H, 'h', 082H, 0aaH, 08aH, 0faH, 091H, 0d2H, 092H, 0caH
	DB	082H, 0e8H, 082H, 0c5H, 082H, 0cdH, 082H, 0c8H, 082H, 0a2H, '('
	DB	'%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NFDIDBOC@PMC_DivRem_X_L?5?$CI?$CFd?4?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BH@NFDIDBOC@PMC_DivRem_X_L?5?$CI?$CFd?4?$CFd?$CJ@ DB 'PMC_DivRem_X'
	DB	'_L (%d.%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GAFJKMBL@?$IP?h?$JH?$FN?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@
CONST	SEGMENT
??_C@_0BF@GAFJKMBL@?$IP?h?$JH?$FN?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@ DB 08fH
	DB	0e8H, 097H, ']', 082H, 0ccH, 092H, 'l', 082H, 0aaH, 088H, 0eaH
	DB	092H, 'v', 082H, 0b5H, 082H, 0c8H, 082H, 0a2H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NJDOJIFK@?$IP?$KE?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@
CONST	SEGMENT
??_C@_0BD@NJDOJIFK@?$IP?$KE?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@ DB 08fH
	DB	0a4H, 082H, 0ccH, 092H, 'l', 082H, 0aaH, 088H, 0eaH, 092H, 'v', 082H
	DB	0b5H, 082H, 0c8H, 082H, 0a2H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JELPCGPD@PMC_To_X_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@
CONST	SEGMENT
??_C@_0CN@JELPCGPD@PMC_To_X_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@ DB 'P'
	DB	'MC_To_X_B', 082H, 0ccH, 095H, 09cH, 08bH, 'A', 083H, 'R', 081H
	DB	'[', 083H, 'h', 082H, 0aaH, 08aH, 0faH, 091H, 0d2H, 092H, 0caH
	DB	082H, 0e8H, 082H, 0c5H, 082H, 0cdH, 082H, 0c8H, 082H, 0a2H, '('
	DB	'%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CJJOGBJJ@PMC_DivRem_X_I?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@
CONST	SEGMENT
??_C@_0DB@CJJOGBJJ@PMC_DivRem_X_I?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@ DB 'P'
	DB	'MC_DivRem_X_I', 082H, 0ccH, 095H, 09cH, 08bH, 'A', 083H, 'R', 081H
	DB	'[', 083H, 'h', 082H, 0aaH, 08aH, 0faH, 091H, 0d2H, 092H, 0caH
	DB	082H, 0e8H, 082H, 0c5H, 082H, 0cdH, 082H, 0c8H, 082H, 0a2H, '('
	DB	'%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DDBBPKKG@PMC_DivRem_X_I?5?$CI?$CFd?4?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BH@DDBBPKKG@PMC_DivRem_X_I?5?$CI?$CFd?4?$CFd?$CJ@ DB 'PMC_DivRem_X'
	DB	'_I (%d.%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LDAEIIBE@PMC_From_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@
CONST	SEGMENT
??_C@_0CN@LDAEIIBE@PMC_From_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@ DB 'P'
	DB	'MC_From_B', 082H, 0ccH, 095H, 09cH, 08bH, 'A', 083H, 'R', 081H
	DB	'[', 083H, 'h', 082H, 0aaH, 08aH, 0faH, 091H, 0d2H, 092H, 0caH
	DB	082H, 0e8H, 082H, 0c5H, 082H, 0cdH, 082H, 0c8H, 082H, 0a2H, '('
	DB	'%d)', 00H					; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h
;	COMDAT __EQUALS_MEMORY
_TEXT	SEGMENT
_buffer1$ = 8						; size = 4
_count1$ = 12						; size = 4
_buffer2$ = 16						; size = 4
_count2$ = 20						; size = 4
__EQUALS_MEMORY PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp

; 103  :     if (count1 != count2)

	mov	edx, DWORD PTR _count1$[ebp]
	push	esi
	cmp	edx, DWORD PTR _count2$[ebp]
	jne	SHORT $LN8@EQUALS_MEM

; 104  :         return (-1);
; 105  :     while (count1 > 0)

	test	edx, edx
	je	SHORT $LN3@EQUALS_MEM
	mov	esi, DWORD PTR _buffer1$[ebp]
	mov	eax, DWORD PTR _buffer2$[ebp]
	sub	esi, eax
$LL2@EQUALS_MEM:

; 106  :     {
; 107  :         if (*buffer1 != *buffer2)

	mov	cl, BYTE PTR [esi+eax]
	cmp	cl, BYTE PTR [eax]
	jne	SHORT $LN8@EQUALS_MEM

; 109  :         ++buffer1;
; 110  :         ++buffer2;

	inc	eax

; 111  :         --count1;

	sub	edx, 1
	jne	SHORT $LL2@EQUALS_MEM
$LN3@EQUALS_MEM:

; 112  :     }
; 113  :     return (0);

	xor	eax, eax
	pop	esi

; 114  : }

	pop	ebp
	ret	0
$LN8@EQUALS_MEM:

; 108  :             return (-1);

	or	eax, -1
	pop	esi

; 114  : }

	pop	ebp
	ret	0
__EQUALS_MEMORY ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c
;	COMDAT _TEST_PMC_DivRem_X_X
_TEXT	SEGMENT
_v_result$1$ = -556					; size = 4
_actual_r_buf_size$ = -552				; size = 4
_actual_q_buf_size$ = -548				; size = 4
_u$ = -544						; size = 4
_u_result$1$ = -540					; size = 4
_v$ = -536						; size = 4
_r$ = -532						; size = 4
_q$ = -528						; size = 4
_q_r_result$1$ = -524					; size = 4
_no$GSCopy$1$ = -520					; size = 4
_actual_r_buf$ = -516					; size = 256
_actual_q_buf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_env$ = 8						; size = 4
_ep$ = 12						; size = 4
_no$ = 16						; size = 4
_u_buf$ = 20						; size = 4
_u_buf_size$ = 24					; size = 4
_v_buf$ = 28						; size = 4
_v_buf_size$ = 32					; size = 4
_desired_return_code$ = 36				; size = 4
_desired_q_buf$ = 40					; size = 4
_desired_q_buf_size$ = 44				; size = 4
_desired_r_buf$ = 48					; size = 4
_desired_r_buf_size$ = 52				; size = 4
_TEST_PMC_DivRem_X_X PROC				; COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _no$[ebp]

; 88   : 	HANDLE u;
; 89   : 	HANDLE v;
; 90   : 	HANDLE q;
; 91   : 	HANDLE r;
; 92   : 	unsigned char actual_q_buf[256];
; 93   : 	size_t actual_q_buf_size;
; 94   : 	unsigned char actual_r_buf[256];
; 95   : 	size_t actual_r_buf_size;
; 96   : 	PMC_STATUS_CODE result;
; 97   : 	PMC_STATUS_CODE u_result;
; 98   : 	PMC_STATUS_CODE v_result;
; 99   : 	PMC_STATUS_CODE q_r_result;
; 100  : 	TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_X (%d.%d)", no, 1), (u_result = ep->PMC_From_B(u_buf, u_buf_size, &u)) == PMC_STATUS_OK, FormatTestMesssage("PMC_From_Bの復帰コードが期待通りではない(%d)", u_result));

	lea	ecx, DWORD PTR _u$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _env$[ebp]
	push	esi
	mov	esi, DWORD PTR _v_buf$[ebp]
	push	edi
	mov	edi, DWORD PTR _ep$[ebp]
	push	ecx
	push	DWORD PTR _u_buf_size$[ebp]
	mov	DWORD PTR _no$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+16]
	call	eax
	push	eax
	push	OFFSET ??_C@_0CN@LDAEIIBE@PMC_From_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@
	mov	DWORD PTR _u_result$1$[ebp], eax
	call	_FormatTestMesssage
	add	esp, 8
	xor	ecx, ecx
	cmp	DWORD PTR _u_result$1$[ebp], ecx
	sete	cl
	push	eax
	push	ecx
	push	1
	push	DWORD PTR _no$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0BH@PLHNBAHA@PMC_DivRem_X_X?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert
	add	esp, 16					; 00000010H

; 101  : 	TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_X (%d.%d)", no, 2), (v_result = ep->PMC_From_B(v_buf, v_buf_size, &v)) == PMC_STATUS_OK, FormatTestMesssage("PMC_From_Bの復帰コードが期待通りではない(%d)", v_result));

	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	push	DWORD PTR _v_buf_size$[ebp]
	mov	eax, DWORD PTR [edi+16]
	push	esi
	call	eax
	mov	esi, eax
	push	esi
	push	OFFSET ??_C@_0CN@LDAEIIBE@PMC_From_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@
	mov	DWORD PTR _v_result$1$[ebp], esi
	call	_FormatTestMesssage
	add	esp, 8
	xor	ecx, ecx
	test	esi, esi
	sete	cl
	push	eax
	push	ecx
	push	2
	push	DWORD PTR _no$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0BH@PLHNBAHA@PMC_DivRem_X_X?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert
	add	esp, 16					; 00000010H

; 102  : 	TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_X (%d.%d)", no, 3), (q_r_result = ep->PMC_DivRem_X_X(u, v, &q, &r)) == desired_return_code, FormatTestMesssage("PMC_DivRem_X_Xの復帰コードが期待通りではない(%d)", q_r_result));

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	push	DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edi+80]
	push	DWORD PTR _u$[ebp]
	call	eax
	push	eax
	push	OFFSET ??_C@_0DB@FNKPNHFA@PMC_DivRem_X_X?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@
	mov	DWORD PTR _q_r_result$1$[ebp], eax
	call	_FormatTestMesssage
	mov	esi, DWORD PTR _desired_return_code$[ebp]
	add	esp, 8
	xor	ecx, ecx
	cmp	DWORD PTR _q_r_result$1$[ebp], esi
	sete	cl
	push	eax
	push	ecx
	push	3
	push	DWORD PTR _no$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0BH@PLHNBAHA@PMC_DivRem_X_X?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert
	add	esp, 16					; 00000010H

; 103  : 	if (desired_return_code == PMC_STATUS_OK)

	test	esi, esi
	jne	$LN2@TEST_PMC_D

; 104  : 	{
; 105  : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_X (%d.%d)", no, 4), (result = ep->PMC_To_X_B(q, actual_q_buf, sizeof(actual_q_buf), &actual_q_buf_size)) == PMC_STATUS_OK, FormatTestMesssage("PMC_To_X_Bの復帰コードが期待通りではない(%d)", result));

	lea	eax, DWORD PTR _actual_q_buf_size$[ebp]
	push	eax
	push	256					; 00000100H
	lea	eax, DWORD PTR _actual_q_buf$[ebp]
	push	eax
	push	DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edi+32]
	call	eax
	mov	esi, eax
	push	esi
	push	OFFSET ??_C@_0CN@JELPCGPD@PMC_To_X_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@
	call	_FormatTestMesssage
	add	esp, 8
	xor	ecx, ecx
	test	esi, esi
	sete	cl
	push	eax
	push	ecx
	push	4
	push	DWORD PTR _no$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0BH@PLHNBAHA@PMC_DivRem_X_X?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert
	add	esp, 16					; 00000010H

; 106  : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_X (%d.%d)", no, 5), (result = ep->PMC_To_X_B(r, actual_r_buf, sizeof(actual_r_buf), &actual_r_buf_size)) == PMC_STATUS_OK, FormatTestMesssage("PMC_To_X_Bの復帰コードが期待通りではない(%d)", result));

	lea	eax, DWORD PTR _actual_r_buf_size$[ebp]
	push	eax
	push	256					; 00000100H
	lea	eax, DWORD PTR _actual_r_buf$[ebp]
	push	eax
	push	DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edi+32]
	call	eax
	mov	esi, eax
	push	esi
	push	OFFSET ??_C@_0CN@JELPCGPD@PMC_To_X_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@
	call	_FormatTestMesssage
	add	esp, 8
	xor	ecx, ecx
	test	esi, esi
	sete	cl
	push	eax
	push	ecx
	push	5
	push	DWORD PTR _no$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0BH@PLHNBAHA@PMC_DivRem_X_X?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert

; 107  : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_X (%d.%d)", no, 6), _EQUALS_MEMORY(actual_q_buf, actual_q_buf_size, desired_q_buf, desired_q_buf_size) == 0, "商の値が一致しない");

	mov	edx, DWORD PTR _actual_q_buf_size$[ebp]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _desired_q_buf$[ebp]
	cmp	edx, DWORD PTR _desired_q_buf_size$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h

; 103  :     if (count1 != count2)

	je	SHORT $LN19@TEST_PMC_D
$LN21@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c

; 107  : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_X (%d.%d)", no, 6), _EQUALS_MEMORY(actual_q_buf, actual_q_buf_size, desired_q_buf, desired_q_buf_size) == 0, "商の値が一致しない");

	or	ecx, -1
	jmp	SHORT $LN7@TEST_PMC_D
$LN19@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h

; 105  :     while (count1 > 0)

	test	edx, edx
	je	SHORT $LN9@TEST_PMC_D
	lea	esi, DWORD PTR _actual_q_buf$[ebp]
	sub	esi, ecx
	npad	2
$LL8@TEST_PMC_D:

; 106  :     {
; 107  :         if (*buffer1 != *buffer2)

	mov	al, BYTE PTR [esi+ecx]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN21@TEST_PMC_D

; 108  :             return (-1);
; 109  :         ++buffer1;
; 110  :         ++buffer2;

	inc	ecx

; 111  :         --count1;

	sub	edx, 1
	jne	SHORT $LL8@TEST_PMC_D
$LN9@TEST_PMC_D:

; 112  :     }
; 113  :     return (0);

	xor	ecx, ecx
$LN7@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c

; 107  : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_X (%d.%d)", no, 6), _EQUALS_MEMORY(actual_q_buf, actual_q_buf_size, desired_q_buf, desired_q_buf_size) == 0, "商の値が一致しない");

	xor	eax, eax
	test	ecx, ecx
	push	OFFSET ??_C@_0BD@NJDOJIFK@?$IP?$KE?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@
	sete	al
	push	eax
	push	6
	push	DWORD PTR _no$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0BH@PLHNBAHA@PMC_DivRem_X_X?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert

; 108  : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_X (%d.%d)", no, 7), _EQUALS_MEMORY(actual_r_buf, actual_r_buf_size, desired_r_buf, desired_r_buf_size) == 0, "剰余の値が一致しない");

	mov	edx, DWORD PTR _actual_r_buf_size$[ebp]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _desired_r_buf$[ebp]
	cmp	edx, DWORD PTR _desired_r_buf_size$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h

; 103  :     if (count1 != count2)

	je	SHORT $LN20@TEST_PMC_D
$LN22@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c

; 108  : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_X (%d.%d)", no, 7), _EQUALS_MEMORY(actual_r_buf, actual_r_buf_size, desired_r_buf, desired_r_buf_size) == 0, "剰余の値が一致しない");

	or	ecx, -1
	jmp	SHORT $LN13@TEST_PMC_D
$LN20@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h

; 105  :     while (count1 > 0)

	test	edx, edx
	je	SHORT $LN15@TEST_PMC_D
	lea	esi, DWORD PTR _actual_r_buf$[ebp]
	sub	esi, ecx
	npad	6
$LL14@TEST_PMC_D:

; 106  :     {
; 107  :         if (*buffer1 != *buffer2)

	mov	al, BYTE PTR [esi+ecx]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN22@TEST_PMC_D

; 108  :             return (-1);
; 109  :         ++buffer1;
; 110  :         ++buffer2;

	inc	ecx

; 111  :         --count1;

	sub	edx, 1
	jne	SHORT $LL14@TEST_PMC_D
$LN15@TEST_PMC_D:

; 112  :     }
; 113  :     return (0);

	xor	ecx, ecx
$LN13@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c

; 108  : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_X (%d.%d)", no, 7), _EQUALS_MEMORY(actual_r_buf, actual_r_buf_size, desired_r_buf, desired_r_buf_size) == 0, "剰余の値が一致しない");

	xor	eax, eax
	test	ecx, ecx
	push	OFFSET ??_C@_0BF@GAFJKMBL@?$IP?h?$JH?$FN?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@
	sete	al
	push	eax
	push	7
	push	DWORD PTR _no$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0BH@PLHNBAHA@PMC_DivRem_X_X?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert
	add	esp, 16					; 00000010H
$LN2@TEST_PMC_D:

; 109  : 	}
; 110  : 	if (q_r_result == PMC_STATUS_OK)

	cmp	DWORD PTR _q_r_result$1$[ebp], 0
	jne	SHORT $LN3@TEST_PMC_D

; 111  : 	{
; 112  : 		ep->PMC_Dispose(q);

	push	DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edi+20]
	call	eax

; 113  : 		ep->PMC_Dispose(r);

	push	DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edi+20]
	call	eax
$LN3@TEST_PMC_D:

; 114  : 	}
; 115  : 	if (v_result == PMC_STATUS_OK)

	cmp	DWORD PTR _v_result$1$[ebp], 0
	jne	SHORT $LN4@TEST_PMC_D

; 116  : 		ep->PMC_Dispose(v);

	push	DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edi+20]
	call	eax
$LN4@TEST_PMC_D:

; 117  : 	if (u_result == PMC_STATUS_OK)

	cmp	DWORD PTR _u_result$1$[ebp], 0
	jne	SHORT $LN5@TEST_PMC_D

; 118  : 		ep->PMC_Dispose(u);

	push	DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edi+20]
	call	eax
$LN5@TEST_PMC_D:

; 119  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEST_PMC_DivRem_X_X ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c
;	COMDAT _TEST_PMC_DivRem_X_L
_TEXT	SEGMENT
_actual_r$ = -292					; size = 8
_actual_q_buf_size$ = -284				; size = 4
_u$ = -280						; size = 4
_u_result$1$ = -276					; size = 4
_q$ = -272						; size = 4
_q_result$1$ = -268					; size = 4
_no$GSCopy$1$ = -264					; size = 4
_actual_q_buf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_env$ = 8						; size = 4
_ep$ = 12						; size = 4
_no$ = 16						; size = 4
_u_buf$ = 20						; size = 4
_u_buf_size$ = 24					; size = 4
_v$ = 28						; size = 8
_desired_return_code$ = 36				; size = 4
_desired_q_buf$ = 40					; size = 4
_desired_q_buf_size$ = 44				; size = 4
_desired_r$ = 48					; size = 8
_TEST_PMC_DivRem_X_L PROC				; COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _u_buf$[ebp]

; 64   : 	HANDLE u;
; 65   : 	HANDLE q;
; 66   : 	unsigned char actual_q_buf[256];
; 67   : 	size_t actual_q_buf_size;
; 68   : 	unsigned __int64 actual_r;
; 69   : 	PMC_STATUS_CODE result;
; 70   : 	PMC_STATUS_CODE u_result;
; 71   : 	PMC_STATUS_CODE q_result;
; 72   : 	TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_L (%d.%d)", no, 1), (u_result = ep->PMC_From_B(u_buf, u_buf_size, &u)) == PMC_STATUS_OK, FormatTestMesssage("PMC_From_Bの復帰コードが期待通りではない(%d)", u_result));

	lea	ecx, DWORD PTR _u$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _env$[ebp]
	push	esi
	mov	esi, DWORD PTR _no$[ebp]
	push	edi
	mov	edi, DWORD PTR _ep$[ebp]
	push	ecx
	push	DWORD PTR _u_buf_size$[ebp]
	mov	DWORD PTR _no$GSCopy$1$[ebp], esi
	push	eax
	mov	eax, DWORD PTR [edi+16]
	call	eax
	push	eax
	push	OFFSET ??_C@_0CN@LDAEIIBE@PMC_From_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@
	mov	DWORD PTR _u_result$1$[ebp], eax
	call	_FormatTestMesssage
	add	esp, 8
	xor	ecx, ecx
	cmp	DWORD PTR _u_result$1$[ebp], ecx
	sete	cl
	push	eax
	push	ecx
	push	1
	push	esi
	push	OFFSET ??_C@_0BH@NFDIDBOC@PMC_DivRem_X_L?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert
	add	esp, 16					; 00000010H

; 73   : 	TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_L (%d.%d)", no, 2), (q_result = ep->PMC_DivRem_X_L(u, v, &q, &actual_r)) == desired_return_code, FormatTestMesssage("PMC_DivRem_X_Lの復帰コードが期待通りではない(%d)", q_result));

	lea	eax, DWORD PTR _actual_r$[ebp]
	push	eax
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	push	DWORD PTR _v$[ebp+4]
	mov	eax, DWORD PTR [edi+76]
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _u$[ebp]
	call	eax
	push	eax
	push	OFFSET ??_C@_0DB@IELOONJL@PMC_DivRem_X_L?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@
	mov	DWORD PTR _q_result$1$[ebp], eax
	call	_FormatTestMesssage
	mov	esi, DWORD PTR _desired_return_code$[ebp]
	add	esp, 8
	xor	ecx, ecx
	cmp	DWORD PTR _q_result$1$[ebp], esi
	sete	cl
	push	eax
	push	ecx
	push	2
	push	DWORD PTR _no$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0BH@NFDIDBOC@PMC_DivRem_X_L?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert
	add	esp, 16					; 00000010H

; 74   : 	if (desired_return_code == PMC_STATUS_OK)

	test	esi, esi
	jne	$LN2@TEST_PMC_D

; 75   : 	{
; 76   : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_L (%d.%d)", no, 3), (result = ep->PMC_To_X_B(q, actual_q_buf, sizeof(actual_q_buf), &actual_q_buf_size)) == PMC_STATUS_OK, FormatTestMesssage("PMC_To_X_Bの復帰コードが期待通りではない(%d)", result));

	lea	eax, DWORD PTR _actual_q_buf_size$[ebp]
	push	eax
	push	256					; 00000100H
	lea	eax, DWORD PTR _actual_q_buf$[ebp]
	push	eax
	push	DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edi+32]
	call	eax
	mov	esi, eax
	push	esi
	push	OFFSET ??_C@_0CN@JELPCGPD@PMC_To_X_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@
	call	_FormatTestMesssage
	add	esp, 8
	xor	ecx, ecx
	test	esi, esi
	sete	cl
	push	eax
	push	ecx
	push	3
	push	DWORD PTR _no$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0BH@NFDIDBOC@PMC_DivRem_X_L?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert

; 77   : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_L (%d.%d)", no, 4), _EQUALS_MEMORY(actual_q_buf, actual_q_buf_size, desired_q_buf, desired_q_buf_size) == 0, "商の値が一致しない");

	mov	edx, DWORD PTR _actual_q_buf_size$[ebp]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _desired_q_buf$[ebp]
	cmp	edx, DWORD PTR _desired_q_buf_size$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h

; 103  :     if (count1 != count2)

	je	SHORT $LN14@TEST_PMC_D
$LN15@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c

; 77   : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_L (%d.%d)", no, 4), _EQUALS_MEMORY(actual_q_buf, actual_q_buf_size, desired_q_buf, desired_q_buf_size) == 0, "商の値が一致しない");

	or	ecx, -1
	jmp	SHORT $LN8@TEST_PMC_D
$LN14@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h

; 105  :     while (count1 > 0)

	test	edx, edx
	je	SHORT $LN10@TEST_PMC_D
	lea	esi, DWORD PTR _actual_q_buf$[ebp]
	sub	esi, ecx
$LL9@TEST_PMC_D:

; 106  :     {
; 107  :         if (*buffer1 != *buffer2)

	mov	al, BYTE PTR [esi+ecx]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN15@TEST_PMC_D

; 108  :             return (-1);
; 109  :         ++buffer1;
; 110  :         ++buffer2;

	inc	ecx

; 111  :         --count1;

	sub	edx, 1
	jne	SHORT $LL9@TEST_PMC_D
$LN10@TEST_PMC_D:

; 112  :     }
; 113  :     return (0);

	xor	ecx, ecx
$LN8@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c

; 77   : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_L (%d.%d)", no, 4), _EQUALS_MEMORY(actual_q_buf, actual_q_buf_size, desired_q_buf, desired_q_buf_size) == 0, "商の値が一致しない");

	mov	esi, DWORD PTR _no$GSCopy$1$[ebp]
	xor	eax, eax
	test	ecx, ecx
	push	OFFSET ??_C@_0BD@NJDOJIFK@?$IP?$KE?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@
	sete	al
	push	eax
	push	4
	push	esi
	push	OFFSET ??_C@_0BH@NFDIDBOC@PMC_DivRem_X_L?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert

; 78   : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_L (%d.%d)", no, 5), actual_r == desired_r, "剰余の値が一致しない");

	mov	eax, DWORD PTR _actual_r$[ebp]
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _desired_r$[ebp]
	jne	SHORT $LN6@TEST_PMC_D
	mov	eax, DWORD PTR _actual_r$[ebp+4]
	cmp	eax, DWORD PTR _desired_r$[ebp+4]
	jne	SHORT $LN6@TEST_PMC_D
	mov	eax, 1
	jmp	SHORT $LN7@TEST_PMC_D
$LN6@TEST_PMC_D:
	xor	eax, eax
$LN7@TEST_PMC_D:
	push	OFFSET ??_C@_0BF@GAFJKMBL@?$IP?h?$JH?$FN?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@
	push	eax
	push	5
	push	esi
	push	OFFSET ??_C@_0BH@NFDIDBOC@PMC_DivRem_X_L?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert
	add	esp, 16					; 00000010H
$LN2@TEST_PMC_D:

; 79   : 	}
; 80   : 	if (q_result == PMC_STATUS_OK)

	cmp	DWORD PTR _q_result$1$[ebp], 0
	jne	SHORT $LN3@TEST_PMC_D

; 81   : 		ep->PMC_Dispose(q);

	push	DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edi+20]
	call	eax
$LN3@TEST_PMC_D:

; 82   : 	if (u_result == PMC_STATUS_OK)

	cmp	DWORD PTR _u_result$1$[ebp], 0
	jne	SHORT $LN4@TEST_PMC_D

; 83   : 		ep->PMC_Dispose(u);

	push	DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edi+20]
	call	eax
$LN4@TEST_PMC_D:

; 84   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEST_PMC_DivRem_X_L ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c
;	COMDAT _TEST_PMC_DivRem_X_I
_TEXT	SEGMENT
_actual_r$ = -288					; size = 4
_actual_q_buf_size$ = -284				; size = 4
_u$ = -280						; size = 4
_u_result$1$ = -276					; size = 4
_q$ = -272						; size = 4
_q_result$1$ = -268					; size = 4
_no$GSCopy$1$ = -264					; size = 4
_actual_q_buf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_env$ = 8						; size = 4
_ep$ = 12						; size = 4
_no$ = 16						; size = 4
_u_buf$ = 20						; size = 4
_u_buf_size$ = 24					; size = 4
_v$ = 28						; size = 4
_desired_return_code$ = 32				; size = 4
_desired_q_buf$ = 36					; size = 4
_desired_q_buf_size$ = 40				; size = 4
_desired_r$ = 44					; size = 4
_TEST_PMC_DivRem_X_I PROC				; COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _u_buf$[ebp]

; 40   : 	HANDLE u;
; 41   : 	HANDLE q;
; 42   : 	unsigned char actual_q_buf[256];
; 43   : 	size_t actual_q_buf_size;
; 44   : 	unsigned __int32 actual_r;
; 45   : 	PMC_STATUS_CODE result;
; 46   : 	PMC_STATUS_CODE u_result;
; 47   : 	PMC_STATUS_CODE q_result;
; 48   : 	TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_I (%d.%d)", no, 1), (u_result = ep->PMC_From_B(u_buf, u_buf_size, &u)) == PMC_STATUS_OK, FormatTestMesssage("PMC_From_Bの復帰コードが期待通りではない(%d)", u_result));

	lea	ecx, DWORD PTR _u$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _env$[ebp]
	push	esi
	mov	esi, DWORD PTR _no$[ebp]
	push	edi
	mov	edi, DWORD PTR _ep$[ebp]
	push	ecx
	push	DWORD PTR _u_buf_size$[ebp]
	mov	DWORD PTR _no$GSCopy$1$[ebp], esi
	push	eax
	mov	eax, DWORD PTR [edi+16]
	call	eax
	push	eax
	push	OFFSET ??_C@_0CN@LDAEIIBE@PMC_From_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@
	mov	DWORD PTR _u_result$1$[ebp], eax
	call	_FormatTestMesssage
	add	esp, 8
	xor	ecx, ecx
	cmp	DWORD PTR _u_result$1$[ebp], ecx
	sete	cl
	push	eax
	push	ecx
	push	1
	push	esi
	push	OFFSET ??_C@_0BH@DDBBPKKG@PMC_DivRem_X_I?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert
	add	esp, 16					; 00000010H

; 49   : 	TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_I (%d.%d)", no, 2), (q_result = ep->PMC_DivRem_X_I(u, v, &q, &actual_r)) == desired_return_code, FormatTestMesssage("PMC_DivRem_X_Iの復帰コードが期待通りではない(%d)", q_result));

	lea	eax, DWORD PTR _actual_r$[ebp]
	push	eax
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	push	DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edi+72]
	push	DWORD PTR _u$[ebp]
	call	eax
	push	eax
	push	OFFSET ??_C@_0DB@CJJOGBJJ@PMC_DivRem_X_I?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB@
	mov	DWORD PTR _q_result$1$[ebp], eax
	call	_FormatTestMesssage
	mov	esi, DWORD PTR _desired_return_code$[ebp]
	add	esp, 8
	xor	ecx, ecx
	cmp	DWORD PTR _q_result$1$[ebp], esi
	sete	cl
	push	eax
	push	ecx
	push	2
	push	DWORD PTR _no$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0BH@DDBBPKKG@PMC_DivRem_X_I?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert
	add	esp, 16					; 00000010H

; 50   : 	if (desired_return_code == PMC_STATUS_OK)

	test	esi, esi
	jne	$LN2@TEST_PMC_D

; 51   : 	{
; 52   : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_I (%d.%d)", no, 3), (result = ep->PMC_To_X_B(q, actual_q_buf, sizeof(actual_q_buf), &actual_q_buf_size)) == PMC_STATUS_OK, FormatTestMesssage("PMC_To_X_Bの復帰コードが期待通りではない(%d)", result));

	lea	eax, DWORD PTR _actual_q_buf_size$[ebp]
	push	eax
	push	256					; 00000100H
	lea	eax, DWORD PTR _actual_q_buf$[ebp]
	push	eax
	push	DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edi+32]
	call	eax
	mov	esi, eax
	push	esi
	push	OFFSET ??_C@_0CN@JELPCGPD@PMC_To_X_B?$IC?L?$JF?$JM?$ILA?$IDR?$IB?$FL?$IDh?$IC?$KK?$IK?z?$JB?R?$JC?J?$IC@
	call	_FormatTestMesssage
	add	esp, 8
	xor	ecx, ecx
	test	esi, esi
	sete	cl
	push	eax
	push	ecx
	push	3
	push	DWORD PTR _no$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0BH@DDBBPKKG@PMC_DivRem_X_I?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert

; 53   : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_I (%d.%d)", no, 4), _EQUALS_MEMORY(actual_q_buf, actual_q_buf_size, desired_q_buf, desired_q_buf_size) == 0, "商の値が一致しない");

	mov	edx, DWORD PTR _actual_q_buf_size$[ebp]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _desired_q_buf$[ebp]
	cmp	edx, DWORD PTR _desired_q_buf_size$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h

; 103  :     if (count1 != count2)

	je	SHORT $LN12@TEST_PMC_D
$LN13@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c

; 53   : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_I (%d.%d)", no, 4), _EQUALS_MEMORY(actual_q_buf, actual_q_buf_size, desired_q_buf, desired_q_buf_size) == 0, "商の値が一致しない");

	or	ecx, -1
	jmp	SHORT $LN6@TEST_PMC_D
$LN12@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_debug.h

; 105  :     while (count1 > 0)

	test	edx, edx
	je	SHORT $LN8@TEST_PMC_D
	lea	esi, DWORD PTR _actual_q_buf$[ebp]
	sub	esi, ecx
	npad	1
$LL7@TEST_PMC_D:

; 106  :     {
; 107  :         if (*buffer1 != *buffer2)

	mov	al, BYTE PTR [esi+ecx]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN13@TEST_PMC_D

; 108  :             return (-1);
; 109  :         ++buffer1;
; 110  :         ++buffer2;

	inc	ecx

; 111  :         --count1;

	sub	edx, 1
	jne	SHORT $LL7@TEST_PMC_D
$LN8@TEST_PMC_D:

; 112  :     }
; 113  :     return (0);

	xor	ecx, ecx
$LN6@TEST_PMC_D:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\test_op_divrem.c

; 53   : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_I (%d.%d)", no, 4), _EQUALS_MEMORY(actual_q_buf, actual_q_buf_size, desired_q_buf, desired_q_buf_size) == 0, "商の値が一致しない");

	mov	esi, DWORD PTR _no$GSCopy$1$[ebp]
	xor	eax, eax
	test	ecx, ecx
	push	OFFSET ??_C@_0BD@NJDOJIFK@?$IP?$KE?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@
	sete	al
	push	eax
	push	4
	push	esi
	push	OFFSET ??_C@_0BH@DDBBPKKG@PMC_DivRem_X_I?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert

; 54   : 		TEST_Assert(env, FormatTestLabel("PMC_DivRem_X_I (%d.%d)", no, 5), actual_r == desired_r, "剰余の値が一致しない");

	mov	eax, DWORD PTR _actual_r$[ebp]
	add	esp, 16					; 00000010H
	xor	ecx, ecx
	cmp	eax, DWORD PTR _desired_r$[ebp]
	sete	cl
	push	OFFSET ??_C@_0BF@GAFJKMBL@?$IP?h?$JH?$FN?$IC?L?$JCl?$IC?$KK?$II?j?$JCv?$IC?$LF?$IC?H?$IC?$KC@
	push	ecx
	push	5
	push	esi
	push	OFFSET ??_C@_0BH@DDBBPKKG@PMC_DivRem_X_I?5?$CI?$CFd?4?$CFd?$CJ@
	call	_FormatTestLabel
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	call	_TEST_Assert
	add	esp, 16					; 00000010H
$LN2@TEST_PMC_D:

; 55   : 	}
; 56   : 	if (q_result == PMC_STATUS_OK)

	cmp	DWORD PTR _q_result$1$[ebp], 0
	jne	SHORT $LN3@TEST_PMC_D

; 57   : 		ep->PMC_Dispose(q);

	push	DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edi+20]
	call	eax
$LN3@TEST_PMC_D:

; 58   : 	if (u_result == PMC_STATUS_OK)

	cmp	DWORD PTR _u_result$1$[ebp], 0
	jne	SHORT $LN4@TEST_PMC_D

; 59   : 		ep->PMC_Dispose(u);

	push	DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edi+20]
	call	eax
$LN4@TEST_PMC_D:

; 60   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEST_PMC_DivRem_X_I ENDP
_TEXT	ENDS
END
