; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

	TITLE	Z:\Sources\Lunor\Repos\rougemeilland\Palmtree.Math.Core.Implements\Palmtree.Math.Core.Implements\pmc_parse.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_Initialize_Parse
PUBLIC	_PMC_TryParse@16
PUBLIC	??_C@_13DEFPDAGF@?$AA?0@			; `string'
PUBLIC	??_C@_13JOFGPIOO@?$AA?4@			; `string'
PUBLIC	??_C@_01EKENIIDA@3@				; `string'
PUBLIC	??_C@_13KJIIAINM@?$AA?$CL@			; `string'
PUBLIC	??_C@_13IMODFHAA@?$AA?9@			; `string'
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrcpyW@8:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	_AllocateBlock:PROC
EXTRN	_DeallocateBlock:PROC
EXTRN	_CheckBlockLight:PROC
EXTRN	_AllocateNumber:PROC
EXTRN	_DeallocateNumber:PROC
EXTRN	_CommitNumber:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_number_zero:BYTE
EXTRN	_statistics_info:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_default_number_format_option DB 028H DUP (?)
_fp_MultiplyAndAdd DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_13IMODFHAA@?$AA?9@
CONST	SEGMENT
??_C@_13IMODFHAA@?$AA?9@ DB '-', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13KJIIAINM@?$AA?$CL@
CONST	SEGMENT
??_C@_13KJIIAINM@?$AA?$CL@ DB '+', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EKENIIDA@3@
CONST	SEGMENT
??_C@_01EKENIIDA@3@ DB '3', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13JOFGPIOO@?$AA?4@
CONST	SEGMENT
??_C@_13JOFGPIOO@?$AA?4@ DB '.', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13DEFPDAGF@?$AA?0@
CONST	SEGMENT
??_C@_13DEFPDAGF@?$AA?0@ DB ',', 00H, 00H, 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _TryParseX
_TEXT	SEGMENT
_o_light_check_code$ = -100				; size = 4
_o$GSCopy$1$ = -96					; size = 4
_int_part_buf_code$ = -92				; size = 4
_int_part_buf_words$ = -88				; size = 4
_state$1 = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o$ = 20						; size = 4
_TryParseX PROC						; COMDAT

; 967  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _o$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _format_option$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _source$[ebp]

; 968  :     PMC_STATUS_CODE result;
; 969  :     __UNIT_TYPE source_len = lstrlenW(source);

	push	edi
	mov	DWORD PTR _o$GSCopy$1$[ebp], eax
	call	DWORD PTR __imp__lstrlenW@4

; 970  :     __UNIT_TYPE int_part_buf_code;
; 971  :     __UNIT_TYPE int_part_buf_words;
; 972  :     wchar_t* int_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &int_part_buf_words, &int_part_buf_code);

	lea	ecx, DWORD PTR _int_part_buf_code$[ebp]
	inc	eax
	push	ecx
	lea	ecx, DWORD PTR _int_part_buf_words$[ebp]
	shl	eax, 4
	push	ecx
	push	eax
	call	_AllocateBlock
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 973  :     if (int_part_buf == NULL)

	test	esi, esi
	jne	SHORT $LN2@TryParseX

; 974  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	pop	edi
	lea	eax, DWORD PTR [esi-5]

; 996  : }

	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@TryParseX:

; 288  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, NULL);

	push	0
	push	esi
	push	ebx
	mov	ebx, DWORD PTR _number_styles$[ebp]
	lea	eax, DWORD PTR _state$1[ebp]
	push	ebx
	push	edi
	push	eax
	call	_InitializeParserState
	add	esp, 24					; 00000018H

; 289  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	test	bl, 1
	je	SHORT $LN46@TryParseX

; 112  :         switch (*state->IN_PTR)

	mov	ecx, DWORD PTR _state$1[ebp]
	movzx	eax, WORD PTR [ecx]
	cmp	eax, 9
	jb	SHORT $LN46@TryParseX
	npad	6
$LL15@TryParseX:
	cmp	eax, 13					; 0000000dH
	jbe	SHORT $LN20@TryParseX
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN46@TryParseX
$LN20@TryParseX:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	ecx, 2
	mov	DWORD PTR _state$1[ebp], ecx
	movzx	eax, WORD PTR [ecx]
	cmp	eax, 9
	jae	SHORT $LL15@TryParseX
$LN46@TryParseX:

; 291  :     ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$1[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence

; 292  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	eax, DWORD PTR _state$1[ebp]
	add	esp, 4
	test	bl, 2
	je	SHORT $LN38@TryParseX

; 112  :         switch (*state->IN_PTR)

	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 9
	jb	SHORT $LN38@TryParseX
$LL24@TryParseX:
	cmp	ecx, 13					; 0000000dH
	jbe	SHORT $LN29@TryParseX
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN38@TryParseX
$LN29@TryParseX:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	eax, 2
	mov	DWORD PTR _state$1[ebp], eax
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 9
	jae	SHORT $LL24@TryParseX
$LN38@TryParseX:

; 294  :     if (*state.IN_PTR != L'\0')

	cmp	WORD PTR [eax], 0
	je	SHORT $LN12@TryParseX

; 295  :         return (0);

	xor	edi, edi
	jmp	SHORT $LN9@TryParseX
$LN12@TryParseX:

; 102  :     *state->INT_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$1[ebp+72]
	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 103  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR _state$1[ebp+4], 32		; 00000020H
	je	SHORT $LN33@TryParseX

; 104  :         *state->FRAC_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$1[ebp+76]
	mov	WORD PTR [eax], cx
$LN33@TryParseX:

; 297  :     return (1);

	mov	edi, 1
$LN9@TryParseX:

; 975  :     int result_parsing = ParseAsHexNumberString(source, number_styles, format_option, int_part_buf);
; 976  :     if ((result = CheckBlockLight((__UNIT_TYPE*)int_part_buf, int_part_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _int_part_buf_code$[ebp]
	push	esi
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	$LN1@TryParseX

; 977  :         return (result);
; 978  :     if (!result_parsing || int_part_buf[0] == L'\0')

	test	edi, edi
	je	$LN5@TryParseX
	cmp	WORD PTR [esi], ax
	je	$LN5@TryParseX

; 982  :     }
; 983  :     __UNIT_TYPE o_bit_count = lstrlenW(int_part_buf) * 4;

	push	esi
	call	DWORD PTR __imp__lstrlenW@4

; 984  :     __UNIT_TYPE o_light_check_code;
; 985  :     if ((result = AllocateNumber(o, o_bit_count, &o_light_check_code)) != PMC_STATUS_OK)

	mov	ebx, DWORD PTR _o$GSCopy$1$[ebp]
	lea	ecx, DWORD PTR _o_light_check_code$[ebp]
	push	ecx
	shl	eax, 2
	push	eax
	push	ebx
	call	_AllocateNumber
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN6@TryParseX

; 986  :     {
; 987  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	push	DWORD PTR _int_part_buf_words$[ebp]
	push	esi
	call	_DeallocateBlock

; 996  : }

	add	esp, 8
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@TryParseX:

; 988  :         return (result);
; 989  :     }
; 990  :     BuildBinaryFromHexString(int_part_buf, (*o)->BLOCK);

	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [eax+24]
	push	esi
	call	_BuildBinaryFromHexString

; 991  :     if ((result = CheckBlockLight((*o)->BLOCK, o_light_check_code)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR _o_light_check_code$[ebp]
	push	DWORD PTR [eax+24]
	call	_CheckBlockLight
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@TryParseX

; 992  :         return (result);
; 993  :     DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	push	DWORD PTR _int_part_buf_words$[ebp]
	push	esi
	call	_DeallocateBlock

; 994  :     CommitNumber(*o);

	push	DWORD PTR [ebx]
	call	_CommitNumber
	add	esp, 12					; 0000000cH

; 995  :     return (PMC_STATUS_OK);

	xor	eax, eax
	pop	edi

; 996  : }

	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@TryParseX:

; 979  :     {
; 980  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	push	DWORD PTR _int_part_buf_words$[ebp]
	push	esi
	call	_DeallocateBlock

; 981  :         return (PMC_STATUS_PARSING_ERROR);

	mov	eax, 1

; 996  : }

	add	esp, 8
$LN1@TryParseX:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TryParseX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _BuildBinaryFromHexString
_TEXT	SEGMENT
_in_ptr$1$ = -20					; size = 4
tv478 = -16						; size = 4
tv479 = -12						; size = 4
tv477 = -8						; size = 4
_r$1$ = -8						; size = 4
tv487 = -4						; size = 4
_source_count$1$ = -4					; size = 4
_source$ = 8						; size = 4
_out_ptr$1$ = 12					; size = 4
_out_buf$ = 12						; size = 4
_BuildBinaryFromHexString PROC				; COMDAT

; 946  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx

; 948  :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	ebx, DWORD PTR _source$[ebp]
	push	esi
	push	edi
	push	ebx
	call	DWORD PTR __imp__lstrlenW@4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 475  :     return ((u + v - 1) / v);

	mov	ecx, DWORD PTR _out_buf$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 948  :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	esi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 475  :     return ((u + v - 1) / v);

	sub	ecx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 948  :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	DWORD PTR _source_count$1$[ebp], esi

; 951  :     int r = source_count % word_digit_count;

	mov	edi, esi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 475  :     return ((u + v - 1) / v);

	lea	eax, DWORD PTR [esi+7]
	shr	eax, 3
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 951  :     int r = source_count % word_digit_count;

	and	edi, 7
	mov	DWORD PTR _r$1$[ebp], edi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 475  :     return ((u + v - 1) / v);

	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _out_ptr$1$[ebp], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 952  :     if (r > 0)

	jle	SHORT $LN35@BuildBinar

; 900  :     __UNIT_TYPE x = Parse1DigitFromHexChar(*in_ptr);

	movzx	eax, WORD PTR [ebx]
	push	eax
	call	_Parse1DigitFromHexChar
	add	esp, 4

; 901  :     ++in_ptr;

	lea	edx, DWORD PTR [ebx+2]
	mov	ecx, eax

; 902  :     --count;

	add	edi, -1

; 903  :     while (count > 0)

	je	SHORT $LN10@BuildBinar
	npad	6
$LL9@BuildBinar:

; 904  :     {
; 905  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr);

	movzx	esi, WORD PTR [edx]

; 866  :     switch (c)

	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 54					; 00000036H
	ja	SHORT $LN18@BuildBinar
	movzx	eax, BYTE PTR $LN42@BuildBinar[eax]
	jmp	DWORD PTR $LN45@BuildBinar[eax*4]
$LN15@BuildBinar:

; 867  :     {
; 868  :     case L'0':
; 869  :     case L'1':
; 870  :     case L'2':
; 871  :     case L'3':
; 872  :     case L'4':
; 873  :     case L'5':
; 874  :     case L'6':
; 875  :     case L'7':
; 876  :     case L'8':
; 877  :     case L'9':
; 878  :         return (c - L'0');

	lea	eax, DWORD PTR [esi-48]
	jmp	SHORT $LN12@BuildBinar
$LN16@BuildBinar:

; 879  :     case L'a':
; 880  :     case L'b':
; 881  :     case L'c':
; 882  :     case L'd':
; 883  :     case L'e':
; 884  :     case L'f':
; 885  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [esi-87]
	jmp	SHORT $LN12@BuildBinar
$LN17@BuildBinar:

; 886  :     case L'A':
; 887  :     case L'B':
; 888  :     case L'C':
; 889  :     case L'D':
; 890  :     case L'E':
; 891  :     case L'F':
; 892  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [esi-55]
	jmp	SHORT $LN12@BuildBinar
$LN18@BuildBinar:

; 893  :     default:
; 894  :         return ((_UINT32_T)-1);

	or	eax, -1
$LN12@BuildBinar:

; 905  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr);

	shl	ecx, 4

; 906  :         ++in_ptr;

	add	edx, 2
	add	ecx, eax

; 907  :         --count;

	sub	edi, 1
	jne	SHORT $LL9@BuildBinar
	mov	esi, DWORD PTR _source_count$1$[ebp]
$LN10@BuildBinar:

; 953  :     {
; 954  :         *out_ptr-- = BuildLeading1WordFromHexString(in_ptr, r);

	mov	eax, DWORD PTR _out_ptr$1$[ebp]
	mov	DWORD PTR [eax], ecx
	sub	eax, 4
	mov	DWORD PTR _out_ptr$1$[ebp], eax

; 955  :         in_ptr += r;

	mov	eax, DWORD PTR _r$1$[ebp]

; 956  :         source_count -= r;

	sub	esi, eax
	lea	ebx, DWORD PTR [ebx+eax*2]
	mov	DWORD PTR _source$[ebp], ebx
$LN35@BuildBinar:

; 957  :     }
; 958  :     while (source_count > 0)

	test	esi, esi
	je	$LN3@BuildBinar
	lea	ecx, DWORD PTR [esi-1]
	shr	ecx, 3
	inc	ecx
	mov	DWORD PTR tv487[ebp], ecx
$LL2@BuildBinar:

; 914  :     __UNIT_TYPE x = Parse1DigitFromHexChar(*in_ptr++);

	movzx	esi, WORD PTR [ebx]

; 866  :     switch (c)

	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 54					; 00000036H
	ja	SHORT $LN32@BuildBinar
	movzx	eax, BYTE PTR $LN43@BuildBinar[eax]
	jmp	DWORD PTR $LN46@BuildBinar[eax*4]
$LN29@BuildBinar:

; 867  :     {
; 868  :     case L'0':
; 869  :     case L'1':
; 870  :     case L'2':
; 871  :     case L'3':
; 872  :     case L'4':
; 873  :     case L'5':
; 874  :     case L'6':
; 875  :     case L'7':
; 876  :     case L'8':
; 877  :     case L'9':
; 878  :         return (c - L'0');

	shl	esi, 4
	sub	esi, 768				; 00000300H
	jmp	SHORT $LN26@BuildBinar
$LN30@BuildBinar:

; 879  :     case L'a':
; 880  :     case L'b':
; 881  :     case L'c':
; 882  :     case L'd':
; 883  :     case L'e':
; 884  :     case L'f':
; 885  :         return (c - L'a' + 10);

	shl	esi, 4
	sub	esi, 1392				; 00000570H
	jmp	SHORT $LN26@BuildBinar
$LN31@BuildBinar:

; 886  :     case L'A':
; 887  :     case L'B':
; 888  :     case L'C':
; 889  :     case L'D':
; 890  :     case L'E':
; 891  :     case L'F':
; 892  :         return (c - L'A' + 10);

	shl	esi, 4
	sub	esi, 880				; 00000370H
	jmp	SHORT $LN26@BuildBinar
$LN32@BuildBinar:

; 893  :     default:
; 894  :         return ((_UINT32_T)-1);

	mov	esi, -16				; fffffff0H
$LN26@BuildBinar:

; 931  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	movzx	ecx, WORD PTR [ebx+8]
	lea	edx, DWORD PTR [ebx+2]
	movzx	eax, WORD PTR [edx]
	movzx	edi, WORD PTR [edx+2]
	movzx	ebx, WORD PTR [edx+4]
	mov	DWORD PTR tv479[ebp], ecx

; 932  :     }
; 933  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 934  :     {
; 935  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	movzx	ecx, WORD PTR [edx+8]
	add	edx, 10					; 0000000aH
	push	eax
	mov	DWORD PTR tv478[ebp], ecx
	mov	DWORD PTR _in_ptr$1$[ebp], edx
	call	_Parse1DigitFromHexChar

; 936  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 937  :     }
; 938  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 939  :     {
; 940  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	add	eax, esi
	mov	esi, eax
	mov	DWORD PTR tv477[ebp], eax
	push	edi
	shl	esi, 4
	call	_Parse1DigitFromHexChar
	add	esi, eax
	push	ebx
	shl	esi, 4
	call	_Parse1DigitFromHexChar
	push	DWORD PTR tv479[ebp]
	add	esi, eax
	shl	esi, 4
	call	_Parse1DigitFromHexChar
	push	DWORD PTR tv478[ebp]
	add	esi, eax
	shl	esi, 4
	call	_Parse1DigitFromHexChar
	mov	edi, DWORD PTR _in_ptr$1$[ebp]
	add	esi, eax
	shl	esi, 4
	movzx	eax, WORD PTR [edi]
	push	eax
	call	_Parse1DigitFromHexChar
	add	esi, eax
	movzx	eax, WORD PTR [edi+2]
	push	eax
	shl	esi, 4
	call	_Parse1DigitFromHexChar

; 959  :     {
; 960  :         *out_ptr-- = Build1WordFromHexString(in_ptr);

	mov	edx, DWORD PTR _out_ptr$1$[ebp]

; 940  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	add	esi, eax

; 961  :         in_ptr += word_digit_count;

	mov	ebx, DWORD PTR _source$[ebp]

; 940  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	add	esp, 28					; 0000001cH

; 961  :         in_ptr += word_digit_count;

	add	ebx, 16					; 00000010H
	mov	DWORD PTR _source$[ebp], ebx
	mov	DWORD PTR [edx], esi
	sub	edx, 4
	sub	DWORD PTR tv487[ebp], 1
	mov	DWORD PTR _out_ptr$1$[ebp], edx
	jne	$LL2@BuildBinar
$LN3@BuildBinar:
	pop	edi

; 962  :         source_count -= word_digit_count;
; 963  :     }
; 964  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN45@BuildBinar:
	DD	$LN15@BuildBinar
	DD	$LN17@BuildBinar
	DD	$LN16@BuildBinar
	DD	$LN18@BuildBinar
$LN42@BuildBinar:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	npad	1
$LN46@BuildBinar:
	DD	$LN29@BuildBinar
	DD	$LN31@BuildBinar
	DD	$LN30@BuildBinar
	DD	$LN32@BuildBinar
$LN43@BuildBinar:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
_BuildBinaryFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _Build1WordFromHexString
_TEXT	SEGMENT
tv174 = -12						; size = 4
tv175 = -8						; size = 4
tv173 = -4						; size = 4
_in_ptr$ = 8						; size = 4
_Build1WordFromHexString PROC				; COMDAT

; 913  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 914  :     __UNIT_TYPE x = Parse1DigitFromHexChar(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	push	ebx
	push	esi
	push	edi
	movzx	eax, WORD PTR [edx]
	add	edx, 2
	push	eax

; 915  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))
; 916  :     {
; 917  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 918  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 919  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 920  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 921  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 922  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 923  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 924  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 925  :     }
; 926  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))
; 927  :     {
; 928  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 929  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 930  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 931  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	movzx	ecx, WORD PTR [edx+6]
	movzx	esi, WORD PTR [edx]
	movzx	edi, WORD PTR [edx+2]
	movzx	ebx, WORD PTR [edx+4]
	mov	DWORD PTR tv175[ebp], ecx

; 932  :     }
; 933  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 934  :     {
; 935  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	movzx	ecx, WORD PTR [edx+8]
	add	edx, 10					; 0000000aH
	mov	DWORD PTR tv174[ebp], ecx
	mov	DWORD PTR _in_ptr$[ebp], edx
	call	_Parse1DigitFromHexChar
	shl	eax, 4
	push	esi
	mov	DWORD PTR tv173[ebp], eax
	call	_Parse1DigitFromHexChar

; 936  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);
; 937  :     }
; 938  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 939  :     {
; 940  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	esi, DWORD PTR tv173[ebp]
	add	esi, eax
	push	edi
	shl	esi, 4
	call	_Parse1DigitFromHexChar
	add	esi, eax
	push	ebx
	shl	esi, 4
	call	_Parse1DigitFromHexChar
	push	DWORD PTR tv175[ebp]
	add	esi, eax
	shl	esi, 4
	call	_Parse1DigitFromHexChar
	push	DWORD PTR tv174[ebp]
	add	esi, eax
	shl	esi, 4
	call	_Parse1DigitFromHexChar
	mov	edi, DWORD PTR _in_ptr$[ebp]
	add	esi, eax
	shl	esi, 4
	movzx	eax, WORD PTR [edi]
	push	eax
	call	_Parse1DigitFromHexChar
	add	esi, eax
	movzx	eax, WORD PTR [edi+2]
	push	eax
	shl	esi, 4
	call	_Parse1DigitFromHexChar
	add	esp, 32					; 00000020H
	add	eax, esi

; 941  :     }
; 942  :     return (x);

	pop	edi
	pop	esi
	pop	ebx

; 943  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Build1WordFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _BuildLeading1WordFromHexString
_TEXT	SEGMENT
_in_ptr$ = 8						; size = 4
_count$ = 12						; size = 4
_BuildLeading1WordFromHexString PROC			; COMDAT

; 899  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 900  :     __UNIT_TYPE x = Parse1DigitFromHexChar(*in_ptr);

	mov	esi, DWORD PTR _in_ptr$[ebp]
	push	edi
	movzx	eax, WORD PTR [esi]
	push	eax
	call	_Parse1DigitFromHexChar

; 901  :     ++in_ptr;
; 902  :     --count;

	mov	edi, DWORD PTR _count$[ebp]
	add	esp, 4
	add	esi, 2
	mov	edx, eax
	sub	edi, 1

; 903  :     while (count > 0)

	je	SHORT $LN3@BuildLeadi
$LL2@BuildLeadi:

; 904  :     {
; 905  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr);

	movzx	ecx, WORD PTR [esi]

; 866  :     switch (c)

	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 54					; 00000036H
	ja	SHORT $LN11@BuildLeadi
	movzx	eax, BYTE PTR $LN17@BuildLeadi[eax]
	jmp	DWORD PTR $LN20@BuildLeadi[eax*4]
$LN8@BuildLeadi:

; 867  :     {
; 868  :     case L'0':
; 869  :     case L'1':
; 870  :     case L'2':
; 871  :     case L'3':
; 872  :     case L'4':
; 873  :     case L'5':
; 874  :     case L'6':
; 875  :     case L'7':
; 876  :     case L'8':
; 877  :     case L'9':
; 878  :         return (c - L'0');

	lea	eax, DWORD PTR [ecx-48]
	jmp	SHORT $LN5@BuildLeadi
$LN9@BuildLeadi:

; 879  :     case L'a':
; 880  :     case L'b':
; 881  :     case L'c':
; 882  :     case L'd':
; 883  :     case L'e':
; 884  :     case L'f':
; 885  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [ecx-87]
	jmp	SHORT $LN5@BuildLeadi
$LN10@BuildLeadi:

; 886  :     case L'A':
; 887  :     case L'B':
; 888  :     case L'C':
; 889  :     case L'D':
; 890  :     case L'E':
; 891  :     case L'F':
; 892  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [ecx-55]
	jmp	SHORT $LN5@BuildLeadi
$LN11@BuildLeadi:

; 893  :     default:
; 894  :         return ((_UINT32_T)-1);

	or	eax, -1
$LN5@BuildLeadi:

; 904  :     {
; 905  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr);

	shl	edx, 4

; 906  :         ++in_ptr;

	add	esi, 2
	add	edx, eax

; 907  :         --count;

	sub	edi, 1
	jne	SHORT $LL2@BuildLeadi

; 908  :     }
; 909  :     return (x);

	mov	eax, edx
$LN3@BuildLeadi:
	pop	edi

; 910  : }

	pop	esi
	pop	ebp
	ret	0
	npad	1
$LN20@BuildLeadi:
	DD	$LN8@BuildLeadi
	DD	$LN10@BuildLeadi
	DD	$LN9@BuildLeadi
	DD	$LN11@BuildLeadi
$LN17@BuildLeadi:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
_BuildLeading1WordFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _Parse1DigitFromHexChar
_TEXT	SEGMENT
_c$ = 8							; size = 2
_Parse1DigitFromHexChar PROC				; COMDAT

; 865  : {

	push	ebp
	mov	ebp, esp

; 866  :     switch (c)

	movzx	edx, WORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx-48]
	cmp	eax, 54					; 00000036H
	ja	SHORT $LN7@Parse1Digi
	movzx	ecx, BYTE PTR $LN9@Parse1Digi[eax]
	jmp	DWORD PTR $LN11@Parse1Digi[ecx*4]
$LN5@Parse1Digi:

; 867  :     {
; 868  :     case L'0':
; 869  :     case L'1':
; 870  :     case L'2':
; 871  :     case L'3':
; 872  :     case L'4':
; 873  :     case L'5':
; 874  :     case L'6':
; 875  :     case L'7':
; 876  :     case L'8':
; 877  :     case L'9':
; 878  :         return (c - L'0');
; 879  :     case L'a':
; 880  :     case L'b':
; 881  :     case L'c':
; 882  :     case L'd':
; 883  :     case L'e':
; 884  :     case L'f':
; 885  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [edx-87]

; 895  :     }
; 896  : }

	pop	ebp
	ret	0
$LN6@Parse1Digi:

; 886  :     case L'A':
; 887  :     case L'B':
; 888  :     case L'C':
; 889  :     case L'D':
; 890  :     case L'E':
; 891  :     case L'F':
; 892  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [edx-55]

; 895  :     }
; 896  : }

	pop	ebp
	ret	0
$LN7@Parse1Digi:

; 893  :     default:
; 894  :         return ((_UINT32_T)-1);

	or	eax, -1
$LN1@Parse1Digi:

; 895  :     }
; 896  : }

	pop	ebp
	ret	0
$LN11@Parse1Digi:
	DD	$LN1@Parse1Digi
	DD	$LN6@Parse1Digi
	DD	$LN5@Parse1Digi
	DD	$LN7@Parse1Digi
$LN9@Parse1Digi:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
_Parse1DigitFromHexChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _TryParseDN
_TEXT	SEGMENT
_no_light_check_code$ = -60				; size = 4
_bin_buf_code$ = -56					; size = 4
_result$4$ = -52					; size = 4
_int_part_buf$1$ = -52					; size = 4
_work_buf_code$1 = -52					; size = 4
_in_ptr$1$ = -48					; size = 4
_out_buf$1$ = -48					; size = 4
tv976 = -44						; size = 4
_work_buf_words$2 = -44					; size = 4
_work_buf$1$ = -40					; size = 4
_r$1$ = -40						; size = 4
tv977 = -40						; size = 4
_frac_part_buf_code$ = -36				; size = 4
_int_part_buf_code$ = -32				; size = 4
_source_count$1$ = -28					; size = 4
_in_buf_count$1$ = -28					; size = 4
tv997 = -28						; size = 4
_result_parsing$1$ = -28				; size = 4
_bin_buf_words$ = -24					; size = 4
_bin_buf$1$ = -20					; size = 4
_sign$ = -20						; size = 4
_bin_buf_count$1$ = -16					; size = 4
_result$5$ = -16					; size = 4
_in_ptr$1$ = -12					; size = 4
_frac_part_buf_words$ = -8				; size = 4
_int_part_buf_words$ = -4				; size = 4
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o$ = 20						; size = 4
_TryParseDN PROC					; COMDAT

; 721  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	push	edi

; 722  :     PMC_STATUS_CODE result;
; 723  : #ifdef _M_IX86
; 724  :     int word_digit_count = 9;
; 725  : #elif defined(_M_IX64)
; 726  :     int word_digit_count = 19;
; 727  : #else
; 728  : #error unknown platform
; 729  : #endif
; 730  :     __UNIT_TYPE source_len = lstrlenW(source);

	push	DWORD PTR _source$[ebp]
	mov	edi, DWORD PTR __imp__lstrlenW@4
	call	edi

; 731  : 
; 732  :     __UNIT_TYPE int_part_buf_code;
; 733  :     __UNIT_TYPE int_part_buf_words;
; 734  :     wchar_t* int_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &int_part_buf_words, &int_part_buf_code);

	lea	esi, DWORD PTR [eax+1]
	lea	eax, DWORD PTR _int_part_buf_code$[ebp]
	shl	esi, 4
	push	eax
	lea	eax, DWORD PTR _int_part_buf_words$[ebp]
	push	eax
	push	esi
	call	_AllocateBlock
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _int_part_buf$1$[ebp], ebx

; 735  :     if (int_part_buf == NULL)

	test	ebx, ebx
	je	SHORT $LN87@TryParseDN

; 736  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 737  : 
; 738  :     __UNIT_TYPE frac_part_buf_code;
; 739  :     __UNIT_TYPE frac_part_buf_words;
; 740  :     wchar_t* frac_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &frac_part_buf_words, &frac_part_buf_code);

	lea	eax, DWORD PTR _frac_part_buf_code$[ebp]
	push	eax
	lea	eax, DWORD PTR _frac_part_buf_words$[ebp]
	push	eax
	push	esi
	call	_AllocateBlock
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 741  :     if (frac_part_buf == NULL)

	test	esi, esi
	jne	SHORT $LN10@TryParseDN
$LN88@TryParseDN:

; 861  : }

	push	DWORD PTR _int_part_buf_words$[ebp]
	push	ebx
	call	_DeallocateBlock
	add	esp, 8
$LN87@TryParseDN:
	pop	edi
	pop	esi
	mov	eax, -5					; fffffffbH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@TryParseDN:

; 742  :     {
; 743  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 744  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 745  :     }
; 746  :     int sign;
; 747  :     int result_parsing = ParseAsDecimalNumberString(source, number_styles, format_option, &sign, int_part_buf, frac_part_buf);

	push	esi
	push	ebx
	lea	eax, DWORD PTR _sign$[ebp]
	push	eax
	push	DWORD PTR _format_option$[ebp]
	push	DWORD PTR _number_styles$[ebp]
	push	DWORD PTR _source$[ebp]
	call	_ParseAsDecimalNumberString

; 748  :     if ((result = CheckBlockLight((__UNIT_TYPE*)int_part_buf, int_part_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _int_part_buf_code$[ebp]
	mov	DWORD PTR _result_parsing$1$[ebp], eax
	push	ebx
	call	_CheckBlockLight
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	$LN1@TryParseDN

; 749  :         return (result);
; 750  :     if ((result = CheckBlockLight((__UNIT_TYPE*)frac_part_buf, frac_part_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _frac_part_buf_code$[ebp]
	push	esi
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	$LN1@TryParseDN

; 751  :         return (result);
; 752  :     if (!result_parsing)

	cmp	DWORD PTR _result_parsing$1$[ebp], eax
	je	SHORT $LN89@TryParseDN

; 753  :     {
; 754  :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);
; 755  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 756  :         return (PMC_STATUS_PARSING_ERROR);
; 757  :     }
; 758  :     // 整数部と小数部がともに空ならばエラーとする
; 759  :     if (int_part_buf[0] == L'\0' && frac_part_buf[0] == L'\0')

	movzx	eax, WORD PTR [ebx]
	test	ax, ax
	jne	SHORT $LN73@TryParseDN
	cmp	WORD PTR [esi], ax
	jne	SHORT $LN60@TryParseDN
$LN89@TryParseDN:

; 861  : }

	push	DWORD PTR _frac_part_buf_words$[ebp]
	push	esi
	call	_DeallocateBlock
	push	DWORD PTR _int_part_buf_words$[ebp]
	push	ebx
	call	_DeallocateBlock
	add	esp, 16					; 00000010H
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@TryParseDN:

; 760  :     {
; 761  :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);
; 762  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 763  :         return (PMC_STATUS_PARSING_ERROR);
; 764  :     }
; 765  : 
; 766  :     if (int_part_buf[0] == L'0')

	cmp	eax, 48					; 00000030H
	jne	SHORT $LN60@TryParseDN

; 767  :     {
; 768  :         // 整数部の先行する 0 を削除する
; 769  :         wchar_t* s_ptr = int_part_buf;

	mov	eax, ebx

; 770  :         wchar_t* d_ptr = int_part_buf;

	mov	edx, ebx
	npad	2
$LL2@TryParseDN:

; 771  :         while (*s_ptr == L'0')

	movzx	ecx, WORD PTR [eax+2]

; 772  :             ++s_ptr;

	add	eax, 2
	cmp	ecx, 48					; 00000030H
	je	SHORT $LL2@TryParseDN

; 773  :         for (;;)
; 774  :         {
; 775  :             *d_ptr = *s_ptr;

	mov	WORD PTR [ebx], cx

; 776  :             if (*s_ptr == L'\0')

	cmp	WORD PTR [eax], 0
	je	SHORT $LN60@TryParseDN
$LL4@TryParseDN:

; 773  :         for (;;)
; 774  :         {
; 775  :             *d_ptr = *s_ptr;

	mov	cx, WORD PTR [eax+2]

; 777  :                 break;
; 778  :             ++s_ptr;

	lea	eax, DWORD PTR [eax+2]

; 779  :             ++d_ptr;

	lea	edx, DWORD PTR [edx+2]
	mov	WORD PTR [edx], cx
	cmp	WORD PTR [eax], 0
	jne	SHORT $LL4@TryParseDN
$LN60@TryParseDN:

; 780  :         }
; 781  :     }
; 782  : 
; 783  :     // 小数部の末尾の 0 を削除する
; 784  :     wchar_t* frac_ptr = frac_part_buf + lstrlenW(frac_part_buf);

	push	esi
	call	edi
	lea	eax, DWORD PTR [esi+eax*2]

; 785  :     while (frac_ptr > frac_part_buf && frac_ptr[-1] == L'0')

	cmp	eax, esi
	jbe	SHORT $LN84@TryParseDN
$LL7@TryParseDN:
	cmp	WORD PTR [eax-2], 48			; 00000030H
	jne	SHORT $LN84@TryParseDN

; 786  :         --frac_ptr;

	add	eax, -2					; fffffffeH
	cmp	eax, esi
	ja	SHORT $LL7@TryParseDN
$LN84@TryParseDN:

; 787  :     *frac_ptr = L'\0';

	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 788  : 
; 789  :     // 小数部が 0 ではない場合、エラーとする
; 790  :     if (frac_part_buf[0] != L'\0')

	cmp	WORD PTR [esi], cx
	jne	SHORT $LN89@TryParseDN

; 791  :     {
; 792  :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);
; 793  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 794  :         return (PMC_STATUS_PARSING_ERROR);
; 795  :     }
; 796  : 
; 797  :     if (sign < 0)

	movzx	eax, WORD PTR [ebx]
	cmp	DWORD PTR _sign$[ebp], ecx
	jge	SHORT $LN74@TryParseDN

; 798  :     {
; 799  :         if (int_part_buf[0] == L'\0')

	test	ax, ax
	je	SHORT $LN82@TryParseDN

; 800  :         {
; 801  :             // - 符号が与えられていてかつ整数部が 0 であるなら符号を修正する
; 802  :             sign = 0;
; 803  :         }
; 804  :         else
; 805  :         {
; 806  :             // - 符号が与えられていてかつ整数部が 0 ではないなら、エラーとする
; 807  :             DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	push	DWORD PTR _frac_part_buf_words$[ebp]
	push	esi
	call	_DeallocateBlock

; 808  :             DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	push	DWORD PTR _int_part_buf_words$[ebp]
	push	ebx
	call	_DeallocateBlock
	add	esp, 16					; 00000010H

; 809  :             return (PMC_STATUS_OVERFLOW);

	mov	eax, -2					; fffffffeH
	pop	edi

; 861  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@TryParseDN:

; 810  :         }
; 811  :     }
; 812  : 
; 813  :     // 整数部が空である場合、1桁の 0 を設定する
; 814  :     if (int_part_buf[0] == L'\0')

	test	ax, ax
	jne	SHORT $LN21@TryParseDN
$LN82@TryParseDN:

; 815  :     {
; 816  :         int_part_buf[0] = L'0';

	mov	DWORD PTR [ebx], 48			; 00000030H
$LN21@TryParseDN:

; 817  :         int_part_buf[1] = L'\0';
; 818  :     }
; 819  : 
; 820  :     // 小数部は捨てる
; 821  :     DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	push	DWORD PTR _frac_part_buf_words$[ebp]
	push	esi
	call	_DeallocateBlock
	add	esp, 8

; 825  :     __UNIT_TYPE* bin_buf = AllocateBlock(_DIVIDE_CEILING_SIZE(lstrlenW(int_part_buf), word_digit_count) * __UNIT_TYPE_BIT_COUNT, &bin_buf_words, &bin_buf_code);

	push	ebx
	call	edi
	lea	ecx, DWORD PTR _bin_buf_code$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _bin_buf_words$[ebp]
	push	ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 480  :     return ((u + v - 1) / v);

	lea	ecx, DWORD PTR [eax+8]
	mov	eax, 954437177				; 38e38e39H
	mul	ecx
	shr	edx, 1
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 825  :     __UNIT_TYPE* bin_buf = AllocateBlock(_DIVIDE_CEILING_SIZE(lstrlenW(int_part_buf), word_digit_count) * __UNIT_TYPE_BIT_COUNT, &bin_buf_words, &bin_buf_code);

	shl	edx, 5
	push	edx
	call	_AllocateBlock
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bin_buf$1$[ebp], edi

; 826  :     if (bin_buf == NULL)

	test	edi, edi
	je	$LN88@TryParseDN

; 358  :     __UNIT_TYPE* out_ptr = out_buf;

	mov	esi, edi
	mov	DWORD PTR _in_ptr$1$[ebp], ebx

; 359  :     __UNIT_TYPE source_count = lstrlenW(source);

	push	ebx
	mov	DWORD PTR _bin_buf_count$1$[ebp], esi
	call	DWORD PTR __imp__lstrlenW@4

; 360  :     int r = source_count % word_digit_count;

	xor	edx, edx
	mov	DWORD PTR _source_count$1$[ebp], eax
	mov	ecx, 9
	div	ecx
	mov	ecx, edx
	mov	DWORD PTR _r$1$[ebp], ecx

; 361  :     if (r > 0)

	test	ecx, ecx
	jle	SHORT $LN85@TryParseDN

; 302  :     __UNIT_TYPE x = 0;

	xor	eax, eax

; 363  :         *out_ptr++ = BuildLeading1WordFromDecimalString(in_ptr, r);

	mov	esi, ebx

; 303  :     while (count > 0)

	test	ecx, ecx
	je	SHORT $LN38@TryParseDN
	npad	5
$LL37@TryParseDN:

; 304  :     {
; 305  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -48				; ffffffd0H

; 306  :         --count;

	sub	edx, 1
	jne	SHORT $LL37@TryParseDN
	mov	ecx, DWORD PTR _r$1$[ebp]
$LN38@TryParseDN:

; 363  :         *out_ptr++ = BuildLeading1WordFromDecimalString(in_ptr, r);

	mov	DWORD PTR [edi], eax
	lea	esi, DWORD PTR [edi+4]

; 364  :         in_ptr += r;

	lea	eax, DWORD PTR [ebx+ecx*2]
	mov	DWORD PTR _bin_buf_count$1$[ebp], esi
	mov	DWORD PTR _in_ptr$1$[ebp], eax

; 365  :         source_count -= r;

	mov	eax, DWORD PTR _source_count$1$[ebp]
	sub	eax, ecx
	jmp	SHORT $LN83@TryParseDN
$LN85@TryParseDN:

; 361  :     if (r > 0)

	mov	eax, DWORD PTR _source_count$1$[ebp]
$LN83@TryParseDN:

; 366  :     }
; 367  :     while (source_count > 0)

	test	eax, eax
	je	$LN33@TryParseDN
	lea	ecx, DWORD PTR [eax-1]
	mov	eax, 954437177				; 38e38e39H
	mul	ecx
	mov	eax, edx
	shr	eax, 1
	inc	eax
	mov	DWORD PTR tv997[ebp], eax
	mov	eax, DWORD PTR _in_ptr$1$[ebp]
	npad	4
$LL32@TryParseDN:

; 329  :         x = x * 10 + (*in_ptr++ - L'0');

	movzx	esi, WORD PTR [eax+2]
	lea	ecx, DWORD PTR [eax+2]

; 330  :         x = x * 10 + (*in_ptr++ - L'0');
; 331  :         x = x * 10 + (*in_ptr++ - L'0');
; 332  :         x = x * 10 + (*in_ptr++ - L'0');
; 333  :         x = x * 10 + (*in_ptr++ - L'0');

	movzx	eax, WORD PTR [ecx+8]
	movzx	edx, WORD PTR [ecx+2]
	movzx	edi, WORD PTR [ecx+4]
	movzx	ebx, WORD PTR [ecx+6]
	mov	DWORD PTR tv977[ebp], eax

; 334  :     }
; 335  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 336  :     {
; 337  :         x = x * 10 + (*in_ptr++ - L'0');

	movzx	eax, WORD PTR [ecx+10]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR tv976[ebp], eax
	mov	eax, DWORD PTR _in_ptr$1$[ebp]
	mov	DWORD PTR _in_ptr$1$[ebp], ecx
	movzx	eax, WORD PTR [eax]

; 338  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	ecx, DWORD PTR [eax+eax*4]

; 339  :     }
; 340  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 341  :     {
; 342  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	eax, DWORD PTR [esi+ecx*2]

; 369  :         *out_ptr++ = Build1WordFromDecimalString(in_ptr);

	mov	esi, DWORD PTR _bin_buf_count$1$[ebp]

; 342  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	edx, DWORD PTR _in_ptr$1$[ebp]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edi+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ebx+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR tv977[ebp]
	movzx	eax, ax
	lea	eax, DWORD PTR [eax+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR tv976[ebp]
	movzx	eax, ax
	lea	eax, DWORD PTR [eax+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [edx]
	lea	eax, DWORD PTR [eax+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [edx+2]
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -1038366032			; c21bcab0H

; 369  :         *out_ptr++ = Build1WordFromDecimalString(in_ptr);

	mov	DWORD PTR [esi], eax
	add	esi, 4

; 370  :         in_ptr += word_digit_count;

	mov	eax, DWORD PTR _in_ptr$1$[ebp]
	add	eax, 18					; 00000012H
	mov	DWORD PTR _bin_buf_count$1$[ebp], esi
	sub	DWORD PTR tv997[ebp], 1
	mov	DWORD PTR _in_ptr$1$[ebp], eax
	jne	$LL32@TryParseDN
	mov	ebx, DWORD PTR _int_part_buf$1$[ebp]
	mov	edi, DWORD PTR _bin_buf$1$[ebp]
$LN33@TryParseDN:

; 827  :     {
; 828  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 829  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 830  :     }
; 831  :     __UNIT_TYPE bin_buf_count;
; 832  :     BuildBinaryFromDecimalString(int_part_buf, bin_buf, &bin_buf_count);
; 833  :     if ((result = CheckBlockLight(bin_buf, bin_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _bin_buf_code$[ebp]

; 373  :     *out_buf_count = out_ptr - out_buf;

	sub	esi, edi
	sar	esi, 2

; 827  :     {
; 828  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 829  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 830  :     }
; 831  :     __UNIT_TYPE bin_buf_count;
; 832  :     BuildBinaryFromDecimalString(int_part_buf, bin_buf, &bin_buf_count);
; 833  :     if ((result = CheckBlockLight(bin_buf, bin_buf_code)) != PMC_STATUS_OK)

	push	edi

; 373  :     *out_buf_count = out_ptr - out_buf;

	mov	DWORD PTR _bin_buf_count$1$[ebp], esi

; 827  :     {
; 828  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 829  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 830  :     }
; 831  :     __UNIT_TYPE bin_buf_count;
; 832  :     BuildBinaryFromDecimalString(int_part_buf, bin_buf, &bin_buf_count);
; 833  :     if ((result = CheckBlockLight(bin_buf, bin_buf_code)) != PMC_STATUS_OK)

	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	$LN1@TryParseDN

; 834  :         return (result);
; 835  :     DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	push	DWORD PTR _int_part_buf_words$[ebp]
	push	ebx
	call	_DeallocateBlock

; 836  : 
; 837  :     __UNIT_TYPE o_bit_count = bin_buf_count * __UNIT_TYPE_BIT_COUNT;
; 838  :     __UNIT_TYPE no_light_check_code;
; 839  :     if ((result = AllocateNumber(o, o_bit_count, &no_light_check_code)) != PMC_STATUS_OK)

	mov	ebx, DWORD PTR _o$[ebp]
	lea	eax, DWORD PTR _no_light_check_code$[ebp]
	push	eax
	shl	esi, 5
	push	esi
	push	ebx
	call	_AllocateNumber
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$4$[ebp], eax
	test	eax, eax
	je	SHORT $LN24@TryParseDN

; 840  :     {
; 841  :         DeallocateBlock(bin_buf, bin_buf_words);

	push	DWORD PTR _bin_buf_words$[ebp]
	push	edi
	call	_DeallocateBlock

; 842  :         return (result);

	mov	eax, DWORD PTR _result$4$[ebp]
	add	esp, 8
	pop	edi

; 861  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@TryParseDN:

; 843  :     }
; 844  : 
; 845  :     if ((result = ConvertCardinalNumber(bin_buf, bin_buf_count, (*o)->BLOCK)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _out_buf$1$[ebp], eax

; 697  :     __UNIT_TYPE* work_buf = AllocateBlock(__UNIT_TYPE_BIT_COUNT * (in_buf_count + 1), &work_buf_words, &work_buf_code);

	lea	eax, DWORD PTR _work_buf_code$1[ebp]
	push	eax
	lea	eax, DWORD PTR _work_buf_words$2[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+32]
	push	eax
	call	_AllocateBlock
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf$1$[ebp], esi

; 698  :     if (work_buf == NULL)

	test	esi, esi
	jne	SHORT $LN49@TryParseDN

; 699  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	lea	eax, DWORD PTR [esi-5]
	jmp	SHORT $LN86@TryParseDN
$LN49@TryParseDN:

; 700  : 
; 701  :     __UNIT_TYPE work_buf_count = 1;
; 702  :     work_buf[0] = in_buf[0];

	mov	eax, DWORD PTR [edi]
	mov	ebx, 1
	mov	DWORD PTR [esi], eax

; 703  :     ++in_buf;

	add	edi, 4

; 704  :     --in_buf_count;

	mov	eax, DWORD PTR _bin_buf_count$1$[ebp]
	add	eax, -1
	mov	DWORD PTR _in_buf_count$1$[ebp], eax

; 705  : 
; 706  :     while (in_buf_count > 0)

	je	SHORT $LN48@TryParseDN
$LL47@TryParseDN:

; 707  :     {
; 708  :         __UNIT_TYPE* w_tail = (*fp_MultiplyAndAdd)(work_buf, work_buf_count, *in_buf);

	push	DWORD PTR [edi]
	push	ebx
	push	esi
	call	DWORD PTR _fp_MultiplyAndAdd
	mov	ebx, eax

; 709  :         work_buf_count = w_tail - work_buf;
; 710  :         ++in_buf;

	lea	edi, DWORD PTR [edi+4]
	sub	ebx, esi
	add	esp, 12					; 0000000cH
	sar	ebx, 2

; 711  :         --in_buf_count;

	sub	DWORD PTR _in_buf_count$1$[ebp], 1
	jne	SHORT $LL47@TryParseDN
$LN48@TryParseDN:

; 712  :     }
; 713  :     if ((result = CheckBlockLight(work_buf, work_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _work_buf_code$1[ebp]
	push	esi
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$5$[ebp], eax
	test	eax, eax
	je	SHORT $LN50@TryParseDN

; 714  :         return (result);

	mov	edi, DWORD PTR _bin_buf$1$[ebp]
	mov	ebx, DWORD PTR _o$[ebp]
	jmp	SHORT $LN46@TryParseDN
$LN50@TryParseDN:

; 716  :     DeallocateBlock(work_buf, work_buf_words);

	push	DWORD PTR _work_buf_words$2[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 349  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, DWORD PTR _out_buf$1$[ebp]
	mov	ecx, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 716  :     DeallocateBlock(work_buf, work_buf_words);

	push	DWORD PTR _work_buf$1$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 349  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 716  :     DeallocateBlock(work_buf, work_buf_words);

	call	_DeallocateBlock
	mov	edi, DWORD PTR _bin_buf$1$[ebp]
	add	esp, 8
	mov	ebx, DWORD PTR _o$[ebp]

; 717  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN86@TryParseDN:

; 843  :     }
; 844  : 
; 845  :     if ((result = ConvertCardinalNumber(bin_buf, bin_buf_count, (*o)->BLOCK)) != PMC_STATUS_OK)

	mov	DWORD PTR _result$5$[ebp], eax
$LN46@TryParseDN:
	mov	ecx, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN25@TryParseDN

; 846  :     {
; 847  :         DeallocateNumber(*o);

	push	ecx
	call	_DeallocateNumber

; 848  :         DeallocateBlock(bin_buf, bin_buf_words);

	push	DWORD PTR _bin_buf_words$[ebp]
	push	edi
	call	_DeallocateBlock

; 849  :         return (result);

	mov	eax, DWORD PTR _result$5$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi

; 861  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@TryParseDN:

; 850  :     }
; 851  :     if ((result = CheckBlockLight((*o)->BLOCK, no_light_check_code)) != PMC_STATUS_OK)

	push	DWORD PTR _no_light_check_code$[ebp]
	push	DWORD PTR [ecx+24]
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@TryParseDN

; 852  :         return (result);
; 853  :     DeallocateBlock(bin_buf, bin_buf_words);

	push	DWORD PTR _bin_buf_words$[ebp]
	push	edi
	call	_DeallocateBlock

; 854  :     CommitNumber(*o);

	push	DWORD PTR [ebx]
	call	_CommitNumber

; 855  :     if ((*o)->IS_ZERO)

	mov	eax, DWORD PTR [ebx]
	add	esp, 12					; 0000000cH
	test	BYTE PTR [eax+16], 2
	je	SHORT $LN27@TryParseDN

; 856  :     {
; 857  :         DeallocateNumber(*o);

	push	eax
	call	_DeallocateNumber
	add	esp, 4

; 858  :         *o = &number_zero;

	mov	DWORD PTR [ebx], OFFSET _number_zero
$LN27@TryParseDN:

; 859  :     }
; 860  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@TryParseDN:
	pop	edi

; 861  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TryParseDN ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _ConvertCardinalNumber
_TEXT	SEGMENT
_work_buf_words$ = -12					; size = 4
_work_buf$1$ = -8					; size = 4
_work_buf_code$ = -4					; size = 4
_in_buf$ = 8						; size = 4
_in_buf_count$ = 12					; size = 4
_out_buf$ = 16						; size = 4
_ConvertCardinalNumber PROC				; COMDAT

; 693  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	edi

; 694  :     PMC_STATUS_CODE result;
; 695  :     __UNIT_TYPE work_buf_code;
; 696  :     __UNIT_TYPE work_buf_words;
; 697  :     __UNIT_TYPE* work_buf = AllocateBlock(__UNIT_TYPE_BIT_COUNT * (in_buf_count + 1), &work_buf_words, &work_buf_code);

	lea	eax, DWORD PTR _work_buf_code$[ebp]
	push	eax
	lea	eax, DWORD PTR _work_buf_words$[ebp]
	push	eax
	mov	eax, DWORD PTR _in_buf_count$[ebp]
	inc	eax
	shl	eax, 5
	push	eax
	call	_AllocateBlock
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf$1$[ebp], edi

; 698  :     if (work_buf == NULL)

	test	edi, edi
	jne	SHORT $LN4@ConvertCar

; 699  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	lea	eax, DWORD PTR [edi-5]
	pop	edi

; 718  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@ConvertCar:
	push	ebx
	push	esi

; 700  : 
; 701  :     __UNIT_TYPE work_buf_count = 1;
; 702  :     work_buf[0] = in_buf[0];

	mov	esi, DWORD PTR _in_buf$[ebp]
	mov	ebx, 1
	mov	eax, DWORD PTR [esi]

; 703  :     ++in_buf;

	add	esi, 4
	sub	DWORD PTR _in_buf_count$[ebp], ebx
	mov	DWORD PTR [edi], eax

; 704  :     --in_buf_count;
; 705  : 
; 706  :     while (in_buf_count > 0)

	je	SHORT $LN3@ConvertCar
$LL2@ConvertCar:

; 707  :     {
; 708  :         __UNIT_TYPE* w_tail = (*fp_MultiplyAndAdd)(work_buf, work_buf_count, *in_buf);

	push	DWORD PTR [esi]
	push	ebx
	push	edi
	call	DWORD PTR _fp_MultiplyAndAdd
	mov	ebx, eax

; 709  :         work_buf_count = w_tail - work_buf;
; 710  :         ++in_buf;

	lea	esi, DWORD PTR [esi+4]
	sub	ebx, edi
	add	esp, 12					; 0000000cH
	sar	ebx, 2

; 711  :         --in_buf_count;

	sub	DWORD PTR _in_buf_count$[ebp], 1
	jne	SHORT $LL2@ConvertCar
$LN3@ConvertCar:

; 712  :     }
; 713  :     if ((result = CheckBlockLight(work_buf, work_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _work_buf_code$[ebp]
	push	edi
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@ConvertCar
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 349  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	eax, DWORD PTR _work_buf$1$[ebp]
	mov	ecx, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 716  :     DeallocateBlock(work_buf, work_buf_words);

	push	DWORD PTR _work_buf_words$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 349  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, DWORD PTR _out_buf$[ebp]
	mov	esi, eax
	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 716  :     DeallocateBlock(work_buf, work_buf_words);

	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 717  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN13@ConvertCar:
	pop	esi
	pop	ebx
	pop	edi

; 718  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ConvertCardinalNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _MultiplyAndAdd_using_ADCX_MULX
_TEXT	SEGMENT
_u_buf$ = 8						; size = 4
_u_count$ = 12						; size = 4
_x$ = 16						; size = 4
_MultiplyAndAdd_using_ADCX_MULX PROC			; COMDAT

; 550  : {

	push	ebp
	mov	ebp, esp

; 551  :     __UNIT_TYPE k = x;
; 552  :     __UNIT_TYPE count = u_count >> 5;
; 553  :     while (count > 0)

	mov	ecx, DWORD PTR _u_buf$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _u_count$[ebp]
	mov	eax, ebx
	push	esi
	shr	eax, 5
	push	edi
	mov	edi, DWORD PTR _x$[ebp]
	test	eax, eax
	je	$LN3@MultiplyAn
	mov	ebx, eax
	npad	2
$LL2@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+4]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+8]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+12]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+16]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+20]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+24]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+28]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+32]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+32], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+36]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+36], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+40]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+40], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+44]
	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi
	mov	DWORD PTR [ecx+44], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+48]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+48], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+52]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+52], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+56]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+56], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+60]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+60], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+64]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+64], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+68]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+68], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+72]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+72], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+76]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+76], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+80]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+80], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+84]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+84], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+88]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+88], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+92]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+92], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+96]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+96], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+100]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+100], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+104]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+104], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+108]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+108], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+112]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+112], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+116]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+116], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+120]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+120], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+124]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+124], eax

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 587  :         u_buf += 32;

	sub	ecx, -128				; ffffff80H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 32					; 00000020H
	lock	 xadd	 DWORD PTR [edx], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 588  :         --count;

	sub	ebx, 1
	jne	$LL2@MultiplyAn

; 551  :     __UNIT_TYPE k = x;
; 552  :     __UNIT_TYPE count = u_count >> 5;
; 553  :     while (count > 0)

	mov	ebx, DWORD PTR _u_count$[ebp]
$LN3@MultiplyAn:

; 589  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 590  :         if (sizeof(k) == sizeof(_UINT32_T))
; 591  :             AddToMULTI32Counter(32);
; 592  :         else
; 593  :             AddToMULTI64Counter(32);
; 594  : #endif
; 595  :     }
; 596  : 
; 597  :     if (u_count & 0x10)

	test	bl, 16					; 00000010H
	je	$LN509@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+4]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+8]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+12]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+16]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+20]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+24]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+28]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+32]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+32], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+36]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+36], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+40]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+40], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+44]
	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi
	mov	DWORD PTR [ecx+44], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+48]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+48], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+52]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+52], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+56]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+56], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+60]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+60], eax

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 615  :         u_buf += 16;

	add	ecx, 64					; 00000040H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 16					; 00000010H
	lock	 xadd	 DWORD PTR [edx], eax
$LN509@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 624  :     if (u_count & 0x8)

	test	bl, 8
	je	$LN593@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+4]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+8]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+12]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+16]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+20]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+24]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+28]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 634  :         u_buf += 8;

	add	ecx, 32					; 00000020H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 8
	lock	 xadd	 DWORD PTR [edx], eax
$LN593@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 643  :     if (u_count & 0x4)

	test	bl, 4
	je	SHORT $LN637@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+4]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax
	mov	eax, 0
	adcx	edi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+8]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+12]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 649  :         u_buf += 4;

	add	ecx, 16					; 00000010H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 4
	lock	 xadd	 DWORD PTR [edx], eax
$LN637@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 658  :     if (u_count & 0x2)

	test	bl, 2
	je	SHORT $LN661@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	esi, eax

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+4]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, 2

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 662  :         u_buf += 2;

	add	ecx, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, OFFSET _statistics_info+4
	lock	 xadd	 DWORD PTR [eax], edx
$LN661@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 671  :     if (u_count & 0x1)

	test	bl, 1
	je	SHORT $LN675@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi
	mov	edi, edx
	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 674  :         u_buf += 1;

	add	ecx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1079 :     _InterlockedIncrement(&statistics_info.COUNT_MULTI32);

	lock	 inc	 (null) PTR _statistics_info+4
$LN675@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 683  :     if (k > 0)

	test	edi, edi
	je	SHORT $LN680@MultiplyAn

; 684  :     {
; 685  :         u_buf[0] = k;

	mov	DWORD PTR [ecx], edi

; 686  :         u_buf += 1;

	lea	eax, DWORD PTR [ecx+4]
	pop	edi

; 687  :     }
; 688  : 
; 689  :     return (u_buf);
; 690  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN680@MultiplyAn:
	pop	edi
	pop	esi
	mov	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
_MultiplyAndAdd_using_ADCX_MULX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _MultiplyAndAdd_using_ADC_MUL
_TEXT	SEGMENT
_u_buf$ = 8						; size = 4
_u_count$ = 12						; size = 4
_x$ = 16						; size = 4
_MultiplyAndAdd_using_ADC_MUL PROC			; COMDAT

; 407  : {

	push	ebp
	mov	ebp, esp

; 408  :     __UNIT_TYPE k = x;
; 409  :     __UNIT_TYPE count = u_count >> 5;
; 410  :     while (count > 0)

	mov	ecx, DWORD PTR _u_buf$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _u_count$[ebp]
	mov	eax, ebx
	push	esi
	shr	eax, 5
	push	edi
	mov	edi, DWORD PTR _x$[ebp]
	test	eax, eax
	je	$LN3@MultiplyAn
	mov	ebx, eax
	npad	2
$LL2@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+4]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+8]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+12]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+16]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+20]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+24]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+28]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+32]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+32], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+36]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+36], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+40]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+40], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+44]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+44], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+48]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+48], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+52]
	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi
	mov	DWORD PTR [ecx+52], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+56]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+56], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+60]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+60], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+64]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+64], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+68]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+68], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+72]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+72], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+76]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+76], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+80]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+80], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+84]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+84], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+88]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+88], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+92]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+92], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+96]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+96], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+100]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+100], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+104]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+104], eax
	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+108]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+108], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+112]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+112], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+116]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+116], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+120]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+120], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+124]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+124], eax

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 32					; 00000020H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 444  :         u_buf += 32;

	sub	ecx, -128				; ffffff80H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lock	 xadd	 DWORD PTR [edx], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 445  :         --count;

	sub	ebx, 1
	jne	$LL2@MultiplyAn

; 408  :     __UNIT_TYPE k = x;
; 409  :     __UNIT_TYPE count = u_count >> 5;
; 410  :     while (count > 0)

	mov	ebx, DWORD PTR _u_count$[ebp]
$LN3@MultiplyAn:

; 446  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 447  :         if (sizeof(k) == sizeof(_UINT32_T))
; 448  :             AddToMULTI32Counter(32);
; 449  :         else
; 450  :             AddToMULTI64Counter(32);
; 451  : #endif
; 452  :     }
; 453  : 
; 454  :     if (u_count & 0x10)

	test	bl, 16					; 00000010H
	je	$LN509@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+4]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+8]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+12]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+16]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+20]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+24]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+28]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+32]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+32], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+36]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+36], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+40]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+40], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+44]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+44], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+48]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+48], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+52]
	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi
	mov	DWORD PTR [ecx+52], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+56]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+56], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+60]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+60], eax

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 16					; 00000010H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 472  :         u_buf += 16;

	add	ecx, 64					; 00000040H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lock	 xadd	 DWORD PTR [edx], eax
$LN509@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 481  :     if (u_count & 0x8)

	test	bl, 8
	je	$LN593@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+4]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+8]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+12]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+16]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+20]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+24]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+28]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 491  :         u_buf += 8;

	add	ecx, 32					; 00000020H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lock	 xadd	 DWORD PTR [edx], eax
$LN593@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 500  :     if (u_count & 0x4)

	test	bl, 4
	je	SHORT $LN637@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+4]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+8]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+12]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 506  :         u_buf += 4;

	add	ecx, 16					; 00000010H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lock	 xadd	 DWORD PTR [edx], eax
$LN637@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 515  :     if (u_count & 0x2)

	test	bl, 2
	je	SHORT $LN661@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+4]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, 2

; 496  :     return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, OFFSET _statistics_info+4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 519  :         u_buf += 2;

	add	ecx, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lock	 xadd	 DWORD PTR [eax], edx
$LN661@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 528  :     if (u_count & 0x1)

	test	bl, 1
	je	SHORT $LN675@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, edi
	mov	edi, edx
	mov	DWORD PTR [ecx], eax
	adc	edi, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 531  :         u_buf += 1;

	add	ecx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 1079 :     _InterlockedIncrement(&statistics_info.COUNT_MULTI32);

	lock	 inc	 (null) PTR _statistics_info+4
$LN675@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 540  :     if (k > 0)

	test	edi, edi
	je	SHORT $LN680@MultiplyAn

; 541  :     {
; 542  :         u_buf[0] = k;

	mov	DWORD PTR [ecx], edi

; 543  :         u_buf += 1;

	lea	eax, DWORD PTR [ecx+4]
	pop	edi

; 544  :     }
; 545  : 
; 546  :     return (u_buf);
; 547  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN680@MultiplyAn:
	pop	edi
	pop	esi
	mov	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
_MultiplyAndAdd_using_ADC_MUL ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _MultiplyAndAdd1Word_using_ADCX_MULX
_TEXT	SEGMENT
_k$ = 8							; size = 4
_u$ = 12						; size = 4
_w_buf$ = 16						; size = 4
_MultiplyAndAdd1Word_using_ADCX_MULX PROC		; COMDAT

; 392  : {

	push	ebp
	mov	ebp, esp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	ecx, DWORD PTR _w_buf$[ebp]

; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR _u$[ebp]

; 524  :     return (_addcarryx_u32(carry, u, v, w));

	add	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	eax, edx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 404  : }

	pop	ebp
	ret	0
_MultiplyAndAdd1Word_using_ADCX_MULX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _MultiplyAndAdd1Word_using_ADC_MUL
_TEXT	SEGMENT
_k$ = 8							; size = 4
_u$ = 12						; size = 4
_w_buf$ = 16						; size = 4
_MultiplyAndAdd1Word_using_ADC_MUL PROC			; COMDAT

; 377  : {

	push	ebp
	mov	ebp, esp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h

; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	ecx, DWORD PTR _w_buf$[ebp]

; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR _u$[ebp]

; 496  :     return (_addcarry_u32(carry, u, v, w));

	add	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR [ecx], eax
	adc	edx, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c

; 388  :     return (k);

	mov	eax, edx

; 389  : }

	pop	ebp
	ret	0
_MultiplyAndAdd1Word_using_ADC_MUL ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _BuildBinaryFromDecimalString
_TEXT	SEGMENT
_in_ptr$1$ = -20					; size = 4
tv603 = -16						; size = 4
tv604 = -12						; size = 4
tv618 = -8						; size = 4
_source_count$1$ = -8					; size = 4
_out_ptr$1$ = -4					; size = 4
_source$ = 8						; size = 4
_out_buf$ = 12						; size = 4
_out_buf_count$ = 16					; size = 4
_BuildBinaryFromDecimalString PROC			; COMDAT

; 349  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx

; 350  : #ifdef _M_IX86
; 351  :     int word_digit_count = 9;
; 352  : #elif defined(_M_IX64)
; 353  :     int word_digit_count = 19;
; 354  : #else
; 355  : #error unknown platform
; 356  : #endif
; 357  :     wchar_t* in_ptr = source;
; 358  :     __UNIT_TYPE* out_ptr = out_buf;

	mov	ebx, DWORD PTR _out_buf$[ebp]
	push	esi

; 359  :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	esi, DWORD PTR _source$[ebp]
	push	edi
	push	esi
	mov	DWORD PTR _out_ptr$1$[ebp], ebx
	call	DWORD PTR __imp__lstrlenW@4

; 360  :     int r = source_count % word_digit_count;

	xor	edx, edx
	mov	ecx, eax
	mov	edi, 9
	mov	DWORD PTR _source_count$1$[ebp], ecx
	div	edi

; 361  :     if (r > 0)

	test	edx, edx
	jle	SHORT $LN17@BuildBinar

; 302  :     __UNIT_TYPE x = 0;

	xor	eax, eax

; 362  :     {
; 363  :         *out_ptr++ = BuildLeading1WordFromDecimalString(in_ptr, r);

	mov	edi, edx

; 303  :     while (count > 0)

	test	edx, edx
	je	SHORT $LN8@BuildBinar
$LL7@BuildBinar:

; 304  :     {
; 305  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -48				; ffffffd0H

; 306  :         --count;

	sub	edi, 1
	jne	SHORT $LL7@BuildBinar
	mov	ecx, DWORD PTR _source_count$1$[ebp]
$LN8@BuildBinar:

; 364  :         in_ptr += r;

	mov	esi, DWORD PTR _source$[ebp]
	mov	DWORD PTR [ebx], eax
	add	ebx, 4
	mov	DWORD PTR _out_ptr$1$[ebp], ebx

; 365  :         source_count -= r;

	sub	ecx, edx
	lea	esi, DWORD PTR [esi+edx*2]
	mov	DWORD PTR _source$[ebp], esi
$LN17@BuildBinar:

; 366  :     }
; 367  :     while (source_count > 0)

	test	ecx, ecx
	je	$LN3@BuildBinar
	dec	ecx
	mov	eax, 954437177				; 38e38e39H
	mul	ecx
	mov	eax, edx
	shr	eax, 1
	inc	eax
	mov	DWORD PTR tv618[ebp], eax
$LL2@BuildBinar:

; 333  :         x = x * 10 + (*in_ptr++ - L'0');

	movzx	eax, WORD PTR [esi+10]
	lea	ecx, DWORD PTR [esi+2]
	movzx	esi, WORD PTR [ecx]
	movzx	edx, WORD PTR [ecx+2]
	movzx	ebx, WORD PTR [ecx+6]
	movzx	edi, WORD PTR [ecx+4]
	mov	DWORD PTR tv604[ebp], eax

; 334  :     }
; 335  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 336  :     {
; 337  :         x = x * 10 + (*in_ptr++ - L'0');

	movzx	eax, WORD PTR [ecx+10]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR tv603[ebp], eax
	mov	eax, DWORD PTR _source$[ebp]
	mov	DWORD PTR _in_ptr$1$[ebp], ecx
	movzx	eax, WORD PTR [eax]

; 338  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	ecx, DWORD PTR [eax+eax*4]

; 339  :     }
; 340  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 341  :     {
; 342  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	eax, DWORD PTR [esi+ecx*2]

; 370  :         in_ptr += word_digit_count;

	mov	esi, DWORD PTR _source$[ebp]

; 342  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	ecx, DWORD PTR [eax+eax*4]

; 370  :         in_ptr += word_digit_count;

	add	esi, 18					; 00000012H

; 342  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	eax, DWORD PTR [edx+ecx*2]

; 370  :         in_ptr += word_digit_count;

	mov	DWORD PTR _source$[ebp], esi

; 342  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	edx, DWORD PTR _in_ptr$1$[ebp]
	lea	eax, DWORD PTR [edi+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ebx+ecx*2]

; 368  :     {
; 369  :         *out_ptr++ = Build1WordFromDecimalString(in_ptr);

	mov	ebx, DWORD PTR _out_ptr$1$[ebp]

; 342  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR tv604[ebp]
	movzx	eax, ax
	lea	eax, DWORD PTR [eax+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR tv603[ebp]
	movzx	eax, ax
	lea	eax, DWORD PTR [eax+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [edx]
	lea	eax, DWORD PTR [eax+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [edx+2]
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -1038366032			; c21bcab0H

; 368  :     {
; 369  :         *out_ptr++ = Build1WordFromDecimalString(in_ptr);

	mov	DWORD PTR [ebx], eax
	add	ebx, 4
	sub	DWORD PTR tv618[ebp], 1
	mov	DWORD PTR _out_ptr$1$[ebp], ebx
	jne	$LL2@BuildBinar
$LN3@BuildBinar:

; 371  :         source_count -= word_digit_count;
; 372  :     }
; 373  :     *out_buf_count = out_ptr - out_buf;

	sub	ebx, DWORD PTR _out_buf$[ebp]
	mov	eax, DWORD PTR _out_buf_count$[ebp]
	pop	edi
	sar	ebx, 2
	pop	esi
	mov	DWORD PTR [eax], ebx
	pop	ebx

; 374  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_BuildBinaryFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _Build1WordFromDecimalString
_TEXT	SEGMENT
tv383 = -8						; size = 4
tv384 = -4						; size = 4
_in_ptr$ = 8						; size = 4
_Build1WordFromDecimalString PROC			; COMDAT

; 312  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 313  :     __UNIT_TYPE x = (*in_ptr++ - L'0');

	mov	ecx, DWORD PTR _in_ptr$[ebp]
	push	ebx
	push	esi
	push	edi
	movzx	eax, WORD PTR [ecx]
	add	ecx, 2

; 314  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))
; 315  :     {
; 316  :         x = x * 10 + (*in_ptr++ - L'0');
; 317  :         x = x * 10 + (*in_ptr++ - L'0');
; 318  :         x = x * 10 + (*in_ptr++ - L'0');
; 319  :         x = x * 10 + (*in_ptr++ - L'0');
; 320  :         x = x * 10 + (*in_ptr++ - L'0');
; 321  :         x = x * 10 + (*in_ptr++ - L'0');
; 322  :         x = x * 10 + (*in_ptr++ - L'0');
; 323  :         x = x * 10 + (*in_ptr++ - L'0');
; 324  :         x = x * 10 + (*in_ptr++ - L'0');
; 325  :         x = x * 10 + (*in_ptr++ - L'0');
; 326  :     }
; 327  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))
; 328  :     {
; 329  :         x = x * 10 + (*in_ptr++ - L'0');

	movzx	edx, WORD PTR [ecx]

; 330  :         x = x * 10 + (*in_ptr++ - L'0');

	movzx	esi, WORD PTR [ecx+2]

; 331  :         x = x * 10 + (*in_ptr++ - L'0');

	movzx	edi, WORD PTR [ecx+4]

; 332  :         x = x * 10 + (*in_ptr++ - L'0');

	movzx	ebx, WORD PTR [ecx+6]
	add	ecx, 8
	mov	DWORD PTR _in_ptr$[ebp], ecx

; 333  :         x = x * 10 + (*in_ptr++ - L'0');

	movzx	ecx, WORD PTR [ecx]
	mov	DWORD PTR tv384[ebp], ecx
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx

; 334  :     }
; 335  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 336  :     {
; 337  :         x = x * 10 + (*in_ptr++ - L'0');

	add	DWORD PTR _in_ptr$[ebp], 2
	movzx	ecx, WORD PTR [ecx]
	mov	DWORD PTR tv383[ebp], ecx

; 338  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	ecx, DWORD PTR [eax+eax*4]

; 339  :     }
; 340  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 341  :     {
; 342  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	eax, DWORD PTR [edx+ecx*2]
	mov	edx, DWORD PTR _in_ptr$[ebp]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [esi+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edi+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ebx+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR tv384[ebp]
	movzx	eax, ax

; 343  :     }
; 344  :     return (x);

	pop	edi
	pop	esi
	pop	ebx
	lea	eax, DWORD PTR [eax+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR tv383[ebp]
	movzx	eax, ax
	lea	eax, DWORD PTR [eax+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [edx]
	lea	eax, DWORD PTR [eax+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [edx+2]
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -1038366032			; c21bcab0H

; 345  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Build1WordFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _BuildLeading1WordFromDecimalString
_TEXT	SEGMENT
_in_ptr$ = 8						; size = 4
_count$ = 12						; size = 4
_BuildLeading1WordFromDecimalString PROC		; COMDAT

; 301  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 302  :     __UNIT_TYPE x = 0;
; 303  :     while (count > 0)

	mov	esi, DWORD PTR _count$[ebp]
	xor	eax, eax
	test	esi, esi
	je	SHORT $LN3@BuildLeadi
	mov	edx, DWORD PTR _in_ptr$[ebp]
$LL2@BuildLeadi:

; 304  :     {
; 305  :         x = x * 10 + (*in_ptr++ - L'0');

	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [edx]
	lea	edx, DWORD PTR [edx+2]
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -48				; ffffffd0H

; 306  :         --count;

	sub	esi, 1
	jne	SHORT $LL2@BuildLeadi
$LN3@BuildLeadi:
	pop	esi

; 307  :     }
; 308  :     return (x);
; 309  : }

	pop	ebp
	ret	0
_BuildLeading1WordFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _ParseAsHexNumberString
_TEXT	SEGMENT
_state$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_in_ptr$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_int_part_buf$ = 20					; size = 4
_ParseAsHexNumberString PROC				; COMDAT

; 286  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _format_option$[ebp]
	push	ebx

; 287  :     struct __tag_PARSER_STATE state;
; 288  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, NULL);

	mov	ebx, DWORD PTR _number_styles$[ebp]
	push	0
	push	DWORD PTR _int_part_buf$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _in_ptr$[ebp]
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_InitializeParserState
	add	esp, 24					; 00000018H

; 289  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	test	bl, 1
	je	SHORT $LN38@ParseAsHex

; 112  :         switch (*state->IN_PTR)

	mov	ecx, DWORD PTR _state$[ebp]
	movzx	eax, WORD PTR [ecx]
	cmp	eax, 9
	jb	SHORT $LN38@ParseAsHex
	npad	3
$LL7@ParseAsHex:
	cmp	eax, 13					; 0000000dH
	jbe	SHORT $LN12@ParseAsHex
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN38@ParseAsHex
$LN12@ParseAsHex:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	ecx, 2
	mov	DWORD PTR _state$[ebp], ecx
	movzx	eax, WORD PTR [ecx]
	cmp	eax, 9
	jae	SHORT $LL7@ParseAsHex
$LN38@ParseAsHex:

; 290  :         SkipSpace(&state);
; 291  :     ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence

; 292  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	eax, DWORD PTR _state$[ebp]
	add	esp, 4
	test	bl, 2
	pop	ebx
	je	SHORT $LN30@ParseAsHex

; 112  :         switch (*state->IN_PTR)

	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 9
	jb	SHORT $LN30@ParseAsHex
$LL16@ParseAsHex:
	cmp	ecx, 13					; 0000000dH
	jbe	SHORT $LN21@ParseAsHex
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN30@ParseAsHex
$LN21@ParseAsHex:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	eax, 2
	mov	DWORD PTR _state$[ebp], eax
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 9
	jae	SHORT $LL16@ParseAsHex
$LN30@ParseAsHex:

; 293  :         SkipSpace(&state);
; 294  :     if (*state.IN_PTR != L'\0')

	cmp	WORD PTR [eax], 0
	je	SHORT $LN4@ParseAsHex

; 295  :         return (0);

	xor	eax, eax

; 296  :     FinalizeParserState(&state);
; 297  :     return (1);
; 298  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@ParseAsHex:

; 102  :     *state->INT_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$[ebp+72]
	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 103  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR _state$[ebp+4], 32		; 00000020H
	je	SHORT $LN25@ParseAsHex

; 104  :         *state->FRAC_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$[ebp+76]
	mov	WORD PTR [eax], cx
$LN25@ParseAsHex:

; 296  :     FinalizeParserState(&state);
; 297  :     return (1);
; 298  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ParseAsHexNumberString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _ParseAsDecimalNumberString
_TEXT	SEGMENT
_sign$GSCopy$1$ = -88					; size = 4
_state$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_in_ptr$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_sign$ = 20						; size = 4
_int_part_buf$ = 24					; size = 4
_frac_part_buf$ = 28					; size = 4
_ParseAsDecimalNumberString PROC			; COMDAT

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _format_option$[ebp]
	mov	ecx, DWORD PTR _sign$[ebp]
	push	ebx

; 190  :     struct __tag_PARSER_STATE state;
; 191  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, frac_part_buf);

	mov	ebx, DWORD PTR _number_styles$[ebp]
	push	esi
	push	edi
	push	DWORD PTR _frac_part_buf$[ebp]
	mov	DWORD PTR _sign$GSCopy$1$[ebp], ecx
	push	DWORD PTR _int_part_buf$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _in_ptr$[ebp]
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_InitializeParserState

; 192  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 24					; 00000018H
	test	bl, 1
	je	SHORT $LN61@ParseAsDec

; 112  :         switch (*state->IN_PTR)

	movzx	eax, WORD PTR [esi]
	cmp	eax, 9
	jb	SHORT $LN61@ParseAsDec
$LL33@ParseAsDec:
	cmp	eax, 13					; 0000000dH
	jbe	SHORT $LN38@ParseAsDec
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN61@ParseAsDec
$LN38@ParseAsDec:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	esi, 2
	mov	DWORD PTR _state$[ebp], esi
	movzx	eax, WORD PTR [esi]
	cmp	eax, 9
	jae	SHORT $LL33@ParseAsDec
$LN61@ParseAsDec:

; 193  :         SkipSpace(&state);
; 194  :     if ((number_styles & PMC_NUMBER_STYLE_ALLOW_PARENTHESES) && *state.IN_PTR == L'(')

	test	bl, 16					; 00000010H
	je	SHORT $LN3@ParseAsDec
	cmp	WORD PTR [esi], 40			; 00000028H
	jne	SHORT $LN3@ParseAsDec

; 195  :     {
; 196  :         state.SIGN = -1;
; 197  :         state.IN_PTR += 1;

	add	esi, 2
	mov	DWORD PTR _state$[ebp+8], -1
	mov	DWORD PTR _state$[ebp], esi
	movzx	eax, WORD PTR [esi]

; 198  :         if (*state.IN_PTR >= L'0' && *state.IN_PTR <= L'9')

	cmp	eax, 48					; 00000030H
	jb	SHORT $LN5@ParseAsDec
	cmp	eax, 57					; 00000039H
	ja	SHORT $LN5@ParseAsDec

; 199  :             ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN5@ParseAsDec:

; 200  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	bl, 32					; 00000020H
	je	SHORT $LN6@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+36]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@ParseAsDec

; 201  :         {
; 202  :             state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+44]
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], eax

; 203  :             ParseAsFractionPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN6@ParseAsDec:

; 204  :         }
; 205  :         if (*state.IN_PTR != L')')

	cmp	WORD PTR [esi], 41			; 00000029H
	jne	$LN23@ParseAsDec

; 206  :             return (0);
; 207  :         state.IN_PTR += 1;

	add	esi, 2
	mov	DWORD PTR _state$[ebp], esi

; 208  :     }

	jmp	$LN27@ParseAsDec
$LN3@ParseAsDec:

; 209  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	bl, 4
	je	$LN12@ParseAsDec

; 62   :     while (*b != L'\0')

	mov	ax, WORD PTR _state$[ebp+12]

; 209  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	lea	ecx, DWORD PTR _state$[ebp+12]

; 62   :     while (*b != L'\0')

	test	ax, ax
	je	SHORT $LN43@ParseAsDec
	movzx	edx, ax
	mov	edi, esi
	mov	eax, ecx
	sub	edi, eax
$LL42@ParseAsDec:

; 63   :     {
; 64   :         if (*a != *b)

	cmp	WORD PTR [edi+ecx], dx
	jne	SHORT $LN8@ParseAsDec

; 65   :             return (0);
; 66   :         ++a;
; 67   :         ++b;

	movzx	eax, WORD PTR [ecx+2]
	add	ecx, 2
	mov	edx, eax
	test	ax, ax
	jne	SHORT $LL42@ParseAsDec
$LN43@ParseAsDec:

; 210  :     {
; 211  :         state.SIGN = 1;
; 212  :         state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+20]
	mov	DWORD PTR _state$[ebp+8], 1

; 213  :         if (*state.IN_PTR >= L'0' && *state.IN_PTR <= L'9')
; 214  :             ParseAsIntegerPartNumberSequence(&state);
; 215  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))
; 216  :         {
; 217  :             state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 218  :             ParseAsFractionPartNumberSequence(&state);
; 219  :         }
; 220  :     }

	jmp	SHORT $LN83@ParseAsDec
$LN8@ParseAsDec:

; 221  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	eax, DWORD PTR _state$[ebp+24]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN12@ParseAsDec

; 222  :     {
; 223  :         state.SIGN = -1;
; 224  :         state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+32]
	mov	DWORD PTR _state$[ebp+8], -1
$LN83@ParseAsDec:

; 268  :         }
; 269  :         else
; 270  :         {
; 271  :         }
; 272  :     }
; 273  :     else
; 274  :         return (0);
; 275  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	lea	esi, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], esi
	movzx	eax, WORD PTR [esi]
	cmp	eax, 48					; 00000030H
	jb	SHORT $LN14@ParseAsDec
	cmp	eax, 57					; 00000039H
	ja	SHORT $LN14@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN14@ParseAsDec:
	test	bl, 32					; 00000020H
	je	SHORT $LN27@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+36]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp+44]
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], eax
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4
$LN76@ParseAsDec:
	mov	esi, DWORD PTR _state$[ebp]
$LN27@ParseAsDec:
	test	bl, 2
	je	SHORT $LN77@ParseAsDec

; 112  :         switch (*state->IN_PTR)

	movzx	eax, WORD PTR [esi]
	cmp	eax, 9
	jb	SHORT $LN77@ParseAsDec
	npad	1
$LL47@ParseAsDec:
	cmp	eax, 13					; 0000000dH
	jbe	SHORT $LN52@ParseAsDec
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN77@ParseAsDec
$LN52@ParseAsDec:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	esi, 2
	mov	DWORD PTR _state$[ebp], esi
	movzx	eax, WORD PTR [esi]
	cmp	eax, 9
	jae	SHORT $LL47@ParseAsDec
$LN77@ParseAsDec:

; 276  :         SkipSpace(&state);
; 277  :     if (*state.IN_PTR != L'\0')

	cmp	WORD PTR [esi], 0
	jne	$LN23@ParseAsDec

; 102  :     *state->INT_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$[ebp+72]
	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 103  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR _state$[ebp+4], 32		; 00000020H
	je	SHORT $LN56@ParseAsDec

; 104  :         *state->FRAC_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$[ebp+76]
	mov	WORD PTR [eax], cx
$LN56@ParseAsDec:

; 278  :         return (0);
; 279  :     FinalizeParserState(&state);
; 280  :     *sign = state.SIGN;

	mov	ecx, DWORD PTR _sign$GSCopy$1$[ebp]
	mov	eax, DWORD PTR _state$[ebp+8]
	pop	edi

; 281  :     return (1);
; 282  : }

	pop	esi
	mov	DWORD PTR [ecx], eax
	mov	eax, 1
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@ParseAsDec:

; 225  :         if (*state.IN_PTR >= L'0' && *state.IN_PTR <= L'9')
; 226  :             ParseAsIntegerPartNumberSequence(&state);
; 227  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))
; 228  :         {
; 229  :             state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 230  :             ParseAsFractionPartNumberSequence(&state);
; 231  :         }
; 232  :     }
; 233  :     else if (*state.IN_PTR >= L'0' && *state.IN_PTR <= L'9')

	movzx	eax, WORD PTR [esi]
	cmp	eax, 48					; 00000030H
	jb	$LN16@ParseAsDec
	cmp	eax, 57					; 00000039H
	ja	$LN16@ParseAsDec

; 234  :     {
; 235  :         ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence

; 236  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
	test	bl, 32					; 00000020H
	je	SHORT $LN18@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+36]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@ParseAsDec

; 237  :         {
; 238  :             state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+44]
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], eax

; 239  :             ParseAsFractionPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN18@ParseAsDec:

; 240  :         }
; 241  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	bl, 8
	je	$LN27@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+12]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN79@ParseAsDec

; 242  :         {
; 243  :             state.SIGN = 1;
; 244  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 245  :         }
; 246  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	eax, DWORD PTR _state$[ebp+24]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN27@ParseAsDec

; 247  :         {
; 248  :             state.SIGN = -1;
; 249  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+32]
	mov	DWORD PTR _state$[ebp+8], -1
	lea	esi, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], esi

; 250  :         }
; 251  :         else
; 252  :         {
; 253  :         }
; 254  :     }

	jmp	$LN27@ParseAsDec
$LN16@ParseAsDec:

; 255  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	bl, 32					; 00000020H
	je	$LN23@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+36]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@ParseAsDec

; 256  :     {
; 257  :         state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+44]
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], eax

; 258  :         ParseAsFractionPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4

; 259  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	bl, 8
	je	$LN76@ParseAsDec
	mov	esi, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR _state$[ebp+12]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@ParseAsDec
$LN79@ParseAsDec:

; 268  :         }
; 269  :         else
; 270  :         {
; 271  :         }
; 272  :     }
; 273  :     else
; 274  :         return (0);
; 275  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	eax, DWORD PTR _state$[ebp+20]
	mov	DWORD PTR _state$[ebp+8], 1
	lea	esi, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], esi
	jmp	$LN27@ParseAsDec
$LN25@ParseAsDec:

; 260  :         {
; 261  :             state.SIGN = 1;
; 262  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 263  :         }
; 264  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	eax, DWORD PTR _state$[ebp+24]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN27@ParseAsDec

; 265  :         {
; 266  :             state.SIGN = -1;
; 267  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+32]
	mov	DWORD PTR _state$[ebp+8], -1

; 268  :         }
; 269  :         else
; 270  :         {
; 271  :         }
; 272  :     }
; 273  :     else
; 274  :         return (0);
; 275  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	lea	esi, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], esi
	jmp	$LN27@ParseAsDec
$LN23@ParseAsDec:

; 281  :     return (1);
; 282  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	eax, eax
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ParseAsDecimalNumberString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _ParseAsFractionPartNumberSequence
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ParseAsFractionPartNumberSequence PROC			; COMDAT

; 161  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _state$[ebp]
$LN15@ParseAsFra:

; 162  :     for (;;)
; 163  :     {
; 164  :         if (*state->IN_PTR >= L'0' && *state->IN_PTR <= L'9')

	mov	ecx, DWORD PTR [eax]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 48					; 00000030H
	jb	SHORT $LN5@ParseAsFra
	cmp	edx, 57					; 00000039H
	ja	SHORT $LN5@ParseAsFra

; 165  :         {
; 166  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	ecx, DWORD PTR [eax+76]
	mov	WORD PTR [ecx], dx

; 167  :             state->FRAC_PART_PTR += 1;

	add	DWORD PTR [eax+76], 2

; 168  :             state->IN_PTR += 1;

	add	DWORD PTR [eax], 2

; 169  :         }

	jmp	SHORT $LN15@ParseAsFra
$LN5@ParseAsFra:

; 170  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && *state->IN_PTR >= L'a' && *state->IN_PTR <= L'f')

	test	DWORD PTR [eax+4], 512			; 00000200H
	je	SHORT $LN9@ParseAsFra
	cmp	edx, 97					; 00000061H
	jb	SHORT $LN7@ParseAsFra
	cmp	edx, 102				; 00000066H
	ja	SHORT $LN7@ParseAsFra

; 171  :         {
; 172  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	ecx, DWORD PTR [eax+76]
	mov	WORD PTR [ecx], dx

; 173  :             state->FRAC_PART_PTR += 1;

	add	DWORD PTR [eax+76], 2

; 174  :             state->IN_PTR += 1;

	add	DWORD PTR [eax], 2

; 175  :         }

	jmp	SHORT $LN15@ParseAsFra
$LN7@ParseAsFra:

; 176  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && *state->IN_PTR >= L'A' && *state->IN_PTR <= L'F')

	cmp	edx, 65					; 00000041H
	jb	SHORT $LN9@ParseAsFra
	cmp	edx, 70					; 00000046H
	ja	SHORT $LN9@ParseAsFra

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	ecx, DWORD PTR [eax+76]
	mov	WORD PTR [ecx], dx

; 179  :             state->FRAC_PART_PTR += 1;

	add	DWORD PTR [eax+76], 2

; 180  :             state->IN_PTR += 1;

	add	DWORD PTR [eax], 2

; 181  :         }
; 182  :         else
; 183  :             break;
; 184  :     }

	jmp	SHORT $LN15@ParseAsFra
$LN9@ParseAsFra:

; 185  : }

	pop	ebp
	ret	0
_ParseAsFractionPartNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _ParseAsIntegerPartNumberSequence
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ParseAsIntegerPartNumberSequence PROC			; COMDAT

; 130  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _state$[ebp]
	push	ebx
	push	esi
	push	edi
$LN42@ParseAsInt:

; 131  :     for (;;)
; 132  :     {
; 133  :         if (*state->IN_PTR >= L'0' && *state->IN_PTR <= L'9')

	mov	esi, DWORD PTR [eax]
	movzx	edx, WORD PTR [esi]
	cmp	edx, 48					; 00000030H
	jb	SHORT $LN5@ParseAsInt
	cmp	edx, 57					; 00000039H
	ja	SHORT $LN5@ParseAsInt

; 134  :         {
; 135  :             *state->INT_PART_PTR = *state->IN_PTR;

	mov	ecx, DWORD PTR [eax+72]
	mov	WORD PTR [ecx], dx

; 136  :             state->INT_PART_PTR += 1;

	add	DWORD PTR [eax+72], 2

; 137  :             state->IN_PTR += 1;

	add	DWORD PTR [eax], 2

; 138  :         }

	jmp	SHORT $LN42@ParseAsInt
$LN5@ParseAsInt:

; 139  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && *state->IN_PTR >= L'a' && *state->IN_PTR <= L'f')

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, 512				; 00000200H
	je	SHORT $LN9@ParseAsInt
	cmp	edx, 97					; 00000061H
	jb	SHORT $LN7@ParseAsInt
	cmp	edx, 102				; 00000066H
	ja	SHORT $LN7@ParseAsInt

; 140  :         {
; 141  :             *state->INT_PART_PTR = *state->IN_PTR;

	mov	ecx, DWORD PTR [eax+72]
	mov	WORD PTR [ecx], dx

; 142  :             state->INT_PART_PTR += 1;

	add	DWORD PTR [eax+72], 2

; 143  :             state->IN_PTR += 1;

	add	DWORD PTR [eax], 2

; 144  :         }

	jmp	SHORT $LN42@ParseAsInt
$LN7@ParseAsInt:

; 145  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && *state->IN_PTR >= L'A' && *state->IN_PTR <= L'F')

	cmp	edx, 65					; 00000041H
	jb	SHORT $LN9@ParseAsInt
	cmp	edx, 70					; 00000046H
	ja	SHORT $LN9@ParseAsInt

; 146  :         {
; 147  :             *state->INT_PART_PTR = *state->IN_PTR;

	mov	ecx, DWORD PTR [eax+72]
	mov	WORD PTR [ecx], dx

; 148  :             state->INT_PART_PTR += 1;

	add	DWORD PTR [eax+72], 2

; 149  :             state->IN_PTR += 1;

	add	DWORD PTR [eax], 2

; 150  :         }

	jmp	SHORT $LN42@ParseAsInt
$LN9@ParseAsInt:

; 151  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && StartsWith(state->IN_PTR, state->GROUP_SEPARATOR))

	test	cl, 64					; 00000040H
	je	SHORT $LN30@ParseAsInt

; 62   :     while (*b != L'\0')

	movzx	ecx, WORD PTR [eax+48]

; 151  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && StartsWith(state->IN_PTR, state->GROUP_SEPARATOR))

	lea	edx, DWORD PTR [eax+48]

; 62   :     while (*b != L'\0')

	test	cx, cx
	je	SHORT $LN18@ParseAsInt
	mov	edi, ecx
	sub	esi, edx
	npad	7
$LL17@ParseAsInt:

; 63   :     {
; 64   :         if (*a != *b)

	cmp	WORD PTR [esi+edx], di
	jne	SHORT $LN36@ParseAsInt

; 65   :             return (0);
; 66   :         ++a;
; 67   :         ++b;

	movzx	ecx, WORD PTR [edx+2]
	add	edx, 2
	mov	edi, ecx
	test	cx, cx
	jne	SHORT $LL17@ParseAsInt
$LN18@ParseAsInt:

; 152  :             state->IN_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	ecx, DWORD PTR [eax+56]
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 155  :         else
; 156  :             break;
; 157  :     }

	jmp	$LN42@ParseAsInt
$LN36@ParseAsInt:

; 153  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && state->SECONDARY_GROUP_SEPARATOR_LENGTH > 0 && StartsWith(state->IN_PTR, state->SECONDARY_GROUP_SEPARATOR))

	mov	ebx, DWORD PTR [eax+68]
	test	ebx, ebx
	jle	SHORT $LN30@ParseAsInt

; 62   :     while (*b != L'\0')

	movzx	ecx, WORD PTR [eax+60]

; 153  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && state->SECONDARY_GROUP_SEPARATOR_LENGTH > 0 && StartsWith(state->IN_PTR, state->SECONDARY_GROUP_SEPARATOR))

	lea	edx, DWORD PTR [eax+60]

; 62   :     while (*b != L'\0')

	test	cx, cx
	je	SHORT $LN23@ParseAsInt
	mov	edi, DWORD PTR [eax]
	mov	esi, ecx
	sub	edi, edx
	npad	7
$LL22@ParseAsInt:

; 63   :     {
; 64   :         if (*a != *b)

	cmp	WORD PTR [edi+edx], si
	jne	SHORT $LN30@ParseAsInt

; 65   :             return (0);
; 66   :         ++a;
; 67   :         ++b;

	movzx	ecx, WORD PTR [edx+2]
	add	edx, 2
	mov	esi, ecx
	test	cx, cx
	jne	SHORT $LL22@ParseAsInt
$LN23@ParseAsInt:

; 154  :             state->IN_PTR += state->SECONDARY_GROUP_SEPARATOR_LENGTH;

	lea	ecx, DWORD PTR [ebx+ebx]
	add	DWORD PTR [eax], ecx
	jmp	$LN42@ParseAsInt
$LN30@ParseAsInt:
	pop	edi

; 158  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_ParseAsIntegerPartNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _SkipSpace
_TEXT	SEGMENT
_state$ = 8						; size = 4
_SkipSpace PROC						; COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp

; 110  :     for (;;)
; 111  :     {
; 112  :         switch (*state->IN_PTR)

	mov	ecx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [ecx]
	movzx	eax, WORD PTR [eax]
	cmp	eax, 9
	jb	SHORT $LN11@SkipSpace
$LL2@SkipSpace:
	cmp	eax, 13					; 0000000dH
	jbe	SHORT $LN7@SkipSpace
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN11@SkipSpace
$LN7@SkipSpace:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	DWORD PTR [ecx], 2
	mov	eax, DWORD PTR [ecx]
	movzx	eax, WORD PTR [eax]
	cmp	eax, 9
	jae	SHORT $LL2@SkipSpace
$LN11@SkipSpace:

; 126  :     }
; 127  : }

	pop	ebp
	ret	0
_SkipSpace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _FinalizeParserState
_TEXT	SEGMENT
_state$ = 8						; size = 4
_FinalizeParserState PROC				; COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp

; 102  :     *state->INT_PART_PTR = L'\0';

	mov	ecx, DWORD PTR _state$[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR [ecx+72]
	mov	WORD PTR [eax], dx

; 103  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR [ecx+4], 32			; 00000020H
	je	SHORT $LN2@FinalizePa

; 104  :         *state->FRAC_PART_PTR = L'\0';

	mov	eax, DWORD PTR [ecx+76]
	xor	ecx, ecx
	mov	WORD PTR [eax], cx
$LN2@FinalizePa:

; 105  : }

	pop	ebp
	ret	0
_FinalizeParserState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _InitializeParserState
_TEXT	SEGMENT
_state$ = 8						; size = 4
_in_ptr$ = 12						; size = 4
_number_styles$ = 16					; size = 4
_format_option$ = 20					; size = 4
_int_part_buf$ = 24					; size = 4
_frac_part_buf$ = 28					; size = 4
_InitializeParserState PROC				; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     state->IN_PTR = in_ptr;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _in_ptr$[ebp]
	push	ebx

; 75   :     state->NUMBER_STYLES = number_styles;
; 76   :     state->SIGN = 0;
; 77   :     lstrcpyW(state->POSITIVE_SIGN, format_option->PositiveSign);

	mov	ebx, DWORD PTR __imp__lstrcpyW@8
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _number_styles$[ebp]
	push	esi
	mov	DWORD PTR [ecx+4], eax
	lea	esi, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _format_option$[ebp]
	push	edi
	add	eax, 16					; 00000010H
	mov	DWORD PTR [ecx+8], 0
	push	eax
	push	esi
	call	ebx

; 78   :     state->POSITIVE_SIGN_LENGTH = lstrlenW(state->POSITIVE_SIGN);

	mov	edi, DWORD PTR __imp__lstrlenW@4
	push	esi
	call	edi
	mov	esi, DWORD PTR _state$[ebp]
	mov	DWORD PTR [esi+20], eax

; 79   :     lstrcpyW(state->NEGATIVE_SIGN, format_option->NegativeSign);

	add	esi, 24					; 00000018H
	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 22					; 00000016H
	push	eax
	push	esi
	call	ebx

; 80   :     state->NEGATIVE_SIGN_LENGTH = lstrlenW(state->NEGATIVE_SIGN);

	push	esi
	call	edi
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 81   :     lstrcpyW(state->DECIMAL_SEPARATOR, format_option->DecimalSeparator);

	lea	esi, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	esi
	call	ebx

; 82   :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(state->DECIMAL_SEPARATOR);

	push	esi
	call	edi
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 83   :     lstrcpyW(state->GROUP_SEPARATOR, format_option->GroupSeparator);

	lea	esi, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 4
	push	eax
	push	esi
	call	ebx

; 84   :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(state->GROUP_SEPARATOR);

	push	esi
	call	edi
	mov	ecx, DWORD PTR _state$[ebp]

; 85   :     if (state->GROUP_SEPARATOR[0] == L'\xa0' && state->GROUP_SEPARATOR[1] == L'\0')

	pop	edi
	mov	DWORD PTR [ecx+56], eax
	mov	eax, 160				; 000000a0H
	cmp	WORD PTR [esi], ax
	pop	esi
	pop	ebx
	jne	SHORT $LN2@Initialize
	cmp	WORD PTR [ecx+50], 0
	jne	SHORT $LN2@Initialize

; 86   :     {
; 87   :         state->SECONDARY_GROUP_SEPARATOR[0] = L'\x20';
; 88   :         state->SECONDARY_GROUP_SEPARATOR[1] = L'\0';

	xor	eax, eax
	mov	WORD PTR [ecx+62], ax

; 89   :         state->SECONDARY_GROUP_SEPARATOR_LENGTH = 1;

	mov	eax, 1
	lea	edx, DWORD PTR [eax+31]

; 90   :     }

	jmp	SHORT $LN3@Initialize
$LN2@Initialize:

; 91   :     else
; 92   :     {
; 93   :         state->SECONDARY_GROUP_SEPARATOR[0] = L'\0';
; 94   :         state->SECONDARY_GROUP_SEPARATOR_LENGTH = 0;

	xor	eax, eax
	xor	edx, edx
$LN3@Initialize:

; 95   :     }
; 96   :     state->INT_PART_PTR = int_part_buf;

	mov	WORD PTR [ecx+60], dx
	mov	DWORD PTR [ecx+68], eax
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 97   :     state->FRAC_PART_PTR = frac_part_buf;

	mov	eax, DWORD PTR _frac_part_buf$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 98   : }

	pop	ebp
	ret	0
_InitializeParserState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _StartsWith
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_StartsWith PROC					; COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp

; 62   :     while (*b != L'\0')

	mov	eax, DWORD PTR _b$[ebp]
	push	esi
	movzx	ecx, WORD PTR [eax]
	test	cx, cx
	je	SHORT $LN3@StartsWith
	mov	esi, DWORD PTR _a$[ebp]
	mov	edx, ecx
	sub	esi, eax
$LL2@StartsWith:

; 63   :     {
; 64   :         if (*a != *b)

	cmp	WORD PTR [esi+eax], dx
	jne	SHORT $LN7@StartsWith

; 66   :         ++a;
; 67   :         ++b;

	movzx	ecx, WORD PTR [eax+2]
	add	eax, 2
	mov	edx, ecx
	test	cx, cx
	jne	SHORT $LL2@StartsWith
$LN3@StartsWith:

; 68   :     }
; 69   :     return (1);

	mov	eax, 1
	pop	esi

; 70   : }

	pop	ebp
	ret	0
$LN7@StartsWith:

; 65   :             return (0);

	xor	eax, eax
	pop	esi

; 70   : }

	pop	ebp
	ret	0
_StartsWith ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _AddToMULTI64Counter
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToMULTI64Counter PROC				; COMDAT

; 1107 : {

	push	ebp
	mov	ebp, esp

; 1108 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info
	lock	 xadd	 DWORD PTR [ecx], eax

; 1109 : }

	pop	ebp
	ret	0
_AddToMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _AddToMULTI32Counter
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToMULTI32Counter PROC				; COMDAT

; 1101 : {

	push	ebp
	mov	ebp, esp

; 1102 :     _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info+4
	lock	 xadd	 DWORD PTR [ecx], eax

; 1103 : }

	pop	ebp
	ret	0
_AddToMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _IncrementMULTI64Counter
_TEXT	SEGMENT
_IncrementMULTI64Counter PROC				; COMDAT

; 1085 :     _InterlockedIncrement(&statistics_info.COUNT_MULTI64);

	lock	 inc	 (null) PTR _statistics_info

; 1086 : }

	ret	0
_IncrementMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT _IncrementMULTI32Counter
_TEXT	SEGMENT
_IncrementMULTI32Counter PROC				; COMDAT

; 1079 :     _InterlockedIncrement(&statistics_info.COUNT_MULTI32);

	lock	 inc	 (null) PTR _statistics_info+4

; 1080 : }

	ret	0
_IncrementMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT __MULTIPLYX_UNIT
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_w_hi$ = 16						; size = 4
__MULTIPLYX_UNIT PROC					; COMDAT

; 616  : {

	push	ebp
	mov	ebp, esp

; 617  : #ifdef _MSC_VER
; 618  : #ifdef _M_IX86
; 619  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, DWORD PTR _u$[ebp]
	mul	DWORD PTR _v$[ebp]

; 464  :     *result_high = (_UINT32_T)(value >> 32);

	mov	ecx, DWORD PTR _w_hi$[ebp]
	mov	DWORD PTR [ecx], edx

; 620  : #elif defined(_M_X64)
; 621  :     return (_mulx_u64(u, v, w_hi));
; 622  : #else
; 623  : #error unknown platform
; 624  : #endif
; 625  : #elif defined(__GNUC__)
; 626  : #ifdef _M_IX86
; 627  :     _UINT32_T w_lo;
; 628  :     __asm__("mulxl %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 629  :     return (w_lo);
; 630  : #elif defined(_M_X64)
; 631  :     _UINT64_T w_lo;
; 632  :     __asm__("mulxq %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 633  :     return (w_lo);
; 634  : #else
; 635  : #error unknown platform
; 636  : #endif
; 637  : #else
; 638  : #error unknown compiler
; 639  : #endif
; 640  : }

	pop	ebp
	ret	0
__MULTIPLYX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT __MULTIPLY_UNIT
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_w_hi$ = 16						; size = 4
__MULTIPLY_UNIT PROC					; COMDAT

; 578  : {

	push	ebp
	mov	ebp, esp

; 579  : #ifdef _M_IX86
; 580  : #ifdef _MSC_VER
; 581  :     return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, DWORD PTR _u$[ebp]
	mul	DWORD PTR _v$[ebp]

; 464  :     *result_high = (_UINT32_T)(value >> 32);

	mov	ecx, DWORD PTR _w_hi$[ebp]
	mov	DWORD PTR [ecx], edx

; 582  : #elif defined(__GNUC__)
; 583  :     _UINT32_T w_lo;
; 584  :     __asm__("mull %3": "=a"(w_lo), "=d"(*w_hi) : "0"(u), "rm"(v));
; 585  :     return (w_lo);
; 586  : #else
; 587  : #error unknown compiler
; 588  : #endif
; 589  : #elif defined(_M_X64)
; 590  :     return (_umul128(u, v, w_hi));
; 591  : #else
; 592  : #error unknown platform
; 593  : #endif
; 594  : }

	pop	ebp
	ret	0
__MULTIPLY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT __ADDX_UNIT
_TEXT	SEGMENT
_carry$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__ADDX_UNIT PROC					; COMDAT

; 522  : {

	push	ebp
	mov	ebp, esp

; 523  : #ifdef _M_IX86
; 524  :     return (_addcarryx_u32(carry, u, v, w));

	mov	al, BYTE PTR _carry$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	add	al, 255					; 000000ffH
	mov	ecx, DWORD PTR _u$[ebp]
	adcx	ecx, DWORD PTR _v$[ebp]
	setb	al
	mov	DWORD PTR [edx], ecx

; 525  : #elif defined(_M_X64)
; 526  :     return (_addcarryx_u64(carry, u, v, w));
; 527  : #else
; 528  : #error unknown platform
; 529  : #endif
; 530  : }

	pop	ebp
	ret	0
__ADDX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT __ADD_UNIT
_TEXT	SEGMENT
_carry$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__ADD_UNIT PROC						; COMDAT

; 494  : {

	push	ebp
	mov	ebp, esp

; 495  : #ifdef _M_IX86
; 496  :     return (_addcarry_u32(carry, u, v, w));

	mov	al, BYTE PTR _carry$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	add	al, 255					; 000000ffH
	mov	ecx, DWORD PTR _u$[ebp]
	adc	ecx, DWORD PTR _v$[ebp]
	setb	al
	mov	DWORD PTR [edx], ecx

; 497  : #elif defined(_M_X64)
; 498  :     return (_addcarry_u64(carry, u, v, w));
; 499  : #else
; 500  : #error unknown platform
; 501  : #endif
; 502  : }

	pop	ebp
	ret	0
__ADD_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT __DIVIDE_CEILING_SIZE
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
__DIVIDE_CEILING_SIZE PROC				; COMDAT

; 479  : {

	push	ebp
	mov	ebp, esp

; 480  :     return ((u + v - 1) / v);

	mov	eax, DWORD PTR _u$[ebp]
	xor	edx, edx
	dec	eax
	add	eax, DWORD PTR _v$[ebp]
	div	DWORD PTR _v$[ebp]

; 481  : }

	pop	ebp
	ret	0
__DIVIDE_CEILING_SIZE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT __DIVIDE_CEILING_UNIT
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
__DIVIDE_CEILING_UNIT PROC				; COMDAT

; 474  : {

	push	ebp
	mov	ebp, esp

; 475  :     return ((u + v - 1) / v);

	mov	eax, DWORD PTR _u$[ebp]
	xor	edx, edx
	dec	eax
	add	eax, DWORD PTR _v$[ebp]
	div	DWORD PTR _v$[ebp]

; 476  : }

	pop	ebp
	ret	0
__DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT __FROMDWORDTOWORD
_TEXT	SEGMENT
_value$ = 8						; size = 8
_result_high$ = 16					; size = 4
__FROMDWORDTOWORD PROC					; COMDAT

; 463  : {

	push	ebp
	mov	ebp, esp

; 464  :     *result_high = (_UINT32_T)(value >> 32);

	mov	eax, DWORD PTR _result_high$[ebp]
	mov	ecx, DWORD PTR _value$[ebp+4]
	mov	DWORD PTR [eax], ecx

; 465  :     return ((_UINT32_T)value);

	mov	eax, DWORD PTR _value$[ebp]

; 466  : }

	pop	ebp
	ret	0
__FROMDWORDTOWORD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_internal.h
;	COMDAT __COPY_MEMORY_UNIT
_TEXT	SEGMENT
_d$ = 8							; size = 4
_s$ = 12						; size = 4
_count$ = 16						; size = 4
__COPY_MEMORY_UNIT PROC					; COMDAT

; 347  : {

	push	ebp
	mov	ebp, esp

; 348  : #ifdef _M_IX86
; 349  :     __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ecx, DWORD PTR _count$[ebp]
	push	esi
	mov	esi, DWORD PTR _s$[ebp]
	push	edi
	mov	edi, DWORD PTR _d$[ebp]
	rep movsd
	pop	edi
	pop	esi

; 350  : #elif defined(_M_X64)
; 351  :     __movsq(d, s, count);
; 352  : #else
; 353  : #error unknown platform
; 354  : #endif
; 355  : }

	pop	ebp
	ret	0
__COPY_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _PMC_TryParse@16
_TEXT	SEGMENT
_no$ = 8						; size = 4
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o$ = 20						; size = 4
_PMC_TryParse@16 PROC					; COMDAT

; 999  : {

	push	ebp
	mov	ebp, esp

; 1000 :     PMC_STATUS_CODE result;
; 1001 :     if (source == NULL)

	mov	ecx, DWORD PTR _source$[ebp]
	push	esi
	push	edi
	test	ecx, ecx
	je	SHORT $LN11@PMC_TryPar

; 1002 :         return (PMC_STATUS_ARGUMENT_ERROR);
; 1003 :     if (o == NULL)

	mov	esi, DWORD PTR _o$[ebp]
	test	esi, esi
	je	SHORT $LN11@PMC_TryPar

; 1004 :         return (PMC_STATUS_ARGUMENT_ERROR);
; 1005 :     if (format_option == NULL)
; 1006 :         format_option = &default_number_format_option;
; 1007 :     NUMBER_HEADER* no;
; 1008 :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER)

	mov	eax, DWORD PTR _format_option$[ebp]
	mov	edx, OFFSET _default_number_format_option
	test	eax, eax
	cmovne	edx, eax
	mov	eax, DWORD PTR _number_styles$[ebp]
	test	eax, 512				; 00000200H
	je	SHORT $LN5@PMC_TryPar

; 1009 :     {
; 1010 :         // 許可されている組み合わせのフラグ
; 1011 :         _UINT32_T mask = PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER | PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE | PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE;
; 1012 : 
; 1013 :         // 許可されていないフラグが指定されていればエラー
; 1014 :         if (number_styles & ~mask)

	test	eax, -516				; fffffdfcH
	jne	SHORT $LN11@PMC_TryPar

; 1016 : 
; 1017 :         if ((result = TryParseX(source, number_styles, format_option, &no)) != PMC_STATUS_OK)

	lea	edi, DWORD PTR _no$[ebp]
	push	edi
	push	edx
	push	eax
	push	ecx
	call	_TryParseX
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN9@PMC_TryPar

; 1031 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	16					; 00000010H
$LN5@PMC_TryPar:

; 1018 :             return (result);
; 1019 :     }
; 1020 :     else
; 1021 :     {
; 1022 :         if ((result = TryParseDN(source, number_styles, format_option, &no)) != PMC_STATUS_OK)

	lea	edi, DWORD PTR _no$[ebp]
	push	edi
	push	edx
	push	eax
	push	ecx
	call	_TryParseDN
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@PMC_TryPar
$LN9@PMC_TryPar:

; 1023 :             return (result);
; 1024 :     }
; 1025 :     *o = no;

	mov	eax, DWORD PTR _no$[ebp]
	mov	DWORD PTR [esi], eax

; 1026 : #ifdef _DEBUG
; 1027 :     if ((result = CheckNumber(*o)) != PMC_STATUS_OK)
; 1028 :         return (result);
; 1029 : #endif
; 1030 :     return (PMC_STATUS_OK);

	xor	eax, eax
	pop	edi

; 1031 : }

	pop	esi
	pop	ebp
	ret	16					; 00000010H
$LN11@PMC_TryPar:

; 1015 :             return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
$LN1@PMC_TryPar:
	pop	edi

; 1031 : }

	pop	esi
	pop	ebp
	ret	16					; 00000010H
_PMC_TryParse@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.implements\palmtree.math.core.implements\pmc_parse.c
;	COMDAT _Initialize_Parse
_TEXT	SEGMENT
_feature$ = 8						; size = 4
_Initialize_Parse PROC					; COMDAT

; 1034 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 1035 :     default_number_format_option.DecimalDigits = 2;
; 1036 :     lstrcpyW(default_number_format_option.GroupSeparator, L",");

	mov	esi, DWORD PTR __imp__lstrcpyW@8
	push	OFFSET ??_C@_13DEFPDAGF@?$AA?0@
	push	OFFSET _default_number_format_option+4
	mov	DWORD PTR _default_number_format_option, 2
	call	esi

; 1037 :     lstrcpyW(default_number_format_option.DecimalSeparator, L".");

	push	OFFSET ??_C@_13JOFGPIOO@?$AA?4@
	push	OFFSET _default_number_format_option+10
	call	esi

; 1038 :     lstrcpy(default_number_format_option.GroupSizes, "3");

	push	OFFSET ??_C@_01EKENIIDA@3@
	push	OFFSET _default_number_format_option+28
	call	DWORD PTR __imp__lstrcpyA@8

; 1039 :     lstrcpyW(default_number_format_option.PositiveSign, L"+");

	push	OFFSET ??_C@_13KJIIAINM@?$AA?$CL@
	push	OFFSET _default_number_format_option+16
	call	esi

; 1040 :     lstrcpyW(default_number_format_option.NegativeSign, L"-");

	push	OFFSET ??_C@_13IMODFHAA@?$AA?9@
	push	OFFSET _default_number_format_option+22
	call	esi
	mov	eax, DWORD PTR _feature$[ebp]

; 1041 : 
; 1042 :     if (feature->PROCESSOR_FEATURE_ADX && feature->PROCESSOR_FEATURE_BMI2)
; 1043 :         fp_MultiplyAndAdd = MultiplyAndAdd_using_ADCX_MULX;
; 1044 :     else
; 1045 :         fp_MultiplyAndAdd = MultiplyAndAdd_using_ADC_MUL;
; 1046 : 
; 1047 :     return (PMC_STATUS_OK);

	mov	ecx, OFFSET _MultiplyAndAdd_using_ADCX_MULX
	mov	edx, OFFSET _MultiplyAndAdd_using_ADC_MUL
	pop	esi
	mov	eax, DWORD PTR [eax]
	and	eax, 10					; 0000000aH
	cmp	al, 10					; 0000000aH
	cmovne	ecx, edx
	xor	eax, eax
	mov	DWORD PTR _fp_MultiplyAndAdd, ecx

; 1048 : }

	pop	ebp
	ret	0
_Initialize_Parse ENDP
_TEXT	ENDS
END
